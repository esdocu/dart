<!DOCTYPE html>
<html>
  

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Language" content="es_ES" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-M146BEZEJV"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-M146BEZEJV');
  </script>

  <meta name="description" content="Details for diagnostics produced by the Dart analyzer.">
  <title>Diagnostic messages | Dart es Español</title>

  <!-- Favicon / Touch Icons -->
  <link rel="icon" sizes="64x64" href="/assets/shared/dart/icon/64.png">
  <link href="/assets/img/touch-icon-iphone.png" rel="apple-touch-icon">
  <link href="/assets/img/touch-icon-ipad.png" rel="apple-touch-icon" sizes="152x152">
  <link href="/assets/img/touch-icon-iphone-retina.png" rel="apple-touch-icon" sizes="180x180">
  <link href="/assets/img/touch-icon-ipad-retina.png" rel="apple-touch-icon" sizes="167x167">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@dart_lang" />
  <meta name="twitter:title" content="Diagnostic messages" />
  <meta name="twitter:description" content="Details for diagnostics produced by the Dart analyzer." />

  <!-- Open Graph -->
  <meta property="og:title" content="Diagnostic messages" />
  <meta property="og:description" content="Details for diagnostics produced by the Dart analyzer." />
  <meta property="og:url" content="https://dart.esdocu.com/tools/diagnostic-messages.html" />
  
  <meta property="og:image" content="https://dart.esdocu.com/assets/shared/dart-logo-for-shares.png?2" />
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans+Display:wght@400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans+Mono:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons&display=swap" rel="stylesheet">
  <script 
    src="https://use.fontawesome.com/releases/v5.15.4/js/all.js"
    data-auto-replace-svg="nest">
  </script>

  <link rel="stylesheet" href="/assets/css/main.css?v=1662050124">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
          integrity="sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK"
          crossorigin="anonymous"
          referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.1/umd/popper.min.js"
          integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN"
          crossorigin="anonymous"
          referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.1/js/bootstrap.min.js"
          integrity="sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2"
          crossorigin="anonymous"
          referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/3.0.1/js.cookie.min.js" 
          integrity="sha512-wT7uPE7tOP6w4o28u1DN775jYjHQApdBnib5Pho4RB0Pgd9y7eSkAV1BTqQydupYDB9GBhTcQQzyNMPMV3cAew==" 
          crossorigin="anonymous" 
          referrerpolicy="no-referrer"></script>

  <script src="/assets/js/vendor/code-prettify/prettify.js"></script>
  <script src="/assets/js/vendor/code-prettify/lang-css.js"></script>
  <script src="/assets/js/vendor/code-prettify/lang-dart.js"></script>
  <script src="/assets/js/vendor/code-prettify/lang-yaml.js"></script>
  <script src="/assets/js/os-tabs.js?v=1662050124"></script>
  <script src="/assets/js/utilities.js?v=1662050124"></script>
  <script src="/assets/js/main.js?v=1662050124"></script>

  <script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26406144-4', 'auto');
ga('send', 'pageview');

</script>


 </head>

  <body class="default show_banner">
    <section id="cookie-notice">
  <div class="container">
    <p>Google utiliza cookies para prestar sus servicios, personalizar anuncios y analizar el tráfico. 
      Puedes ajustar tus controles de privacidad en cualquier momento en tu 
      <a href="https://myaccount.google.com/data-and-personalization" target="_blank" rel="noopener" class="no-automatic-external">Configuración de Google</a>.
      <a href="https://policies.google.com/technologies/cookies" target="_blank" rel="noopener" class="no-automatic-external">Más información</a>.
    </p>
    <button id="cookie-consent" class="btn btn-primary">Está bien</button>
  </div>
</section>

    <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5VSZM5J"
 height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

    <header id="page-header" class="site-header">
  <nav id="mainnav" class="site-header">
  <div id="menu-toggle"><i class="material-icons">menu</i></div>
  <a href="/" class="brand" title="Dart es Español">
    <img src="/assets/img/shared/dart/logo+text/horizontal/white.svg" alt="Dart es Español">
  </a>
  <ul class="navbar">
    <li>
      <a href="/overview" class="nav-link">Overview</a>
    </li>
    <li class="mainnav__get-started">
      <a href="/guides" class="nav-link
         active">
        <span>Docs</span>
      </a>
    </li>
    <li>
      <a href="/community" class="nav-link">Comunidad</a>
    </li>
    <li>
      <a href="/#try-dart" class="nav-link">Probar Dart</a>
    </li>
    <li>
      <a href="/get-dart" class="nav-link">Obtener Dart</a>
    </li>
    <li class="searchfield">
      <form action="/search" class="site-header__search form-inline" id="cse-search-box">
        <input type="hidden" name="cx" value="011220921317074318178:_yy-tmb5t_i">
        <input type="hidden" name="ie" value="UTF-8">
        <input type="hidden" name="hl" value="en">
        <input class="site-header__searchfield form-control search-field" type="search" name="q"
          id="q" autocomplete="off" placeholder="Search" aria-label="Search">
      </form>
    </li>
  </ul>
</nav>

  
</header>
 <div class="banner">
  <p class="banner__text">
    Dart 2.18 ya está disponible con interoperabilidad de Objective-C y Swift y mejoras de networking, la inferencia de tipos y el rendimiento del código asíncrono. <a href="https://medium.com/@mit.mit/dart-2-18-f4b3101f146c">Más información</a><br>
    Los equipos de Flutter y Dart están contratando.
    <a href="https://docs.flutter.dev/jobs">Más información</a>
  </p>
</div> 

    <div id="sidenav" class="">
  <form action="/search/" class="site-header__search form-inline">
    <input class="site-header__searchfield form-control search-field" type="search" name="q"
           id="q" autocomplete="off" placeholder="Search" aria-label="Search">
  </form>

  <div class="site-sidebar">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a href="/overview" class="nav-link">Overview</a>
      </li>
      <li class="nav-item">
        <a href="/community" class="nav-link">Comunidad</a>
      </li>
      <li class="nav-item">
        <a href="https://dartpad.dev" class="nav-link">Probar Dart</a>
      </li>
      <li class="nav-item">
        <a href="/get-dart" class="nav-link">Obtener Dart</a>
      </li>
      <li class="nav-item">
        <a href="/guides" class="nav-link active">Docs</a>
      </li>
    </ul>

    <ul class="nav flex-column"><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-1" role="button"
        aria-expanded="false" aria-controls="sidenav-1"
      >Samples & tutorials</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-1">
        <li class="nav-item">
    <a class="nav-link" href="/samples">Language samples</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable"
      data-toggle="collapse" data-target="#sidenav-1-2"
      href="#sidenav-1-2" role="button"
      aria-expanded="true" aria-controls="sidenav-1-2"
    >Codelabs
    </a>
    <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-1-2">
      <li class="nav-item">
    <a class="nav-link" href="/codelabs">List of Dart codelabs</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/codelabs/dart-cheatsheet">Language cheatsheet</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/codelabs/iterables">Iterable collections</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/codelabs/async-await">Asynchronous programming</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/codelabs/null-safety">Null safety</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/tutorials">Tutorials</a>
  </li>
</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-2" role="button"
        aria-expanded="false" aria-controls="sidenav-2"
      >Language</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-2">
        <li class="nav-item">
    <a class="nav-link" href="/guides/language/language-tour">Tour</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/type-system">Type system</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-2-3"
      href="#sidenav-2-3" role="button"
      aria-expanded="false" aria-controls="sidenav-2-3"
    >Effective Dart
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-2-3">
      <li class="nav-item">
    <a class="nav-link" href="/guides/language/effective-dart">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/effective-dart/style">Style</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/effective-dart/documentation">Documentation</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/effective-dart/usage">Usage</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/effective-dart/design">Design</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-2-4"
      href="#sidenav-2-4" role="button"
      aria-expanded="false" aria-controls="sidenav-2-4"
    >Coming from ...
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-2-4">
      <li class="nav-item">
    <a class="nav-link" href="/guides/language/coming-from/js-to-dart">JavaScript to Dart</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/guides/language/extension-methods">Extension methods</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/concurrency">Concurrency</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/numbers">Numbers</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-2-8"
      href="#sidenav-2-8" role="button"
      aria-expanded="false" aria-controls="sidenav-2-8"
    >Null safety
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-2-8">
      <li class="nav-item">
    <a class="nav-link" href="/null-safety">Overview: Sound null safety</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/null-safety/migration-guide">Migrating to null safety</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/null-safety/understanding-null-safety">Understanding null safety</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/null-safety/unsound-null-safety">Unsound null safety</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/null-safety/faq">FAQ</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/guides/language/evolution">Evolution</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/spec">Specification</a>
  </li>
</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-3" role="button"
        aria-expanded="false" aria-controls="sidenav-3"
      >Core libraries</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-3">
        <li class="nav-item">
    <a class="nav-link" href="/guides/libraries">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/library-tour">Tour</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-3-3"
      href="#sidenav-3-3" role="button"
      aria-expanded="false" aria-controls="sidenav-3-3"
    >Articles
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-3-3">
      <li class="nav-item">
    <a class="nav-link" href="/articles/libraries/dart-io">Intro to dart:io</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/articles/libraries/creating-streams">Creating streams</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-4" role="button"
        aria-expanded="false" aria-controls="sidenav-4"
      >Packages</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-4">
        <li class="nav-item">
    <a class="nav-link" href="/guides/packages">How to use packages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/useful-libraries">Commonly used packages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/create-library-packages">Creating packages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/publishing">Publishing packages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/writing-package-pages">Writing package pages</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-4-6"
      href="#sidenav-4-6" role="button"
      aria-expanded="false" aria-controls="sidenav-4-6"
    >Package reference
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-4-6">
      <li class="nav-item">
    <a class="nav-link" href="/tools/pub/dependencies">Dependencies</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/glossary">Glossary</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/package-layout">Package layout conventions</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/environment-variables">Pub environment variables</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/pubspec">Pubspec file</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/troubleshoot">Troubleshooting pub</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/verified-publishers">Verified publishers</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/versioning">Versioning</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-5" role="button"
        aria-expanded="false" aria-controls="sidenav-5"
      >Development</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5">
        <li class="nav-item">
    <a class="nav-link" href="/codelabs/async-await">Futures, async, await</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/language/streams">Streams</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/json">JSON</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-4"
      href="#sidenav-5-4" role="button"
      aria-expanded="false" aria-controls="sidenav-5-4"
    >Interoperability
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-4">
      <li class="nav-item">
    <a class="nav-link" href="/guides/libraries/c-interop">C interop</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/objective-c-interop">Objective-C and Swift interop</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/web/js-interop">JavaScript interop</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/guides/google-apis">Google APIs</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/multiplatform-apps">Multi-platform apps</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-7"
      href="#sidenav-5-7" role="button"
      aria-expanded="false" aria-controls="sidenav-5-7"
    >Command-line & server apps
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-7">
      <li class="nav-item">
    <a class="nav-link" href="/server">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/server/get-started">Get started</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/server/cmdline">Write command-line apps</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/server/httpserver">Write HTTP servers</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/server/libraries">Libraries and packages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/server/google-cloud">Google Cloud</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-8"
      href="#sidenav-5-8" role="button"
      aria-expanded="false" aria-controls="sidenav-5-8"
    >Web apps
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-8">
      <li class="nav-item">
    <a class="nav-link" href="/web">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/web/get-started">Get started</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/web/fetch-data">Fetch data dynamically</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-8-4"
      href="#sidenav-5-8-4" role="button"
      aria-expanded="false" aria-controls="sidenav-5-8-4"
    >Low-level web programming
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-8-4">
      <li class="nav-item">
    <a class="nav-link" href="/tutorials/web/low-level-html/connect-dart-html">Connect Dart & HTML</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tutorials/web/low-level-html/add-elements">Add elements to the DOM</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tutorials/web/low-level-html/remove-elements">Remove DOM elements</a>
  </li>
  </ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/web/deployment">Deployment</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/web/libraries">Libraries and packages</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link active" data-toggle="collapse" href="#sidenav-6" role="button"
        aria-expanded="true" aria-controls="sidenav-6"
      >Tools & techniques</a>

      <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-6">
        <li class="nav-item">
    <a class="nav-link" href="/tools">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-2"
      href="#sidenav-6-2" role="button"
      aria-expanded="false" aria-controls="sidenav-6-2"
    >Editors & debuggers
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-2">
      <li class="nav-item">
    <a class="nav-link" href="/tools/jetbrains-plugin">IntelliJ & Android Studio</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/vs-code">VS Code</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/dart-devtools">Dart DevTools</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/dartpad">DartPad</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-3"
      href="#sidenav-6-3" role="button"
      aria-expanded="false" aria-controls="sidenav-6-3"
    >Command-line tools
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-3">
      <li class="nav-item">
    <a class="nav-link collapsable"
      data-toggle="collapse" data-target="#sidenav-6-3-1"
      href="#sidenav-6-3-1" role="button"
      aria-expanded="true" aria-controls="sidenav-6-3-1"
    >Dart SDK
    </a>
    <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-6-3-1">
      <li class="nav-item">
    <a class="nav-link" href="/tools/sdk">Overview</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-tool">dart</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-analyze">dart analyze</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-compile">dart compile</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-create">dart create</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-doc">dart doc</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-fix">dart fix</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-format">dart format</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/pub/cmd">dart pub</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-run">dart run</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-test">dart test</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dartaotruntime">dartaotruntime</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/experiment-flags">Experiment flags</a>
  </li>
  </ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable"
      data-toggle="collapse" data-target="#sidenav-6-3-2"
      href="#sidenav-6-3-2" role="button"
      aria-expanded="true" aria-controls="sidenav-6-3-2"
    >Other command-line tools
    </a>
    <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-6-3-2">
      <li class="nav-item">
    <a class="nav-link" href="/tools/build_runner">build_runner</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/webdev">webdev</a>
  </li>
  </ul>
  </li>
</ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-4"
      href="#sidenav-6-4" role="button"
      aria-expanded="false" aria-controls="sidenav-6-4"
    >Managing source code
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-4">
      <li class="nav-item">
    <a class="nav-link" href="/guides/language/formatting">Formatting code</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/private-files">What not to commit</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link active collapsable"
      data-toggle="collapse" data-target="#sidenav-6-5"
      href="#sidenav-6-5" role="button"
      aria-expanded="true" aria-controls="sidenav-6-5"
    >Static analysis
    </a>
    <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-6-5">
      <li class="nav-item">
    <a class="nav-link" href="/guides/language/analysis-options">Customizing static analysis</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/sound-problems">Fixing common type problems</a>
  </li><li class="nav-item">
    <a class="nav-link active" href="/tools/diagnostic-messages">Diagnostic messages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/linter-rules">Linter rules</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-6"
      href="#sidenav-6-6" role="button"
      aria-expanded="false" aria-controls="sidenav-6-6"
    >Testing & optimization
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-6">
      <li class="nav-item">
    <a class="nav-link" href="/guides/testing">Testing</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/web/debugging">Debugging web apps</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-7" role="button"
        aria-expanded="false" aria-controls="sidenav-7"
      >Resources</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-7">
        <li class="nav-item">
    <a class="nav-link" href="/resources">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/resources/books">Books</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/resources/dartpad-best-practices">DartPad in tutorials: Best practices</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/code-of-conduct">Code of conduct</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/faq">FAQ</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-7-6"
      href="#sidenav-7-6" role="button"
      aria-expanded="false" aria-controls="sidenav-7-6"
    >History
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-7-6">
      <li class="nav-item">
    <a class="nav-link" href="/dart-2">Migrating to Dart&nbsp;2</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/resources/videos">Videos</a>
  </li>
</ul>
    </li><li class="nav-item">
      <a class="nav-link " data-toggle="collapse" href="#sidenav-8" role="button"
        aria-expanded="true" aria-controls="sidenav-8"
      >Related sites</a>

      <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-8">
        <li class="nav-item">
    <a class="nav-link" href="https://api.dart.dev" target="_blank" rel="noopener">API reference<span class="material-icons md-24">
        open_in_new
      </span></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://medium.com/dartlang" target="_blank" rel="noopener">Blog<span class="material-icons md-24">
        open_in_new
      </span></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://dartpad.dev" target="_blank" rel="noopener">DartPad (online editor)<span class="material-icons md-24">
        open_in_new
      </span></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://flutter.dev" target="_blank" rel="noopener">Flutter<span class="material-icons md-24">
        open_in_new
      </span></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://pub.dev" target="_blank" rel="noopener">Package site<span class="material-icons md-24">
        open_in_new
      </span></a>
  </li>
</ul>
    </li></ul>

  </div>
</div>

    <main id="page-content">
      







<div id="site-toc--side" class="site-toc ">
  <header class="site-toc__title">
    Contents
    <button type="button" class="btn site-toc--button__page-top" aria-label="Page top"></button>
    
  </header>
  <ul id="toc" class="section-nav">
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#glossary">Glossary</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#constant-context">Constant context</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#definite-assignment">Definite assignment</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin-application">Mixin application</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#override-inference">Override inference</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#part-file">Part file</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#potentially-non-nullable">Potentially non-nullable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#public-library">Public library</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#diagnostics">Diagnostics</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#abi_specific_integer_invalid">abi_specific_integer_invalid</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#abi_specific_integer_mapping_extra">abi_specific_integer_mapping_extra</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#abi_specific_integer_mapping_missing">abi_specific_integer_mapping_missing</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#abi_specific_integer_mapping_unsupported">abi_specific_integer_mapping_unsupported</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#abstract_field_initializer">abstract_field_initializer</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#abstract_super_member_reference">abstract_super_member_reference</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#ambiguous_export">ambiguous_export</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#ambiguous_extension_member_access">ambiguous_extension_member_access</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#ambiguous_import">ambiguous_import</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#ambiguous_set_or_map_literal_both">ambiguous_set_or_map_literal_both</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#ambiguous_set_or_map_literal_either">ambiguous_set_or_map_literal_either</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#annotation_on_pointer_field">annotation_on_pointer_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#argument_must_be_a_constant">argument_must_be_a_constant</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#argument_type_not_assignable">argument_type_not_assignable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#argument_type_not_assignable_to_error_handler">argument_type_not_assignable_to_error_handler</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#assert_in_redirecting_constructor">assert_in_redirecting_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#asset_directory_does_not_exist">asset_directory_does_not_exist</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#asset_does_not_exist">asset_does_not_exist</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#asset_field_not_list">asset_field_not_list</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#asset_not_string">asset_not_string</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#assignment_of_do_not_store">assignment_of_do_not_store</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#assignment_to_const">assignment_to_const</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#assignment_to_final">assignment_to_final</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#assignment_to_final_local">assignment_to_final_local</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#assignment_to_final_no_setter">assignment_to_final_no_setter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#assignment_to_function">assignment_to_function</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#assignment_to_method">assignment_to_method</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#assignment_to_type">assignment_to_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#async_for_in_wrong_context">async_for_in_wrong_context</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#await_in_late_local_variable_initializer">await_in_late_local_variable_initializer</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#body_might_complete_normally">body_might_complete_normally</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#body_might_complete_normally_nullable">body_might_complete_normally_nullable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#break_label_on_switch_member">break_label_on_switch_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#built_in_identifier_as_type">built_in_identifier_as_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#built_in_identifier_in_declaration">built_in_identifier_in_declaration</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#case_block_not_terminated">case_block_not_terminated</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#case_expression_type_implements_equals">case_expression_type_implements_equals</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#case_expression_type_is_not_switch_expression_subtype">case_expression_type_is_not_switch_expression_subtype</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#cast_to_non_type">cast_to_non_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#collection_element_from_deferred_library">collection_element_from_deferred_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#compound_implements_finalizable">compound_implements_finalizable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#concrete_class_has_enum_superinterface">concrete_class_has_enum_superinterface</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#concrete_class_with_abstract_member">concrete_class_with_abstract_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#conflicting_constructor_and_static_member">conflicting_constructor_and_static_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#conflicting_generic_interfaces">conflicting_generic_interfaces</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#conflicting_type_variable_and_container">conflicting_type_variable_and_container</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#conflicting_type_variable_and_member">conflicting_type_variable_and_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_constructor_param_type_mismatch">const_constructor_param_type_mismatch</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_constructor_with_field_initialized_by_non_const">const_constructor_with_field_initialized_by_non_const</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_constructor_with_non_const_super">const_constructor_with_non_const_super</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_constructor_with_non_final_field">const_constructor_with_non_final_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_deferred_class">const_deferred_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_initialized_with_non_constant_value">const_initialized_with_non_constant_value</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_initialized_with_non_constant_value_from_deferred_library">const_initialized_with_non_constant_value_from_deferred_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_instance_field">const_instance_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_map_key_expression_type_implements_equals">const_map_key_expression_type_implements_equals</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_not_initialized">const_not_initialized</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_set_element_type_implements_equals">const_set_element_type_implements_equals</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_spread_expected_list_or_set">const_spread_expected_list_or_set</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_spread_expected_map">const_spread_expected_map</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_with_non_const">const_with_non_const</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_with_non_constant_argument">const_with_non_constant_argument</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#const_with_type_parameters">const_with_type_parameters</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#continue_label_on_switch">continue_label_on_switch</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#creation_of_struct_or_union">creation_of_struct_or_union</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#creation_with_non_type">creation_with_non_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#dead_code">dead_code</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#dead_code_catch_following_catch">dead_code_catch_following_catch</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#dead_code_on_catch_subtype">dead_code_on_catch_subtype</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#dead_null_aware_expression">dead_null_aware_expression</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#default_list_constructor">default_list_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#default_value_in_function_type">default_value_in_function_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#default_value_in_redirecting_factory_constructor">default_value_in_redirecting_factory_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#default_value_on_required_parameter">default_value_on_required_parameter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#deferred_import_of_extension">deferred_import_of_extension</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#definitely_unassigned_late_local_variable">definitely_unassigned_late_local_variable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#dependencies_field_not_map">dependencies_field_not_map</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#deprecated_field">deprecated_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#deprecated_member_use">deprecated_member_use</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#deprecated_member_use_from_same_package">deprecated_member_use_from_same_package</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#deprecated_new_in_comment_reference">deprecated_new_in_comment_reference</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#deprecated_subtype_of_function">deprecated_subtype_of_function</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#disallowed_type_instantiation_expression">disallowed_type_instantiation_expression</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#division_optimization">division_optimization</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#duplicate_constructor">duplicate_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#duplicate_definition">duplicate_definition</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#duplicate_field_formal_parameter">duplicate_field_formal_parameter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#duplicate_hidden_name">duplicate_hidden_name</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#duplicate_ignore">duplicate_ignore</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#duplicate_import">duplicate_import</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#duplicate_named_argument">duplicate_named_argument</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#duplicate_part">duplicate_part</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#duplicate_shown_name">duplicate_shown_name</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#empty_struct">empty_struct</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#enum_constant_same_name_as_enclosing">enum_constant_same_name_as_enclosing</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#enum_constant_with_non_const_constructor">enum_constant_with_non_const_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#enum_mixin_with_instance_variable">enum_mixin_with_instance_variable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#enum_with_abstract_member">enum_with_abstract_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#enum_with_name_values">enum_with_name_values</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#equal_elements_in_const_set">equal_elements_in_const_set</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#equal_elements_in_set">equal_elements_in_set</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#equal_keys_in_const_map">equal_keys_in_const_map</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#equal_keys_in_map">equal_keys_in_map</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#expected_one_list_type_arguments">expected_one_list_type_arguments</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#expected_one_set_type_arguments">expected_one_set_type_arguments</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#expected_two_map_type_arguments">expected_two_map_type_arguments</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#export_internal_library">export_internal_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#export_legacy_symbol">export_legacy_symbol</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#export_of_non_library">export_of_non_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#expression_in_map">expression_in_map</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extends_non_class">extends_non_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extension_as_expression">extension_as_expression</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extension_conflicting_static_and_instance">extension_conflicting_static_and_instance</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extension_declares_abstract_member">extension_declares_abstract_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extension_declares_constructor">extension_declares_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extension_declares_instance_field">extension_declares_instance_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extension_declares_member_of_object">extension_declares_member_of_object</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extension_override_access_to_static_member">extension_override_access_to_static_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extension_override_argument_not_assignable">extension_override_argument_not_assignable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extension_override_without_access">extension_override_without_access</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extension_override_with_cascade">extension_override_with_cascade</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#external_with_initializer">external_with_initializer</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extra_annotation_on_struct_field">extra_annotation_on_struct_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extra_positional_arguments">extra_positional_arguments</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extra_positional_arguments_could_be_named">extra_positional_arguments_could_be_named</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#extra_size_annotation_carray">extra_size_annotation_carray</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_initialized_by_multiple_initializers">field_initialized_by_multiple_initializers</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_initialized_in_initializer_and_declaration">field_initialized_in_initializer_and_declaration</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_initialized_in_parameter_and_initializer">field_initialized_in_parameter_and_initializer</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_initializer_factory_constructor">field_initializer_factory_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_initializer_in_struct">field_initializer_in_struct</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_initializer_not_assignable">field_initializer_not_assignable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_initializer_outside_constructor">field_initializer_outside_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_initializer_redirecting_constructor">field_initializer_redirecting_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_initializing_formal_not_assignable">field_initializing_formal_not_assignable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_in_struct_with_initializer">field_in_struct_with_initializer</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#field_must_be_external_in_struct">field_must_be_external_in_struct</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#final_initialized_in_declaration_and_constructor">final_initialized_in_declaration_and_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#final_not_initialized">final_not_initialized</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#final_not_initialized_constructor">final_not_initialized_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#flutter_field_not_map">flutter_field_not_map</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#for_in_of_invalid_element_type">for_in_of_invalid_element_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#for_in_of_invalid_type">for_in_of_invalid_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#for_in_with_const_variable">for_in_with_const_variable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#generic_method_type_instantiation_on_dynamic">generic_method_type_instantiation_on_dynamic</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#generic_struct_subclass">generic_struct_subclass</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#getter_not_subtype_setter_types">getter_not_subtype_setter_types</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#illegal_async_generator_return_type">illegal_async_generator_return_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#illegal_async_return_type">illegal_async_return_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#illegal_concrete_enum_member">illegal_concrete_enum_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#illegal_enum_values">illegal_enum_values</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#illegal_sync_generator_return_type">illegal_sync_generator_return_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#implements_non_class">implements_non_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#implements_repeated">implements_repeated</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#implements_super_class">implements_super_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#implicit_super_initializer_missing_arguments">implicit_super_initializer_missing_arguments</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#implicit_this_reference_in_initializer">implicit_this_reference_in_initializer</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#import_deferred_library_with_load_function">import_deferred_library_with_load_function</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#import_internal_library">import_internal_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#import_of_legacy_library_into_null_safe">import_of_legacy_library_into_null_safe</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#import_of_non_library">import_of_non_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#inconsistent_inheritance">inconsistent_inheritance</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#inconsistent_language_version_override">inconsistent_language_version_override</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#initializer_for_non_existent_field">initializer_for_non_existent_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#initializer_for_static_field">initializer_for_static_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#initializing_formal_for_non_existent_field">initializing_formal_for_non_existent_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#instance_access_to_static_member">instance_access_to_static_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#instance_member_access_from_factory">instance_member_access_from_factory</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#instance_member_access_from_static">instance_member_access_from_static</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#instantiate_abstract_class">instantiate_abstract_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#instantiate_enum">instantiate_enum</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#instantiate_type_alias_expands_to_type_parameter">instantiate_type_alias_expands_to_type_parameter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#integer_literal_imprecise_as_double">integer_literal_imprecise_as_double</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#integer_literal_out_of_range">integer_literal_out_of_range</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_annotation">invalid_annotation</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_annotation_constant_value_from_deferred_library">invalid_annotation_constant_value_from_deferred_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_annotation_from_deferred_library">invalid_annotation_from_deferred_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_annotation_target">invalid_annotation_target</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_assignment">invalid_assignment</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_dependency">invalid_dependency</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_exception_value">invalid_exception_value</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_export_of_internal_element">invalid_export_of_internal_element</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_export_of_internal_element_indirectly">invalid_export_of_internal_element_indirectly</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_extension_argument_count">invalid_extension_argument_count</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_factory_method_decl">invalid_factory_method_decl</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_factory_method_impl">invalid_factory_method_impl</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_factory_name_not_a_class">invalid_factory_name_not_a_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_field_type_in_struct">invalid_field_type_in_struct</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_implementation_override">invalid_implementation_override</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_inline_function_type">invalid_inline_function_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_internal_annotation">invalid_internal_annotation</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_language_version_override">invalid_language_version_override</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_literal_annotation">invalid_literal_annotation</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_modifier_on_constructor">invalid_modifier_on_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_modifier_on_setter">invalid_modifier_on_setter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_non_virtual_annotation">invalid_non_virtual_annotation</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_null_aware_operator">invalid_null_aware_operator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_override">invalid_override</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_override_of_non_virtual_member">invalid_override_of_non_virtual_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_reference_to_generative_enum_constructor">invalid_reference_to_generative_enum_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_reference_to_this">invalid_reference_to_this</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_return_type_for_catch_error">invalid_return_type_for_catch_error</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_sealed_annotation">invalid_sealed_annotation</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_super_formal_parameter_location">invalid_super_formal_parameter_location</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_type_argument_in_const_literal">invalid_type_argument_in_const_literal</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_uri">invalid_uri</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_use_of_covariant_in_extension">invalid_use_of_covariant_in_extension</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_use_of_internal_member">invalid_use_of_internal_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_use_of_null_value">invalid_use_of_null_value</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_use_of_visible_for_overriding_member">invalid_use_of_visible_for_overriding_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_use_of_visible_for_testing_member">invalid_use_of_visible_for_testing_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_visibility_annotation">invalid_visibility_annotation</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid_visible_for_overriding_annotation">invalid_visible_for_overriding_annotation</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invocation_of_extension_without_call">invocation_of_extension_without_call</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invocation_of_non_function">invocation_of_non_function</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invocation_of_non_function_expression">invocation_of_non_function_expression</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#label_in_outer_scope">label_in_outer_scope</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#label_undefined">label_undefined</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#late_final_field_with_const_constructor">late_final_field_with_const_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#late_final_local_already_assigned">late_final_local_already_assigned</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#leaf_call_must_not_return_handle">leaf_call_must_not_return_handle</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#leaf_call_must_not_take_handle">leaf_call_must_not_take_handle</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#list_element_type_not_assignable">list_element_type_not_assignable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#main_first_positional_parameter_type">main_first_positional_parameter_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#main_has_required_named_parameters">main_has_required_named_parameters</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#main_has_too_many_required_positional_parameters">main_has_too_many_required_positional_parameters</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#main_is_not_function">main_is_not_function</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#map_entry_not_in_map">map_entry_not_in_map</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#map_key_type_not_assignable">map_key_type_not_assignable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#map_value_type_not_assignable">map_value_type_not_assignable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mismatched_annotation_on_struct_field">mismatched_annotation_on_struct_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_annotation_on_struct_field">missing_annotation_on_struct_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_dart_library">missing_dart_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_default_value_for_parameter">missing_default_value_for_parameter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_enum_constant_in_switch">missing_enum_constant_in_switch</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_exception_value">missing_exception_value</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_field_type_in_struct">missing_field_type_in_struct</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_name">missing_name</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_required_argument">missing_required_argument</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_required_param">missing_required_param</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_return">missing_return</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#missing_size_annotation_carray">missing_size_annotation_carray</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin_application_concrete_super_invoked_member_type">mixin_application_concrete_super_invoked_member_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin_application_not_implemented_interface">mixin_application_not_implemented_interface</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin_application_no_concrete_super_invoked_member">mixin_application_no_concrete_super_invoked_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin_class_declares_constructor">mixin_class_declares_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin_inherits_from_not_object">mixin_inherits_from_not_object</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin_instantiate">mixin_instantiate</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin_of_non_class">mixin_of_non_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin_on_sealed_class">mixin_on_sealed_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin_super_class_constraint_deferred_class">mixin_super_class_constraint_deferred_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#mixin_super_class_constraint_non_interface">mixin_super_class_constraint_non_interface</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#multiple_redirecting_constructor_invocations">multiple_redirecting_constructor_invocations</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#multiple_super_initializers">multiple_super_initializers</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#must_be_a_native_function_type">must_be_a_native_function_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#must_be_a_subtype">must_be_a_subtype</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#must_be_immutable">must_be_immutable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#must_call_super">must_call_super</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#name_not_string">name_not_string</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#new_with_undefined_constructor_default">new_with_undefined_constructor_default</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_abstract_class_inherits_abstract_member">non_abstract_class_inherits_abstract_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_bool_condition">non_bool_condition</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_bool_expression">non_bool_expression</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_bool_negation_expression">non_bool_negation_expression</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_bool_operand">non_bool_operand</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_annotation_constructor">non_constant_annotation_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_case_expression">non_constant_case_expression</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_case_expression_from_deferred_library">non_constant_case_expression_from_deferred_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_default_value">non_constant_default_value</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_default_value_from_deferred_library">non_constant_default_value_from_deferred_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_list_element">non_constant_list_element</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_map_element">non_constant_map_element</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_map_key">non_constant_map_key</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_map_value">non_constant_map_value</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_set_element">non_constant_set_element</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_constant_type_argument">non_constant_type_argument</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_const_call_to_literal_constructor">non_const_call_to_literal_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_const_generative_enum_constructor">non_const_generative_enum_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_final_field_in_enum">non_final_field_in_enum</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_generative_constructor">non_generative_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_generative_implicit_constructor">non_generative_implicit_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_native_function_type_argument_to_pointer">non_native_function_type_argument_to_pointer</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_positive_array_dimension">non_positive_array_dimension</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_sized_type_argument">non_sized_type_argument</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_sync_factory">non_sync_factory</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_type_as_type_argument">non_type_as_type_argument</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_type_in_catch_clause">non_type_in_catch_clause</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_void_return_for_operator">non_void_return_for_operator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non_void_return_for_setter">non_void_return_for_setter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#not_assigned_potentially_non_nullable_local_variable">not_assigned_potentially_non_nullable_local_variable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#not_a_type">not_a_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#not_binary_operator">not_binary_operator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#not_enough_positional_arguments">not_enough_positional_arguments</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#not_initialized_non_nullable_instance_field">not_initialized_non_nullable_instance_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#not_initialized_non_nullable_variable">not_initialized_non_nullable_variable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#not_iterable_spread">not_iterable_spread</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#not_map_spread">not_map_spread</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#no_annotation_constructor_arguments">no_annotation_constructor_arguments</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#no_combined_super_signature">no_combined_super_signature</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#no_generative_constructors_in_superclass">no_generative_constructors_in_superclass</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#nullable_type_in_catch_clause">nullable_type_in_catch_clause</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#nullable_type_in_extends_clause">nullable_type_in_extends_clause</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#nullable_type_in_implements_clause">nullable_type_in_implements_clause</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#nullable_type_in_on_clause">nullable_type_in_on_clause</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#nullable_type_in_with_clause">nullable_type_in_with_clause</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#null_argument_to_non_null_type">null_argument_to_non_null_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#null_check_always_fails">null_check_always_fails</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#on_repeated">on_repeated</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#optional_parameter_in_operator">optional_parameter_in_operator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#override_on_non_overriding_member">override_on_non_overriding_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#packed_annotation">packed_annotation</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#packed_annotation_alignment">packed_annotation_alignment</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#packed_nesting_non_packed">packed_nesting_non_packed</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#part_of_different_library">part_of_different_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#part_of_non_part">part_of_non_part</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#part_of_unnamed_library">part_of_unnamed_library</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#path_does_not_exist">path_does_not_exist</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#path_not_posix">path_not_posix</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#path_pubspec_does_not_exist">path_pubspec_does_not_exist</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#positional_super_formal_parameter_with_positional_argument">positional_super_formal_parameter_with_positional_argument</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#prefix_collides_with_top_level_member">prefix_collides_with_top_level_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#prefix_identifier_not_followed_by_dot">prefix_identifier_not_followed_by_dot</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#prefix_shadowed_by_local_declaration">prefix_shadowed_by_local_declaration</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#private_collision_in_mixin_application">private_collision_in_mixin_application</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#private_optional_parameter">private_optional_parameter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#private_setter">private_setter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#read_potentially_unassigned_final">read_potentially_unassigned_final</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#recursive_compile_time_constant">recursive_compile_time_constant</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#recursive_constructor_redirect">recursive_constructor_redirect</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#recursive_interface_inheritance">recursive_interface_inheritance</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#redirect_generative_to_missing_constructor">redirect_generative_to_missing_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#redirect_generative_to_non_generative_constructor">redirect_generative_to_non_generative_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#redirect_to_abstract_class_constructor">redirect_to_abstract_class_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#redirect_to_invalid_function_type">redirect_to_invalid_function_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#redirect_to_invalid_return_type">redirect_to_invalid_return_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#redirect_to_missing_constructor">redirect_to_missing_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#redirect_to_non_class">redirect_to_non_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#redirect_to_non_const_constructor">redirect_to_non_const_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#redirect_to_type_alias_expands_to_type_parameter">redirect_to_type_alias_expands_to_type_parameter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#referenced_before_declaration">referenced_before_declaration</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#rethrow_outside_catch">rethrow_outside_catch</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#return_in_generative_constructor">return_in_generative_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#return_in_generator">return_in_generator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#return_of_do_not_store">return_of_do_not_store</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#return_of_invalid_type">return_of_invalid_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#return_of_invalid_type_from_closure">return_of_invalid_type_from_closure</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#return_without_value">return_without_value</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_async_exported_from_core">sdk_version_async_exported_from_core</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_as_expression_in_const_context">sdk_version_as_expression_in_const_context</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_bool_operator_in_const_context">sdk_version_bool_operator_in_const_context</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_constructor_tearoffs">sdk_version_constructor_tearoffs</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_eq_eq_operator_in_const_context">sdk_version_eq_eq_operator_in_const_context</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_extension_methods">sdk_version_extension_methods</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_gt_gt_gt_operator">sdk_version_gt_gt_gt_operator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_is_expression_in_const_context">sdk_version_is_expression_in_const_context</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_never">sdk_version_never</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_set_literal">sdk_version_set_literal</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_ui_as_code">sdk_version_ui_as_code</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#sdk_version_ui_as_code_in_const_context">sdk_version_ui_as_code_in_const_context</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#set_element_type_not_assignable">set_element_type_not_assignable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#shared_deferred_prefix">shared_deferred_prefix</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#size_annotation_dimensions">size_annotation_dimensions</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#static_access_to_instance_member">static_access_to_instance_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#subtype_of_deferred_class">subtype_of_deferred_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#subtype_of_disallowed_type">subtype_of_disallowed_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#subtype_of_ffi_class">subtype_of_ffi_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#subtype_of_sealed_class">subtype_of_sealed_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#subtype_of_struct_class">subtype_of_struct_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#supertype_expands_to_type_parameter">supertype_expands_to_type_parameter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#super_formal_parameter_type_is_not_subtype_of_associated">super_formal_parameter_type_is_not_subtype_of_associated</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#super_formal_parameter_without_associated_named">super_formal_parameter_without_associated_named</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#super_formal_parameter_without_associated_positional">super_formal_parameter_without_associated_positional</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#super_invocation_not_last">super_invocation_not_last</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#super_in_enum_constructor">super_in_enum_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#super_in_extension">super_in_extension</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#super_in_invalid_context">super_in_invalid_context</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#super_in_redirecting_constructor">super_in_redirecting_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#switch_case_completes_normally">switch_case_completes_normally</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#switch_expression_not_assignable">switch_expression_not_assignable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#tearoff_of_generative_constructor_of_abstract_class">tearoff_of_generative_constructor_of_abstract_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#text_direction_code_point_in_comment">text_direction_code_point_in_comment</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#text_direction_code_point_in_literal">text_direction_code_point_in_literal</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#throw_of_invalid_type">throw_of_invalid_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#top_level_cycle">top_level_cycle</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#type_alias_cannot_reference_itself">type_alias_cannot_reference_itself</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#type_annotation_deferred_class">type_annotation_deferred_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#type_argument_not_matching_bounds">type_argument_not_matching_bounds</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#type_check_with_null">type_check_with_null</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#type_parameter_referenced_by_static">type_parameter_referenced_by_static</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#type_parameter_supertype_of_its_bound">type_parameter_supertype_of_its_bound</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#type_test_with_non_type">type_test_with_non_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#type_test_with_undefined_name">type_test_with_undefined_name</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unchecked_use_of_nullable_value">unchecked_use_of_nullable_value</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_annotation">undefined_annotation</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_class">undefined_class</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_constructor_in_initializer">undefined_constructor_in_initializer</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_enum_constant">undefined_enum_constant</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_enum_constructor">undefined_enum_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_extension_getter">undefined_extension_getter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_extension_method">undefined_extension_method</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_extension_operator">undefined_extension_operator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_extension_setter">undefined_extension_setter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_function">undefined_function</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_getter">undefined_getter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_hidden_name">undefined_hidden_name</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_identifier">undefined_identifier</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_identifier_await">undefined_identifier_await</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_method">undefined_method</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_named_parameter">undefined_named_parameter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_operator">undefined_operator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_prefixed_name">undefined_prefixed_name</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_referenced_parameter">undefined_referenced_parameter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_setter">undefined_setter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_shown_name">undefined_shown_name</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#undefined_super_member">undefined_super_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unnecessary_cast">unnecessary_cast</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unnecessary_dev_dependency">unnecessary_dev_dependency</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unnecessary_final">unnecessary_final</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unnecessary_import">unnecessary_import</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unnecessary_non_null_assertion">unnecessary_non_null_assertion</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unnecessary_no_such_method">unnecessary_no_such_method</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unnecessary_null_comparison">unnecessary_null_comparison</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unnecessary_question_mark">unnecessary_question_mark</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unnecessary_type_check">unnecessary_type_check</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unqualified_reference_to_non_local_static_member">unqualified_reference_to_non_local_static_member</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unqualified_reference_to_static_member_of_extended_type">unqualified_reference_to_static_member_of_extended_type</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unused_catch_clause">unused_catch_clause</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unused_catch_stack">unused_catch_stack</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unused_element">unused_element</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unused_field">unused_field</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unused_import">unused_import</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unused_label">unused_label</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unused_local_variable">unused_local_variable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unused_result">unused_result</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unused_shown_name">unused_shown_name</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#uri_does_not_exist">uri_does_not_exist</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#uri_has_not_been_generated">uri_has_not_been_generated</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#uri_with_interpolation">uri_with_interpolation</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#use_of_native_extension">use_of_native_extension</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#use_of_void_result">use_of_void_result</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#values_declaration_in_enum">values_declaration_in_enum</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#variable_type_mismatch">variable_type_mismatch</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#wrong_number_of_parameters_for_operator">wrong_number_of_parameters_for_operator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#wrong_number_of_parameters_for_setter">wrong_number_of_parameters_for_setter</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#wrong_number_of_type_arguments">wrong_number_of_type_arguments</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#wrong_number_of_type_arguments_constructor">wrong_number_of_type_arguments_constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#wrong_number_of_type_arguments_enum">wrong_number_of_type_arguments_enum</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#wrong_number_of_type_arguments_extension">wrong_number_of_type_arguments_extension</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#wrong_number_of_type_arguments_method">wrong_number_of_type_arguments_method</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#yield_in_non_generator">yield_in_non_generator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#yield_of_invalid_type">yield_of_invalid_type</a></li>
</ul>
</li>
</ul>
</div>


      <article>
        <div class="content">
          

          <div>
            <div id="page-github-links" class="btn-group" aria-label="Page GitHub links" role="group">
  <a href="https://github.com/dart-lang/site-www/tree/main/src/tools/diagnostic-messages.md" class="btn no-automatic-external" title="View page source" target="_blank" rel="noopener">
    <i class="fas fa-file-alt fa-sm"></i>
  </a>
  <a href="https://github.com/dart-lang/site-www/issues/new?template=1_page_issue.yml&title=[PAGE ISSUE]: 'Diagnostic messages'&page-url=https://dart.esdocu.com/tools/diagnostic-messages.html&page-source=https://github.com/dart-lang/site-www/tree/main/src/tools/diagnostic-messages.md" class="btn no-automatic-external" title="Report an issue with this page"
    target="_blank" rel="noopener">
    <i class="fas fa-bug fa-sm"></i>
  </a>
</div>

            <h1>Diagnostic messages</h1>
          </div>
          







<div id="site-toc--inline" class="site-toc toc-collapsible toc-collapsed">
  <header class="site-toc__title">
    Contents
    <button type="button" class="btn site-toc--button__page-top" aria-label="Page top"></button>
    
      <span class="site-toc--inline__toggle toc-toggle-down"><i class="material-icons">keyboard_arrow_down</i></span>
      <span class="site-toc--inline__toggle toc-toggle-up"><i class="material-icons">keyboard_arrow_up</i></span>
    
  </header>
  <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#glossary">Glossary</a>
<ul>
<li class="toc-entry toc-h3"><a href="#constant-context">Constant context</a></li>
<li class="toc-entry toc-h3"><a href="#definite-assignment">Definite assignment</a></li>
<li class="toc-entry toc-h3"><a href="#mixin-application">Mixin application</a></li>
<li class="toc-entry toc-h3"><a href="#override-inference">Override inference</a></li>
<li class="toc-entry toc-h3"><a href="#part-file">Part file</a></li>
<li class="toc-entry toc-h3"><a href="#potentially-non-nullable">Potentially non-nullable</a></li>
<li class="toc-entry toc-h3"><a href="#public-library">Public library</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#diagnostics">Diagnostics</a>
<ul>
<li class="toc-entry toc-h3"><a href="#abi_specific_integer_invalid">abi_specific_integer_invalid</a></li>
<li class="toc-entry toc-h3"><a href="#abi_specific_integer_mapping_extra">abi_specific_integer_mapping_extra</a></li>
<li class="toc-entry toc-h3"><a href="#abi_specific_integer_mapping_missing">abi_specific_integer_mapping_missing</a></li>
<li class="toc-entry toc-h3"><a href="#abi_specific_integer_mapping_unsupported">abi_specific_integer_mapping_unsupported</a></li>
<li class="toc-entry toc-h3"><a href="#abstract_field_initializer">abstract_field_initializer</a></li>
<li class="toc-entry toc-h3"><a href="#abstract_super_member_reference">abstract_super_member_reference</a></li>
<li class="toc-entry toc-h3"><a href="#ambiguous_export">ambiguous_export</a></li>
<li class="toc-entry toc-h3"><a href="#ambiguous_extension_member_access">ambiguous_extension_member_access</a></li>
<li class="toc-entry toc-h3"><a href="#ambiguous_import">ambiguous_import</a></li>
<li class="toc-entry toc-h3"><a href="#ambiguous_set_or_map_literal_both">ambiguous_set_or_map_literal_both</a></li>
<li class="toc-entry toc-h3"><a href="#ambiguous_set_or_map_literal_either">ambiguous_set_or_map_literal_either</a></li>
<li class="toc-entry toc-h3"><a href="#annotation_on_pointer_field">annotation_on_pointer_field</a></li>
<li class="toc-entry toc-h3"><a href="#argument_must_be_a_constant">argument_must_be_a_constant</a></li>
<li class="toc-entry toc-h3"><a href="#argument_type_not_assignable">argument_type_not_assignable</a></li>
<li class="toc-entry toc-h3"><a href="#argument_type_not_assignable_to_error_handler">argument_type_not_assignable_to_error_handler</a></li>
<li class="toc-entry toc-h3"><a href="#assert_in_redirecting_constructor">assert_in_redirecting_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#asset_directory_does_not_exist">asset_directory_does_not_exist</a></li>
<li class="toc-entry toc-h3"><a href="#asset_does_not_exist">asset_does_not_exist</a></li>
<li class="toc-entry toc-h3"><a href="#asset_field_not_list">asset_field_not_list</a></li>
<li class="toc-entry toc-h3"><a href="#asset_not_string">asset_not_string</a></li>
<li class="toc-entry toc-h3"><a href="#assignment_of_do_not_store">assignment_of_do_not_store</a></li>
<li class="toc-entry toc-h3"><a href="#assignment_to_const">assignment_to_const</a></li>
<li class="toc-entry toc-h3"><a href="#assignment_to_final">assignment_to_final</a></li>
<li class="toc-entry toc-h3"><a href="#assignment_to_final_local">assignment_to_final_local</a></li>
<li class="toc-entry toc-h3"><a href="#assignment_to_final_no_setter">assignment_to_final_no_setter</a></li>
<li class="toc-entry toc-h3"><a href="#assignment_to_function">assignment_to_function</a></li>
<li class="toc-entry toc-h3"><a href="#assignment_to_method">assignment_to_method</a></li>
<li class="toc-entry toc-h3"><a href="#assignment_to_type">assignment_to_type</a></li>
<li class="toc-entry toc-h3"><a href="#async_for_in_wrong_context">async_for_in_wrong_context</a></li>
<li class="toc-entry toc-h3"><a href="#await_in_late_local_variable_initializer">await_in_late_local_variable_initializer</a></li>
<li class="toc-entry toc-h3"><a href="#body_might_complete_normally">body_might_complete_normally</a></li>
<li class="toc-entry toc-h3"><a href="#body_might_complete_normally_nullable">body_might_complete_normally_nullable</a></li>
<li class="toc-entry toc-h3"><a href="#break_label_on_switch_member">break_label_on_switch_member</a></li>
<li class="toc-entry toc-h3"><a href="#built_in_identifier_as_type">built_in_identifier_as_type</a></li>
<li class="toc-entry toc-h3"><a href="#built_in_identifier_in_declaration">built_in_identifier_in_declaration</a></li>
<li class="toc-entry toc-h3"><a href="#case_block_not_terminated">case_block_not_terminated</a></li>
<li class="toc-entry toc-h3"><a href="#case_expression_type_implements_equals">case_expression_type_implements_equals</a></li>
<li class="toc-entry toc-h3"><a href="#case_expression_type_is_not_switch_expression_subtype">case_expression_type_is_not_switch_expression_subtype</a></li>
<li class="toc-entry toc-h3"><a href="#cast_to_non_type">cast_to_non_type</a></li>
<li class="toc-entry toc-h3"><a href="#collection_element_from_deferred_library">collection_element_from_deferred_library</a></li>
<li class="toc-entry toc-h3"><a href="#compound_implements_finalizable">compound_implements_finalizable</a></li>
<li class="toc-entry toc-h3"><a href="#concrete_class_has_enum_superinterface">concrete_class_has_enum_superinterface</a></li>
<li class="toc-entry toc-h3"><a href="#concrete_class_with_abstract_member">concrete_class_with_abstract_member</a></li>
<li class="toc-entry toc-h3"><a href="#conflicting_constructor_and_static_member">conflicting_constructor_and_static_member</a></li>
<li class="toc-entry toc-h3"><a href="#conflicting_generic_interfaces">conflicting_generic_interfaces</a></li>
<li class="toc-entry toc-h3"><a href="#conflicting_type_variable_and_container">conflicting_type_variable_and_container</a></li>
<li class="toc-entry toc-h3"><a href="#conflicting_type_variable_and_member">conflicting_type_variable_and_member</a></li>
<li class="toc-entry toc-h3"><a href="#const_constructor_param_type_mismatch">const_constructor_param_type_mismatch</a></li>
<li class="toc-entry toc-h3"><a href="#const_constructor_with_field_initialized_by_non_const">const_constructor_with_field_initialized_by_non_const</a></li>
<li class="toc-entry toc-h3"><a href="#const_constructor_with_non_const_super">const_constructor_with_non_const_super</a></li>
<li class="toc-entry toc-h3"><a href="#const_constructor_with_non_final_field">const_constructor_with_non_final_field</a></li>
<li class="toc-entry toc-h3"><a href="#const_deferred_class">const_deferred_class</a></li>
<li class="toc-entry toc-h3"><a href="#const_initialized_with_non_constant_value">const_initialized_with_non_constant_value</a></li>
<li class="toc-entry toc-h3"><a href="#const_initialized_with_non_constant_value_from_deferred_library">const_initialized_with_non_constant_value_from_deferred_library</a></li>
<li class="toc-entry toc-h3"><a href="#const_instance_field">const_instance_field</a></li>
<li class="toc-entry toc-h3"><a href="#const_map_key_expression_type_implements_equals">const_map_key_expression_type_implements_equals</a></li>
<li class="toc-entry toc-h3"><a href="#const_not_initialized">const_not_initialized</a></li>
<li class="toc-entry toc-h3"><a href="#const_set_element_type_implements_equals">const_set_element_type_implements_equals</a></li>
<li class="toc-entry toc-h3"><a href="#const_spread_expected_list_or_set">const_spread_expected_list_or_set</a></li>
<li class="toc-entry toc-h3"><a href="#const_spread_expected_map">const_spread_expected_map</a></li>
<li class="toc-entry toc-h3"><a href="#const_with_non_const">const_with_non_const</a></li>
<li class="toc-entry toc-h3"><a href="#const_with_non_constant_argument">const_with_non_constant_argument</a></li>
<li class="toc-entry toc-h3"><a href="#const_with_type_parameters">const_with_type_parameters</a></li>
<li class="toc-entry toc-h3"><a href="#continue_label_on_switch">continue_label_on_switch</a></li>
<li class="toc-entry toc-h3"><a href="#creation_of_struct_or_union">creation_of_struct_or_union</a></li>
<li class="toc-entry toc-h3"><a href="#creation_with_non_type">creation_with_non_type</a></li>
<li class="toc-entry toc-h3"><a href="#dead_code">dead_code</a></li>
<li class="toc-entry toc-h3"><a href="#dead_code_catch_following_catch">dead_code_catch_following_catch</a></li>
<li class="toc-entry toc-h3"><a href="#dead_code_on_catch_subtype">dead_code_on_catch_subtype</a></li>
<li class="toc-entry toc-h3"><a href="#dead_null_aware_expression">dead_null_aware_expression</a></li>
<li class="toc-entry toc-h3"><a href="#default_list_constructor">default_list_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#default_value_in_function_type">default_value_in_function_type</a></li>
<li class="toc-entry toc-h3"><a href="#default_value_in_redirecting_factory_constructor">default_value_in_redirecting_factory_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#default_value_on_required_parameter">default_value_on_required_parameter</a></li>
<li class="toc-entry toc-h3"><a href="#deferred_import_of_extension">deferred_import_of_extension</a></li>
<li class="toc-entry toc-h3"><a href="#definitely_unassigned_late_local_variable">definitely_unassigned_late_local_variable</a></li>
<li class="toc-entry toc-h3"><a href="#dependencies_field_not_map">dependencies_field_not_map</a></li>
<li class="toc-entry toc-h3"><a href="#deprecated_field">deprecated_field</a></li>
<li class="toc-entry toc-h3"><a href="#deprecated_member_use">deprecated_member_use</a></li>
<li class="toc-entry toc-h3"><a href="#deprecated_member_use_from_same_package">deprecated_member_use_from_same_package</a></li>
<li class="toc-entry toc-h3"><a href="#deprecated_new_in_comment_reference">deprecated_new_in_comment_reference</a></li>
<li class="toc-entry toc-h3"><a href="#deprecated_subtype_of_function">deprecated_subtype_of_function</a></li>
<li class="toc-entry toc-h3"><a href="#disallowed_type_instantiation_expression">disallowed_type_instantiation_expression</a></li>
<li class="toc-entry toc-h3"><a href="#division_optimization">division_optimization</a></li>
<li class="toc-entry toc-h3"><a href="#duplicate_constructor">duplicate_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#duplicate_definition">duplicate_definition</a></li>
<li class="toc-entry toc-h3"><a href="#duplicate_field_formal_parameter">duplicate_field_formal_parameter</a></li>
<li class="toc-entry toc-h3"><a href="#duplicate_hidden_name">duplicate_hidden_name</a></li>
<li class="toc-entry toc-h3"><a href="#duplicate_ignore">duplicate_ignore</a></li>
<li class="toc-entry toc-h3"><a href="#duplicate_import">duplicate_import</a></li>
<li class="toc-entry toc-h3"><a href="#duplicate_named_argument">duplicate_named_argument</a></li>
<li class="toc-entry toc-h3"><a href="#duplicate_part">duplicate_part</a></li>
<li class="toc-entry toc-h3"><a href="#duplicate_shown_name">duplicate_shown_name</a></li>
<li class="toc-entry toc-h3"><a href="#empty_struct">empty_struct</a></li>
<li class="toc-entry toc-h3"><a href="#enum_constant_same_name_as_enclosing">enum_constant_same_name_as_enclosing</a></li>
<li class="toc-entry toc-h3"><a href="#enum_constant_with_non_const_constructor">enum_constant_with_non_const_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#enum_mixin_with_instance_variable">enum_mixin_with_instance_variable</a></li>
<li class="toc-entry toc-h3"><a href="#enum_with_abstract_member">enum_with_abstract_member</a></li>
<li class="toc-entry toc-h3"><a href="#enum_with_name_values">enum_with_name_values</a></li>
<li class="toc-entry toc-h3"><a href="#equal_elements_in_const_set">equal_elements_in_const_set</a></li>
<li class="toc-entry toc-h3"><a href="#equal_elements_in_set">equal_elements_in_set</a></li>
<li class="toc-entry toc-h3"><a href="#equal_keys_in_const_map">equal_keys_in_const_map</a></li>
<li class="toc-entry toc-h3"><a href="#equal_keys_in_map">equal_keys_in_map</a></li>
<li class="toc-entry toc-h3"><a href="#expected_one_list_type_arguments">expected_one_list_type_arguments</a></li>
<li class="toc-entry toc-h3"><a href="#expected_one_set_type_arguments">expected_one_set_type_arguments</a></li>
<li class="toc-entry toc-h3"><a href="#expected_two_map_type_arguments">expected_two_map_type_arguments</a></li>
<li class="toc-entry toc-h3"><a href="#export_internal_library">export_internal_library</a></li>
<li class="toc-entry toc-h3"><a href="#export_legacy_symbol">export_legacy_symbol</a></li>
<li class="toc-entry toc-h3"><a href="#export_of_non_library">export_of_non_library</a></li>
<li class="toc-entry toc-h3"><a href="#expression_in_map">expression_in_map</a></li>
<li class="toc-entry toc-h3"><a href="#extends_non_class">extends_non_class</a></li>
<li class="toc-entry toc-h3"><a href="#extension_as_expression">extension_as_expression</a></li>
<li class="toc-entry toc-h3"><a href="#extension_conflicting_static_and_instance">extension_conflicting_static_and_instance</a></li>
<li class="toc-entry toc-h3"><a href="#extension_declares_abstract_member">extension_declares_abstract_member</a></li>
<li class="toc-entry toc-h3"><a href="#extension_declares_constructor">extension_declares_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#extension_declares_instance_field">extension_declares_instance_field</a></li>
<li class="toc-entry toc-h3"><a href="#extension_declares_member_of_object">extension_declares_member_of_object</a></li>
<li class="toc-entry toc-h3"><a href="#extension_override_access_to_static_member">extension_override_access_to_static_member</a></li>
<li class="toc-entry toc-h3"><a href="#extension_override_argument_not_assignable">extension_override_argument_not_assignable</a></li>
<li class="toc-entry toc-h3"><a href="#extension_override_without_access">extension_override_without_access</a></li>
<li class="toc-entry toc-h3"><a href="#extension_override_with_cascade">extension_override_with_cascade</a></li>
<li class="toc-entry toc-h3"><a href="#external_with_initializer">external_with_initializer</a></li>
<li class="toc-entry toc-h3"><a href="#extra_annotation_on_struct_field">extra_annotation_on_struct_field</a></li>
<li class="toc-entry toc-h3"><a href="#extra_positional_arguments">extra_positional_arguments</a></li>
<li class="toc-entry toc-h3"><a href="#extra_positional_arguments_could_be_named">extra_positional_arguments_could_be_named</a></li>
<li class="toc-entry toc-h3"><a href="#extra_size_annotation_carray">extra_size_annotation_carray</a></li>
<li class="toc-entry toc-h3"><a href="#field_initialized_by_multiple_initializers">field_initialized_by_multiple_initializers</a></li>
<li class="toc-entry toc-h3"><a href="#field_initialized_in_initializer_and_declaration">field_initialized_in_initializer_and_declaration</a></li>
<li class="toc-entry toc-h3"><a href="#field_initialized_in_parameter_and_initializer">field_initialized_in_parameter_and_initializer</a></li>
<li class="toc-entry toc-h3"><a href="#field_initializer_factory_constructor">field_initializer_factory_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#field_initializer_in_struct">field_initializer_in_struct</a></li>
<li class="toc-entry toc-h3"><a href="#field_initializer_not_assignable">field_initializer_not_assignable</a></li>
<li class="toc-entry toc-h3"><a href="#field_initializer_outside_constructor">field_initializer_outside_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#field_initializer_redirecting_constructor">field_initializer_redirecting_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#field_initializing_formal_not_assignable">field_initializing_formal_not_assignable</a></li>
<li class="toc-entry toc-h3"><a href="#field_in_struct_with_initializer">field_in_struct_with_initializer</a></li>
<li class="toc-entry toc-h3"><a href="#field_must_be_external_in_struct">field_must_be_external_in_struct</a></li>
<li class="toc-entry toc-h3"><a href="#final_initialized_in_declaration_and_constructor">final_initialized_in_declaration_and_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#final_not_initialized">final_not_initialized</a></li>
<li class="toc-entry toc-h3"><a href="#final_not_initialized_constructor">final_not_initialized_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#flutter_field_not_map">flutter_field_not_map</a></li>
<li class="toc-entry toc-h3"><a href="#for_in_of_invalid_element_type">for_in_of_invalid_element_type</a></li>
<li class="toc-entry toc-h3"><a href="#for_in_of_invalid_type">for_in_of_invalid_type</a></li>
<li class="toc-entry toc-h3"><a href="#for_in_with_const_variable">for_in_with_const_variable</a></li>
<li class="toc-entry toc-h3"><a href="#generic_method_type_instantiation_on_dynamic">generic_method_type_instantiation_on_dynamic</a></li>
<li class="toc-entry toc-h3"><a href="#generic_struct_subclass">generic_struct_subclass</a></li>
<li class="toc-entry toc-h3"><a href="#getter_not_subtype_setter_types">getter_not_subtype_setter_types</a></li>
<li class="toc-entry toc-h3"><a href="#illegal_async_generator_return_type">illegal_async_generator_return_type</a></li>
<li class="toc-entry toc-h3"><a href="#illegal_async_return_type">illegal_async_return_type</a></li>
<li class="toc-entry toc-h3"><a href="#illegal_concrete_enum_member">illegal_concrete_enum_member</a></li>
<li class="toc-entry toc-h3"><a href="#illegal_enum_values">illegal_enum_values</a></li>
<li class="toc-entry toc-h3"><a href="#illegal_sync_generator_return_type">illegal_sync_generator_return_type</a></li>
<li class="toc-entry toc-h3"><a href="#implements_non_class">implements_non_class</a></li>
<li class="toc-entry toc-h3"><a href="#implements_repeated">implements_repeated</a></li>
<li class="toc-entry toc-h3"><a href="#implements_super_class">implements_super_class</a></li>
<li class="toc-entry toc-h3"><a href="#implicit_super_initializer_missing_arguments">implicit_super_initializer_missing_arguments</a></li>
<li class="toc-entry toc-h3"><a href="#implicit_this_reference_in_initializer">implicit_this_reference_in_initializer</a></li>
<li class="toc-entry toc-h3"><a href="#import_deferred_library_with_load_function">import_deferred_library_with_load_function</a></li>
<li class="toc-entry toc-h3"><a href="#import_internal_library">import_internal_library</a></li>
<li class="toc-entry toc-h3"><a href="#import_of_legacy_library_into_null_safe">import_of_legacy_library_into_null_safe</a></li>
<li class="toc-entry toc-h3"><a href="#import_of_non_library">import_of_non_library</a></li>
<li class="toc-entry toc-h3"><a href="#inconsistent_inheritance">inconsistent_inheritance</a></li>
<li class="toc-entry toc-h3"><a href="#inconsistent_language_version_override">inconsistent_language_version_override</a></li>
<li class="toc-entry toc-h3"><a href="#initializer_for_non_existent_field">initializer_for_non_existent_field</a></li>
<li class="toc-entry toc-h3"><a href="#initializer_for_static_field">initializer_for_static_field</a></li>
<li class="toc-entry toc-h3"><a href="#initializing_formal_for_non_existent_field">initializing_formal_for_non_existent_field</a></li>
<li class="toc-entry toc-h3"><a href="#instance_access_to_static_member">instance_access_to_static_member</a></li>
<li class="toc-entry toc-h3"><a href="#instance_member_access_from_factory">instance_member_access_from_factory</a></li>
<li class="toc-entry toc-h3"><a href="#instance_member_access_from_static">instance_member_access_from_static</a></li>
<li class="toc-entry toc-h3"><a href="#instantiate_abstract_class">instantiate_abstract_class</a></li>
<li class="toc-entry toc-h3"><a href="#instantiate_enum">instantiate_enum</a></li>
<li class="toc-entry toc-h3"><a href="#instantiate_type_alias_expands_to_type_parameter">instantiate_type_alias_expands_to_type_parameter</a></li>
<li class="toc-entry toc-h3"><a href="#integer_literal_imprecise_as_double">integer_literal_imprecise_as_double</a></li>
<li class="toc-entry toc-h3"><a href="#integer_literal_out_of_range">integer_literal_out_of_range</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_annotation">invalid_annotation</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_annotation_constant_value_from_deferred_library">invalid_annotation_constant_value_from_deferred_library</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_annotation_from_deferred_library">invalid_annotation_from_deferred_library</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_annotation_target">invalid_annotation_target</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_assignment">invalid_assignment</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_dependency">invalid_dependency</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_exception_value">invalid_exception_value</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_export_of_internal_element">invalid_export_of_internal_element</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_export_of_internal_element_indirectly">invalid_export_of_internal_element_indirectly</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_extension_argument_count">invalid_extension_argument_count</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_factory_method_decl">invalid_factory_method_decl</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_factory_method_impl">invalid_factory_method_impl</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_factory_name_not_a_class">invalid_factory_name_not_a_class</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_field_type_in_struct">invalid_field_type_in_struct</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_implementation_override">invalid_implementation_override</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_inline_function_type">invalid_inline_function_type</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_internal_annotation">invalid_internal_annotation</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_language_version_override">invalid_language_version_override</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_literal_annotation">invalid_literal_annotation</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_modifier_on_constructor">invalid_modifier_on_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_modifier_on_setter">invalid_modifier_on_setter</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_non_virtual_annotation">invalid_non_virtual_annotation</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_null_aware_operator">invalid_null_aware_operator</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_override">invalid_override</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_override_of_non_virtual_member">invalid_override_of_non_virtual_member</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_reference_to_generative_enum_constructor">invalid_reference_to_generative_enum_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_reference_to_this">invalid_reference_to_this</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_return_type_for_catch_error">invalid_return_type_for_catch_error</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_sealed_annotation">invalid_sealed_annotation</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_super_formal_parameter_location">invalid_super_formal_parameter_location</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_type_argument_in_const_literal">invalid_type_argument_in_const_literal</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_uri">invalid_uri</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_use_of_covariant_in_extension">invalid_use_of_covariant_in_extension</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_use_of_internal_member">invalid_use_of_internal_member</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_use_of_null_value">invalid_use_of_null_value</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_use_of_visible_for_overriding_member">invalid_use_of_visible_for_overriding_member</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_use_of_visible_for_testing_member">invalid_use_of_visible_for_testing_member</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_visibility_annotation">invalid_visibility_annotation</a></li>
<li class="toc-entry toc-h3"><a href="#invalid_visible_for_overriding_annotation">invalid_visible_for_overriding_annotation</a></li>
<li class="toc-entry toc-h3"><a href="#invocation_of_extension_without_call">invocation_of_extension_without_call</a></li>
<li class="toc-entry toc-h3"><a href="#invocation_of_non_function">invocation_of_non_function</a></li>
<li class="toc-entry toc-h3"><a href="#invocation_of_non_function_expression">invocation_of_non_function_expression</a></li>
<li class="toc-entry toc-h3"><a href="#label_in_outer_scope">label_in_outer_scope</a></li>
<li class="toc-entry toc-h3"><a href="#label_undefined">label_undefined</a></li>
<li class="toc-entry toc-h3"><a href="#late_final_field_with_const_constructor">late_final_field_with_const_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#late_final_local_already_assigned">late_final_local_already_assigned</a></li>
<li class="toc-entry toc-h3"><a href="#leaf_call_must_not_return_handle">leaf_call_must_not_return_handle</a></li>
<li class="toc-entry toc-h3"><a href="#leaf_call_must_not_take_handle">leaf_call_must_not_take_handle</a></li>
<li class="toc-entry toc-h3"><a href="#list_element_type_not_assignable">list_element_type_not_assignable</a></li>
<li class="toc-entry toc-h3"><a href="#main_first_positional_parameter_type">main_first_positional_parameter_type</a></li>
<li class="toc-entry toc-h3"><a href="#main_has_required_named_parameters">main_has_required_named_parameters</a></li>
<li class="toc-entry toc-h3"><a href="#main_has_too_many_required_positional_parameters">main_has_too_many_required_positional_parameters</a></li>
<li class="toc-entry toc-h3"><a href="#main_is_not_function">main_is_not_function</a></li>
<li class="toc-entry toc-h3"><a href="#map_entry_not_in_map">map_entry_not_in_map</a></li>
<li class="toc-entry toc-h3"><a href="#map_key_type_not_assignable">map_key_type_not_assignable</a></li>
<li class="toc-entry toc-h3"><a href="#map_value_type_not_assignable">map_value_type_not_assignable</a></li>
<li class="toc-entry toc-h3"><a href="#mismatched_annotation_on_struct_field">mismatched_annotation_on_struct_field</a></li>
<li class="toc-entry toc-h3"><a href="#missing_annotation_on_struct_field">missing_annotation_on_struct_field</a></li>
<li class="toc-entry toc-h3"><a href="#missing_dart_library">missing_dart_library</a></li>
<li class="toc-entry toc-h3"><a href="#missing_default_value_for_parameter">missing_default_value_for_parameter</a></li>
<li class="toc-entry toc-h3"><a href="#missing_enum_constant_in_switch">missing_enum_constant_in_switch</a></li>
<li class="toc-entry toc-h3"><a href="#missing_exception_value">missing_exception_value</a></li>
<li class="toc-entry toc-h3"><a href="#missing_field_type_in_struct">missing_field_type_in_struct</a></li>
<li class="toc-entry toc-h3"><a href="#missing_name">missing_name</a></li>
<li class="toc-entry toc-h3"><a href="#missing_required_argument">missing_required_argument</a></li>
<li class="toc-entry toc-h3"><a href="#missing_required_param">missing_required_param</a></li>
<li class="toc-entry toc-h3"><a href="#missing_return">missing_return</a></li>
<li class="toc-entry toc-h3"><a href="#missing_size_annotation_carray">missing_size_annotation_carray</a></li>
<li class="toc-entry toc-h3"><a href="#mixin_application_concrete_super_invoked_member_type">mixin_application_concrete_super_invoked_member_type</a></li>
<li class="toc-entry toc-h3"><a href="#mixin_application_not_implemented_interface">mixin_application_not_implemented_interface</a></li>
<li class="toc-entry toc-h3"><a href="#mixin_application_no_concrete_super_invoked_member">mixin_application_no_concrete_super_invoked_member</a></li>
<li class="toc-entry toc-h3"><a href="#mixin_class_declares_constructor">mixin_class_declares_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#mixin_inherits_from_not_object">mixin_inherits_from_not_object</a></li>
<li class="toc-entry toc-h3"><a href="#mixin_instantiate">mixin_instantiate</a></li>
<li class="toc-entry toc-h3"><a href="#mixin_of_non_class">mixin_of_non_class</a></li>
<li class="toc-entry toc-h3"><a href="#mixin_on_sealed_class">mixin_on_sealed_class</a></li>
<li class="toc-entry toc-h3"><a href="#mixin_super_class_constraint_deferred_class">mixin_super_class_constraint_deferred_class</a></li>
<li class="toc-entry toc-h3"><a href="#mixin_super_class_constraint_non_interface">mixin_super_class_constraint_non_interface</a></li>
<li class="toc-entry toc-h3"><a href="#multiple_redirecting_constructor_invocations">multiple_redirecting_constructor_invocations</a></li>
<li class="toc-entry toc-h3"><a href="#multiple_super_initializers">multiple_super_initializers</a></li>
<li class="toc-entry toc-h3"><a href="#must_be_a_native_function_type">must_be_a_native_function_type</a></li>
<li class="toc-entry toc-h3"><a href="#must_be_a_subtype">must_be_a_subtype</a></li>
<li class="toc-entry toc-h3"><a href="#must_be_immutable">must_be_immutable</a></li>
<li class="toc-entry toc-h3"><a href="#must_call_super">must_call_super</a></li>
<li class="toc-entry toc-h3"><a href="#name_not_string">name_not_string</a></li>
<li class="toc-entry toc-h3"><a href="#new_with_undefined_constructor_default">new_with_undefined_constructor_default</a></li>
<li class="toc-entry toc-h3"><a href="#non_abstract_class_inherits_abstract_member">non_abstract_class_inherits_abstract_member</a></li>
<li class="toc-entry toc-h3"><a href="#non_bool_condition">non_bool_condition</a></li>
<li class="toc-entry toc-h3"><a href="#non_bool_expression">non_bool_expression</a></li>
<li class="toc-entry toc-h3"><a href="#non_bool_negation_expression">non_bool_negation_expression</a></li>
<li class="toc-entry toc-h3"><a href="#non_bool_operand">non_bool_operand</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_annotation_constructor">non_constant_annotation_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_case_expression">non_constant_case_expression</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_case_expression_from_deferred_library">non_constant_case_expression_from_deferred_library</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_default_value">non_constant_default_value</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_default_value_from_deferred_library">non_constant_default_value_from_deferred_library</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_list_element">non_constant_list_element</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_map_element">non_constant_map_element</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_map_key">non_constant_map_key</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_map_value">non_constant_map_value</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_set_element">non_constant_set_element</a></li>
<li class="toc-entry toc-h3"><a href="#non_constant_type_argument">non_constant_type_argument</a></li>
<li class="toc-entry toc-h3"><a href="#non_const_call_to_literal_constructor">non_const_call_to_literal_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#non_const_generative_enum_constructor">non_const_generative_enum_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#non_final_field_in_enum">non_final_field_in_enum</a></li>
<li class="toc-entry toc-h3"><a href="#non_generative_constructor">non_generative_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#non_generative_implicit_constructor">non_generative_implicit_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#non_native_function_type_argument_to_pointer">non_native_function_type_argument_to_pointer</a></li>
<li class="toc-entry toc-h3"><a href="#non_positive_array_dimension">non_positive_array_dimension</a></li>
<li class="toc-entry toc-h3"><a href="#non_sized_type_argument">non_sized_type_argument</a></li>
<li class="toc-entry toc-h3"><a href="#non_sync_factory">non_sync_factory</a></li>
<li class="toc-entry toc-h3"><a href="#non_type_as_type_argument">non_type_as_type_argument</a></li>
<li class="toc-entry toc-h3"><a href="#non_type_in_catch_clause">non_type_in_catch_clause</a></li>
<li class="toc-entry toc-h3"><a href="#non_void_return_for_operator">non_void_return_for_operator</a></li>
<li class="toc-entry toc-h3"><a href="#non_void_return_for_setter">non_void_return_for_setter</a></li>
<li class="toc-entry toc-h3"><a href="#not_assigned_potentially_non_nullable_local_variable">not_assigned_potentially_non_nullable_local_variable</a></li>
<li class="toc-entry toc-h3"><a href="#not_a_type">not_a_type</a></li>
<li class="toc-entry toc-h3"><a href="#not_binary_operator">not_binary_operator</a></li>
<li class="toc-entry toc-h3"><a href="#not_enough_positional_arguments">not_enough_positional_arguments</a></li>
<li class="toc-entry toc-h3"><a href="#not_initialized_non_nullable_instance_field">not_initialized_non_nullable_instance_field</a></li>
<li class="toc-entry toc-h3"><a href="#not_initialized_non_nullable_variable">not_initialized_non_nullable_variable</a></li>
<li class="toc-entry toc-h3"><a href="#not_iterable_spread">not_iterable_spread</a></li>
<li class="toc-entry toc-h3"><a href="#not_map_spread">not_map_spread</a></li>
<li class="toc-entry toc-h3"><a href="#no_annotation_constructor_arguments">no_annotation_constructor_arguments</a></li>
<li class="toc-entry toc-h3"><a href="#no_combined_super_signature">no_combined_super_signature</a></li>
<li class="toc-entry toc-h3"><a href="#no_generative_constructors_in_superclass">no_generative_constructors_in_superclass</a></li>
<li class="toc-entry toc-h3"><a href="#nullable_type_in_catch_clause">nullable_type_in_catch_clause</a></li>
<li class="toc-entry toc-h3"><a href="#nullable_type_in_extends_clause">nullable_type_in_extends_clause</a></li>
<li class="toc-entry toc-h3"><a href="#nullable_type_in_implements_clause">nullable_type_in_implements_clause</a></li>
<li class="toc-entry toc-h3"><a href="#nullable_type_in_on_clause">nullable_type_in_on_clause</a></li>
<li class="toc-entry toc-h3"><a href="#nullable_type_in_with_clause">nullable_type_in_with_clause</a></li>
<li class="toc-entry toc-h3"><a href="#null_argument_to_non_null_type">null_argument_to_non_null_type</a></li>
<li class="toc-entry toc-h3"><a href="#null_check_always_fails">null_check_always_fails</a></li>
<li class="toc-entry toc-h3"><a href="#on_repeated">on_repeated</a></li>
<li class="toc-entry toc-h3"><a href="#optional_parameter_in_operator">optional_parameter_in_operator</a></li>
<li class="toc-entry toc-h3"><a href="#override_on_non_overriding_member">override_on_non_overriding_member</a></li>
<li class="toc-entry toc-h3"><a href="#packed_annotation">packed_annotation</a></li>
<li class="toc-entry toc-h3"><a href="#packed_annotation_alignment">packed_annotation_alignment</a></li>
<li class="toc-entry toc-h3"><a href="#packed_nesting_non_packed">packed_nesting_non_packed</a></li>
<li class="toc-entry toc-h3"><a href="#part_of_different_library">part_of_different_library</a></li>
<li class="toc-entry toc-h3"><a href="#part_of_non_part">part_of_non_part</a></li>
<li class="toc-entry toc-h3"><a href="#part_of_unnamed_library">part_of_unnamed_library</a></li>
<li class="toc-entry toc-h3"><a href="#path_does_not_exist">path_does_not_exist</a></li>
<li class="toc-entry toc-h3"><a href="#path_not_posix">path_not_posix</a></li>
<li class="toc-entry toc-h3"><a href="#path_pubspec_does_not_exist">path_pubspec_does_not_exist</a></li>
<li class="toc-entry toc-h3"><a href="#positional_super_formal_parameter_with_positional_argument">positional_super_formal_parameter_with_positional_argument</a></li>
<li class="toc-entry toc-h3"><a href="#prefix_collides_with_top_level_member">prefix_collides_with_top_level_member</a></li>
<li class="toc-entry toc-h3"><a href="#prefix_identifier_not_followed_by_dot">prefix_identifier_not_followed_by_dot</a></li>
<li class="toc-entry toc-h3"><a href="#prefix_shadowed_by_local_declaration">prefix_shadowed_by_local_declaration</a></li>
<li class="toc-entry toc-h3"><a href="#private_collision_in_mixin_application">private_collision_in_mixin_application</a></li>
<li class="toc-entry toc-h3"><a href="#private_optional_parameter">private_optional_parameter</a></li>
<li class="toc-entry toc-h3"><a href="#private_setter">private_setter</a></li>
<li class="toc-entry toc-h3"><a href="#read_potentially_unassigned_final">read_potentially_unassigned_final</a></li>
<li class="toc-entry toc-h3"><a href="#recursive_compile_time_constant">recursive_compile_time_constant</a></li>
<li class="toc-entry toc-h3"><a href="#recursive_constructor_redirect">recursive_constructor_redirect</a></li>
<li class="toc-entry toc-h3"><a href="#recursive_interface_inheritance">recursive_interface_inheritance</a></li>
<li class="toc-entry toc-h3"><a href="#redirect_generative_to_missing_constructor">redirect_generative_to_missing_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#redirect_generative_to_non_generative_constructor">redirect_generative_to_non_generative_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#redirect_to_abstract_class_constructor">redirect_to_abstract_class_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#redirect_to_invalid_function_type">redirect_to_invalid_function_type</a></li>
<li class="toc-entry toc-h3"><a href="#redirect_to_invalid_return_type">redirect_to_invalid_return_type</a></li>
<li class="toc-entry toc-h3"><a href="#redirect_to_missing_constructor">redirect_to_missing_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#redirect_to_non_class">redirect_to_non_class</a></li>
<li class="toc-entry toc-h3"><a href="#redirect_to_non_const_constructor">redirect_to_non_const_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#redirect_to_type_alias_expands_to_type_parameter">redirect_to_type_alias_expands_to_type_parameter</a></li>
<li class="toc-entry toc-h3"><a href="#referenced_before_declaration">referenced_before_declaration</a></li>
<li class="toc-entry toc-h3"><a href="#rethrow_outside_catch">rethrow_outside_catch</a></li>
<li class="toc-entry toc-h3"><a href="#return_in_generative_constructor">return_in_generative_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#return_in_generator">return_in_generator</a></li>
<li class="toc-entry toc-h3"><a href="#return_of_do_not_store">return_of_do_not_store</a></li>
<li class="toc-entry toc-h3"><a href="#return_of_invalid_type">return_of_invalid_type</a></li>
<li class="toc-entry toc-h3"><a href="#return_of_invalid_type_from_closure">return_of_invalid_type_from_closure</a></li>
<li class="toc-entry toc-h3"><a href="#return_without_value">return_without_value</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_async_exported_from_core">sdk_version_async_exported_from_core</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_as_expression_in_const_context">sdk_version_as_expression_in_const_context</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_bool_operator_in_const_context">sdk_version_bool_operator_in_const_context</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_constructor_tearoffs">sdk_version_constructor_tearoffs</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_eq_eq_operator_in_const_context">sdk_version_eq_eq_operator_in_const_context</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_extension_methods">sdk_version_extension_methods</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_gt_gt_gt_operator">sdk_version_gt_gt_gt_operator</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_is_expression_in_const_context">sdk_version_is_expression_in_const_context</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_never">sdk_version_never</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_set_literal">sdk_version_set_literal</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_ui_as_code">sdk_version_ui_as_code</a></li>
<li class="toc-entry toc-h3"><a href="#sdk_version_ui_as_code_in_const_context">sdk_version_ui_as_code_in_const_context</a></li>
<li class="toc-entry toc-h3"><a href="#set_element_type_not_assignable">set_element_type_not_assignable</a></li>
<li class="toc-entry toc-h3"><a href="#shared_deferred_prefix">shared_deferred_prefix</a></li>
<li class="toc-entry toc-h3"><a href="#size_annotation_dimensions">size_annotation_dimensions</a></li>
<li class="toc-entry toc-h3"><a href="#static_access_to_instance_member">static_access_to_instance_member</a></li>
<li class="toc-entry toc-h3"><a href="#subtype_of_deferred_class">subtype_of_deferred_class</a></li>
<li class="toc-entry toc-h3"><a href="#subtype_of_disallowed_type">subtype_of_disallowed_type</a></li>
<li class="toc-entry toc-h3"><a href="#subtype_of_ffi_class">subtype_of_ffi_class</a></li>
<li class="toc-entry toc-h3"><a href="#subtype_of_sealed_class">subtype_of_sealed_class</a></li>
<li class="toc-entry toc-h3"><a href="#subtype_of_struct_class">subtype_of_struct_class</a></li>
<li class="toc-entry toc-h3"><a href="#supertype_expands_to_type_parameter">supertype_expands_to_type_parameter</a></li>
<li class="toc-entry toc-h3"><a href="#super_formal_parameter_type_is_not_subtype_of_associated">super_formal_parameter_type_is_not_subtype_of_associated</a></li>
<li class="toc-entry toc-h3"><a href="#super_formal_parameter_without_associated_named">super_formal_parameter_without_associated_named</a></li>
<li class="toc-entry toc-h3"><a href="#super_formal_parameter_without_associated_positional">super_formal_parameter_without_associated_positional</a></li>
<li class="toc-entry toc-h3"><a href="#super_invocation_not_last">super_invocation_not_last</a></li>
<li class="toc-entry toc-h3"><a href="#super_in_enum_constructor">super_in_enum_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#super_in_extension">super_in_extension</a></li>
<li class="toc-entry toc-h3"><a href="#super_in_invalid_context">super_in_invalid_context</a></li>
<li class="toc-entry toc-h3"><a href="#super_in_redirecting_constructor">super_in_redirecting_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#switch_case_completes_normally">switch_case_completes_normally</a></li>
<li class="toc-entry toc-h3"><a href="#switch_expression_not_assignable">switch_expression_not_assignable</a></li>
<li class="toc-entry toc-h3"><a href="#tearoff_of_generative_constructor_of_abstract_class">tearoff_of_generative_constructor_of_abstract_class</a></li>
<li class="toc-entry toc-h3"><a href="#text_direction_code_point_in_comment">text_direction_code_point_in_comment</a></li>
<li class="toc-entry toc-h3"><a href="#text_direction_code_point_in_literal">text_direction_code_point_in_literal</a></li>
<li class="toc-entry toc-h3"><a href="#throw_of_invalid_type">throw_of_invalid_type</a></li>
<li class="toc-entry toc-h3"><a href="#top_level_cycle">top_level_cycle</a></li>
<li class="toc-entry toc-h3"><a href="#type_alias_cannot_reference_itself">type_alias_cannot_reference_itself</a></li>
<li class="toc-entry toc-h3"><a href="#type_annotation_deferred_class">type_annotation_deferred_class</a></li>
<li class="toc-entry toc-h3"><a href="#type_argument_not_matching_bounds">type_argument_not_matching_bounds</a></li>
<li class="toc-entry toc-h3"><a href="#type_check_with_null">type_check_with_null</a></li>
<li class="toc-entry toc-h3"><a href="#type_parameter_referenced_by_static">type_parameter_referenced_by_static</a></li>
<li class="toc-entry toc-h3"><a href="#type_parameter_supertype_of_its_bound">type_parameter_supertype_of_its_bound</a></li>
<li class="toc-entry toc-h3"><a href="#type_test_with_non_type">type_test_with_non_type</a></li>
<li class="toc-entry toc-h3"><a href="#type_test_with_undefined_name">type_test_with_undefined_name</a></li>
<li class="toc-entry toc-h3"><a href="#unchecked_use_of_nullable_value">unchecked_use_of_nullable_value</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_annotation">undefined_annotation</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_class">undefined_class</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_constructor_in_initializer">undefined_constructor_in_initializer</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_enum_constant">undefined_enum_constant</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_enum_constructor">undefined_enum_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_extension_getter">undefined_extension_getter</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_extension_method">undefined_extension_method</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_extension_operator">undefined_extension_operator</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_extension_setter">undefined_extension_setter</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_function">undefined_function</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_getter">undefined_getter</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_hidden_name">undefined_hidden_name</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_identifier">undefined_identifier</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_identifier_await">undefined_identifier_await</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_method">undefined_method</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_named_parameter">undefined_named_parameter</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_operator">undefined_operator</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_prefixed_name">undefined_prefixed_name</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_referenced_parameter">undefined_referenced_parameter</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_setter">undefined_setter</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_shown_name">undefined_shown_name</a></li>
<li class="toc-entry toc-h3"><a href="#undefined_super_member">undefined_super_member</a></li>
<li class="toc-entry toc-h3"><a href="#unnecessary_cast">unnecessary_cast</a></li>
<li class="toc-entry toc-h3"><a href="#unnecessary_dev_dependency">unnecessary_dev_dependency</a></li>
<li class="toc-entry toc-h3"><a href="#unnecessary_final">unnecessary_final</a></li>
<li class="toc-entry toc-h3"><a href="#unnecessary_import">unnecessary_import</a></li>
<li class="toc-entry toc-h3"><a href="#unnecessary_non_null_assertion">unnecessary_non_null_assertion</a></li>
<li class="toc-entry toc-h3"><a href="#unnecessary_no_such_method">unnecessary_no_such_method</a></li>
<li class="toc-entry toc-h3"><a href="#unnecessary_null_comparison">unnecessary_null_comparison</a></li>
<li class="toc-entry toc-h3"><a href="#unnecessary_question_mark">unnecessary_question_mark</a></li>
<li class="toc-entry toc-h3"><a href="#unnecessary_type_check">unnecessary_type_check</a></li>
<li class="toc-entry toc-h3"><a href="#unqualified_reference_to_non_local_static_member">unqualified_reference_to_non_local_static_member</a></li>
<li class="toc-entry toc-h3"><a href="#unqualified_reference_to_static_member_of_extended_type">unqualified_reference_to_static_member_of_extended_type</a></li>
<li class="toc-entry toc-h3"><a href="#unused_catch_clause">unused_catch_clause</a></li>
<li class="toc-entry toc-h3"><a href="#unused_catch_stack">unused_catch_stack</a></li>
<li class="toc-entry toc-h3"><a href="#unused_element">unused_element</a></li>
<li class="toc-entry toc-h3"><a href="#unused_field">unused_field</a></li>
<li class="toc-entry toc-h3"><a href="#unused_import">unused_import</a></li>
<li class="toc-entry toc-h3"><a href="#unused_label">unused_label</a></li>
<li class="toc-entry toc-h3"><a href="#unused_local_variable">unused_local_variable</a></li>
<li class="toc-entry toc-h3"><a href="#unused_result">unused_result</a></li>
<li class="toc-entry toc-h3"><a href="#unused_shown_name">unused_shown_name</a></li>
<li class="toc-entry toc-h3"><a href="#uri_does_not_exist">uri_does_not_exist</a></li>
<li class="toc-entry toc-h3"><a href="#uri_has_not_been_generated">uri_has_not_been_generated</a></li>
<li class="toc-entry toc-h3"><a href="#uri_with_interpolation">uri_with_interpolation</a></li>
<li class="toc-entry toc-h3"><a href="#use_of_native_extension">use_of_native_extension</a></li>
<li class="toc-entry toc-h3"><a href="#use_of_void_result">use_of_void_result</a></li>
<li class="toc-entry toc-h3"><a href="#values_declaration_in_enum">values_declaration_in_enum</a></li>
<li class="toc-entry toc-h3"><a href="#variable_type_mismatch">variable_type_mismatch</a></li>
<li class="toc-entry toc-h3"><a href="#wrong_number_of_parameters_for_operator">wrong_number_of_parameters_for_operator</a></li>
<li class="toc-entry toc-h3"><a href="#wrong_number_of_parameters_for_setter">wrong_number_of_parameters_for_setter</a></li>
<li class="toc-entry toc-h3"><a href="#wrong_number_of_type_arguments">wrong_number_of_type_arguments</a></li>
<li class="toc-entry toc-h3"><a href="#wrong_number_of_type_arguments_constructor">wrong_number_of_type_arguments_constructor</a></li>
<li class="toc-entry toc-h3"><a href="#wrong_number_of_type_arguments_enum">wrong_number_of_type_arguments_enum</a></li>
<li class="toc-entry toc-h3"><a href="#wrong_number_of_type_arguments_extension">wrong_number_of_type_arguments_extension</a></li>
<li class="toc-entry toc-h3"><a href="#wrong_number_of_type_arguments_method">wrong_number_of_type_arguments_method</a></li>
<li class="toc-entry toc-h3"><a href="#yield_in_non_generator">yield_in_non_generator</a></li>
<li class="toc-entry toc-h3"><a href="#yield_of_invalid_type">yield_of_invalid_type</a></li>
</ul>
</li>
</ul>
</div>


          <p>This page lists diagnostic messages produced by the Dart analyzer,
with details about what those messages mean and how you can fix your code.
For more information about the analyzer, see
<a href="/guides/language/analysis-options">Customizing static analysis</a>.</p>

<h2 id="glossary">
<a class="anchor" href="#glossary" aria-hidden="true"><span class="octicon octicon-link"></span></a>Glossary</h2>

<p>This page uses the following terms:</p>

<ul>
  <li><a href="#constant-context">constant context</a></li>
  <li><a href="#definite-assignment">definite assignment</a></li>
  <li><a href="#mixin-application">mixin application</a></li>
  <li><a href="#override-inference">override inference</a></li>
  <li><a href="#part-file">part file</a></li>
  <li><a href="#potentially-non-nullable">potentially non-nullable</a></li>
  <li><a href="#public-library">public library</a></li>
</ul>

<h3 id="constant-context">
<a class="anchor" href="#constant-context" aria-hidden="true"><span class="octicon octicon-link"></span></a>Constant context</h3>

<p>A <em>constant context</em> is a region of code in which it isn’t necessary to include
the <code class="language-plaintext highlighter-rouge">const</code> keyword because it’s implied by the fact that everything in that
region is required to be a constant. The following locations are constant
contexts:</p>

<ul>
  <li>
    <p>Everything inside a list, map or set literal that’s prefixed by the
<code class="language-plaintext highlighter-rouge">const</code> keyword. Example:</p>

    <div class="language-dart highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="n">l</span> <span class="o">=</span> <span class="kd">const</span> <span class="o">[</span><span class="cm">/*constant context*/</span><span class="o">];</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>The arguments inside an invocation of a constant constructor. Example:</p>

    <div class="language-dart highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="n">p</span> <span class="o">=</span> <span class="kd">const</span> <span class="n">Point</span><span class="o">(</span><span class="cm">/*constant context*/</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>The initializer for a variable that’s prefixed by the <code class="language-plaintext highlighter-rouge">const</code> keyword.
Example:</p>

    <div class="language-dart highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="n">v</span> <span class="o">=</span> <span class="cm">/*constant context*/</span><span class="o">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Annotations</p>
  </li>
  <li>
    <p>The expression in a <code class="language-plaintext highlighter-rouge">case</code> clause. Example:</p>

    <div class="language-dart highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="cm">/*constant context*/</span><span class="o">:</span>
      <span class="k">break</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="definite-assignment">
<a class="anchor" href="#definite-assignment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Definite assignment</h3>

<p>Definite assignment analysis is the process of determining, for each local
variable at each point in the code, which of the following is true:</p>
<ul>
  <li>The variable has definitely been assigned a value (<em>definitely assigned</em>).</li>
  <li>The variable has definitely not been assigned a value (<em>definitely
unassigned</em>).</li>
  <li>The variable might or might not have been assigned a value, depending on the
execution path taken to arrive at that point.</li>
</ul>

<p>Definite assignment analysis helps find problems in code, such as places where a
variable that might not have been assigned a value is being referenced, or
places where a variable that can only be assigned a value one time is being
assigned after it might already have been assigned a value.</p>

<p>For example, in the following code the variable <code class="language-plaintext highlighter-rouge">s</code> is definitely unassigned
when it’s passed as an argument to <code class="language-plaintext highlighter-rouge">print</code>:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">String</span> <span class="n">s</span><span class="o">;</span>
  <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But in the following code, the variable <code class="language-plaintext highlighter-rouge">s</code> is definitely assigned:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">'Hello </span><span class="si">$name</span><span class="s">!'</span><span class="o">;</span>
  <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Definite assignment analysis can even tell whether a variable is definitely
assigned (or unassigned) when there are multiple possible execution paths. In
the following code the <code class="language-plaintext highlighter-rouge">print</code> function is called if execution goes through
either the true or the false branch of the <code class="language-plaintext highlighter-rouge">if</code> statement, but because <code class="language-plaintext highlighter-rouge">s</code> is
assigned no matter which branch is taken, it’s definitely assigned before it’s
passed to <code class="language-plaintext highlighter-rouge">print</code>:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">bool</span> <span class="n">casual</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">String</span> <span class="n">s</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">casual</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s">'Hi </span><span class="si">$name</span><span class="s">!'</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s">'Hello </span><span class="si">$name</span><span class="s">!'</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In flow analysis, the end of the <code class="language-plaintext highlighter-rouge">if</code> statement is referred to as a <em>join</em>—a
place where two or more execution paths merge back together. Where there’s a
join, the analysis says that a variable is definitely assigned if it’s
definitely assigned along all of the paths that are merging, and definitely
unassigned if it’s definitely unassigned along all of the paths.</p>

<p>Sometimes a variable is assigned a value on one path but not on another, in
which case the variable might or might not have been assigned a value. In the
following example, the true branch of the <code class="language-plaintext highlighter-rouge">if</code> statement might or might not be
executed, so the variable might or might be assigned a value:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">bool</span> <span class="n">casual</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">String</span> <span class="n">s</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">casual</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s">'Hi </span><span class="si">$name</span><span class="s">!'</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The same is true if there is a false branch that doesn’t assign a value to <code class="language-plaintext highlighter-rouge">s</code>.</p>

<p>The analysis of loops is a little more complicated, but it follows the same
basic reasoning. For example, the condition in a <code class="language-plaintext highlighter-rouge">while</code> loop is always
executed, but the body might or might not be. So just like an <code class="language-plaintext highlighter-rouge">if</code> statement,
there’s a join at the end of the <code class="language-plaintext highlighter-rouge">while</code> statement between the path in which the
condition is <code class="language-plaintext highlighter-rouge">true</code> and the path in which the condition is <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>For additional details, see the
<a href="https://github.com/dart-lang/language/blob/master/resources/type-system/flow-analysis.md">specification of definite assignment</a>.</p>

<h3 id="mixin-application">
<a class="anchor" href="#mixin-application" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mixin application</h3>

<p>A <em>mixin application</em> is the class created when a mixin is applied to a class.
For example, consider the following declarations:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{}</span>

<span class="kd">mixin</span> <span class="nc">M</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="k">with</span> <span class="n">M</span> <span class="o">{}</span>
</code></pre></div></div>

<p>The class <code class="language-plaintext highlighter-rouge">B</code> is a subclass of the mixin application of <code class="language-plaintext highlighter-rouge">M</code> to <code class="language-plaintext highlighter-rouge">A</code>, sometimes
nomenclated as <code class="language-plaintext highlighter-rouge">A+M</code>. The class <code class="language-plaintext highlighter-rouge">A+M</code> is a subclass of <code class="language-plaintext highlighter-rouge">A</code> and has members that
are copied from <code class="language-plaintext highlighter-rouge">M</code>.</p>

<p>You can give an actual name to a mixin application by defining it as:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{}</span>

<span class="kd">mixin</span> <span class="nc">M</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">A_M</span> <span class="o">=</span> <span class="n">A</span> <span class="k">with</span> <span class="n">M</span><span class="o">;</span>
</code></pre></div></div>

<p>Given this declaration of <code class="language-plaintext highlighter-rouge">A_M</code>, the following declaration of <code class="language-plaintext highlighter-rouge">B</code> is equivalent
to the declaration of <code class="language-plaintext highlighter-rouge">B</code> in the original example:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">A_M</span> <span class="o">{}</span>
</code></pre></div></div>

<h3 id="override-inference">
<a class="anchor" href="#override-inference" aria-hidden="true"><span class="octicon octicon-link"></span></a>Override inference</h3>

<p>Override inference is the process by which any missing types in a method
declaration are inferred based on the corresponding types from the method or
methods that it overrides.</p>

<p>If a candidate method (the method that’s missing type information) overrides a
single inherited method, then the corresponding types from the overridden method
are inferred. For example, consider the following code:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">m</span><span class="o">(</span><span class="kt">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">{</span>
  <span class="nd">@override</span>
  <span class="n">m</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The declaration of <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">B</code> is a candidate because it’s missing both the
return type and the parameter type. Because it overrides a single method (the
method <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">A</code>), the types from the overridden method will be used to infer
the missing types and it will be as if the method in <code class="language-plaintext highlighter-rouge">B</code> had been declared as
<code class="language-plaintext highlighter-rouge">int m(String s) =&gt; 1;</code>.</p>

<p>If a candidate method overrides multiple methods, and the function type one of
those overridden methods, M<sub>s</sub>, is a supertype of the function types of
all of the other overridden methods, then M<sub>s</sub> is used to infer the
missing types. For example, consider the following code:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">m</span><span class="o">(</span><span class="kt">num</span> <span class="n">n</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
  <span class="kt">num</span> <span class="n">m</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">A</span><span class="o">,</span> <span class="n">B</span> <span class="o">{</span>
  <span class="nd">@override</span>
  <span class="n">m</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The declaration of <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">C</code> is a candidate for override inference because it’s
missing both the return type and the parameter type. It overrides both <code class="language-plaintext highlighter-rouge">m</code> in
<code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">B</code>, so we need to choose one of them from which the missing
types can be inferred. But because the function type of <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">A</code>
(<code class="language-plaintext highlighter-rouge">int Function(num)</code>) is a supertype of the function type of <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">B</code>
(<code class="language-plaintext highlighter-rouge">num Function(int)</code>), the function in <code class="language-plaintext highlighter-rouge">A</code> is used to infer the missing types.
The result is the same as declaring the method in <code class="language-plaintext highlighter-rouge">C</code> as <code class="language-plaintext highlighter-rouge">int m(num n) =&gt; 1;</code>.</p>

<p>It is an error if none of the overridden methods has a function type that is a
supertype of all the other overridden methods.</p>

<h3 id="part-file">
<a class="anchor" href="#part-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Part file</h3>

<p>A part file is a Dart source file that contains a <code class="language-plaintext highlighter-rouge">part of</code> directive.</p>

<h3 id="potentially-non-nullable">
<a class="anchor" href="#potentially-non-nullable" aria-hidden="true"><span class="octicon octicon-link"></span></a>Potentially non-nullable</h3>

<p>A type is <em>potentially non-nullable</em> if it’s either explicitly non-nullable or
if it’s a type parameter.</p>

<p>A type is explicitly non-nullable if it is a type name that isn’t followed by a
question mark. Note that there are a few types that are always nullable, such as
<code class="language-plaintext highlighter-rouge">Null</code> and <code class="language-plaintext highlighter-rouge">dynamic</code>, and that <code class="language-plaintext highlighter-rouge">FutureOr</code> is only non-nullable if it isn’t
followed by a question mark <em>and</em> the type argument is non-nullable (such as
<code class="language-plaintext highlighter-rouge">FutureOr&lt;String&gt;</code>).</p>

<p>Type parameters are potentially non-nullable because the actual runtime type
(the type specified as a type argument) might be non-nullable. For example,
given a declaration of <code class="language-plaintext highlighter-rouge">class C&lt;T&gt; {}</code>, the type <code class="language-plaintext highlighter-rouge">C</code> could be used with a
non-nullable type argument as in <code class="language-plaintext highlighter-rouge">C&lt;int&gt;</code>.</p>

<h3 id="public-library">
<a class="anchor" href="#public-library" aria-hidden="true"><span class="octicon octicon-link"></span></a>Public library</h3>

<p>A public library is a library that is located inside the package’s <code class="language-plaintext highlighter-rouge">lib</code>
directory but not inside the <code class="language-plaintext highlighter-rouge">lib/src</code> directory.</p>

<h2 id="diagnostics">
<a class="anchor" href="#diagnostics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Diagnostics</h2>

<p>The analyzer produces the following diagnostics for code that
doesn’t conform to the language specification or
that might work in unexpected ways.</p>

<h3 id="abi_specific_integer_invalid">
<a class="anchor" href="#abi_specific_integer_invalid" aria-hidden="true"><span class="octicon octicon-link"></span></a>abi_specific_integer_invalid</h3>

<p><em>Classes extending ‘AbiSpecificInteger’ must have exactly one const constructor,
no other members, and no type parameters.</em></p>

<h4 id="description">Description</h4>

<p>The analyzer produces this diagnostic when a class that extends
<code class="language-plaintext highlighter-rouge">AbiSpecificInteger</code> doesn’t meet all of the following requirements:</p>
<ul>
  <li>there must be exactly one constructor</li>
  <li>the constructor must be marked <code class="language-plaintext highlighter-rouge">const</code>
</li>
  <li>there must not be any members of other than the one constructor</li>
  <li>there must not be any type parameters</li>
</ul>

<h4 id="examples">Examples</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code> doesn’t
define a const constructor:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})
class <span class="highlight">C</span> extends AbiSpecificInteger {
}</code></pre>

<p>The following code produces this diagnostic because the constructor isn’t
a <code class="language-plaintext highlighter-rouge">const</code> constructor:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})
class <span class="highlight">C</span> extends AbiSpecificInteger {
  C();
}</code></pre>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code> defines
multiple constructors:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})
class <span class="highlight">C</span> extends AbiSpecificInteger {
  const C.zero();
  const C.one();
}</code></pre>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code> defineS
a field:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})
class <span class="highlight">C</span> extends AbiSpecificInteger {
  final int i;

  const C(this.i);
}</code></pre>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code> has a
type parameter:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})
class <span class="highlight">C</span>&lt;T&gt; extends AbiSpecificInteger { // type parameters
  const C();
}</code></pre>

<h4 id="common-fixes">Common fixes</h4>

<p>Change the class so that it meets the requirements of having no type
parameters and a single member that is a <code class="language-plaintext highlighter-rouge">const</code> constructor:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})
class C extends AbiSpecificInteger {
  const C();
}</code></pre>

<h3 id="abi_specific_integer_mapping_extra">
<a class="anchor" href="#abi_specific_integer_mapping_extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>abi_specific_integer_mapping_extra</h3>

<p><em>Classes extending ‘AbiSpecificInteger’ must have exactly one
‘AbiSpecificIntegerMapping’ annotation specifying the mapping from ABI to a ‘NativeType’ integer with a fixed size.</em></p>

<h4 id="description-1">Description</h4>

<p>The analyzer produces this diagnostic when a class that extends
<code class="language-plaintext highlighter-rouge">AbiSpecificInteger</code> has more than one <code class="language-plaintext highlighter-rouge">AbiSpecificIntegerMapping</code>
annotation.</p>

<h4 id="example">Example</h4>

<p>The following code produces this diagnostic because there are two
<code class="language-plaintext highlighter-rouge">AbiSpecificIntegerMapping</code> annotations on the class <code class="language-plaintext highlighter-rouge">C</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})
@<span class="highlight">AbiSpecificIntegerMapping</span>({Abi.linuxX64 : Uint16()})
class C extends AbiSpecificInteger {
  const C();
}</code></pre>

<h4 id="common-fixes-1">Common fixes</h4>

<p>Remove all but one of the annotations, merging the arguments as
appropriate:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@AbiSpecificIntegerMapping({Abi.macosX64 : Int8(), Abi.linuxX64 : Uint16()})
class C extends AbiSpecificInteger {
  const C();
}</code></pre>

<h3 id="abi_specific_integer_mapping_missing">
<a class="anchor" href="#abi_specific_integer_mapping_missing" aria-hidden="true"><span class="octicon octicon-link"></span></a>abi_specific_integer_mapping_missing</h3>

<p><em>Classes extending ‘AbiSpecificInteger’ must have exactly one
‘AbiSpecificIntegerMapping’ annotation specifying the mapping from ABI to a ‘NativeType’ integer with a fixed size.</em></p>

<h4 id="description-2">Description</h4>

<p>The analyzer produces this diagnostic when a class that extends
<code class="language-plaintext highlighter-rouge">AbiSpecificInteger</code> doesn’t have an <code class="language-plaintext highlighter-rouge">AbiSpecificIntegerMapping</code>
annotation.</p>

<h4 id="example-1">Example</h4>

<p>The following code produces this diagnostic because there’s no
<code class="language-plaintext highlighter-rouge">AbiSpecificIntegerMapping</code> annotation on the class <code class="language-plaintext highlighter-rouge">C</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class <span class="highlight">C</span> extends AbiSpecificInteger {
  const C();
}</code></pre>

<h4 id="common-fixes-2">Common fixes</h4>

<p>Add an <code class="language-plaintext highlighter-rouge">AbiSpecificIntegerMapping</code> annotation to the class:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})
class C extends AbiSpecificInteger {
  const C();
}</code></pre>

<h3 id="abi_specific_integer_mapping_unsupported">
<a class="anchor" href="#abi_specific_integer_mapping_unsupported" aria-hidden="true"><span class="octicon octicon-link"></span></a>abi_specific_integer_mapping_unsupported</h3>

<p><em>Only mappings to ‘Int8’, ‘Int16’, ‘Int32’, ‘Int64’, ‘Uint8’, ‘Uint16’,
‘UInt32’, and ‘Uint64’ are supported.</em></p>

<h4 id="description-3">Description</h4>

<p>The analyzer produces this diagnostic when a value in the map argument of
an <code class="language-plaintext highlighter-rouge">AbiSpecificIntegerMapping</code> annotation is anything other than one of
the following integer types:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Int8</code></li>
  <li><code class="language-plaintext highlighter-rouge">Int16</code></li>
  <li><code class="language-plaintext highlighter-rouge">Int32</code></li>
  <li><code class="language-plaintext highlighter-rouge">Int64</code></li>
  <li><code class="language-plaintext highlighter-rouge">Uint8</code></li>
  <li><code class="language-plaintext highlighter-rouge">Uint16</code></li>
  <li><code class="language-plaintext highlighter-rouge">UInt32</code></li>
  <li><code class="language-plaintext highlighter-rouge">Uint64</code></li>
</ul>

<h4 id="example-2">Example</h4>

<p>The following code produces this diagnostic because the value of the map
entry is <code class="language-plaintext highlighter-rouge">Array&lt;Uint8&gt;</code>, which isn’t a valid integer type:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@<span class="highlight">AbiSpecificIntegerMapping</span>({Abi.macosX64 : Array&lt;Uint8&gt;(4)})
class C extends AbiSpecificInteger {
  const C();
}</code></pre>

<h4 id="common-fixes-3">Common fixes</h4>

<p>Use one of the valid types as a value in the map:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@AbiSpecificIntegerMapping({Abi.macosX64 : Int8()})
class C extends AbiSpecificInteger {
  const C();
}</code></pre>

<h3 id="abstract_field_initializer">
<a class="anchor" href="#abstract_field_initializer" aria-hidden="true"><span class="octicon octicon-link"></span></a>abstract_field_initializer</h3>

<p><em>Abstract fields can’t have initializers.</em></p>

<h4 id="description-4">Description</h4>

<p>The analyzer produces this diagnostic when a field that has the <code class="language-plaintext highlighter-rouge">abstract</code>
modifier also has an initializer.</p>

<h4 id="examples-1">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is marked as
<code class="language-plaintext highlighter-rouge">abstract</code> and has an initializer:</p>

<pre class="prettyprint lang-dart"><code>abstract class C {
  abstract int <span class="highlight">f</span> = 0;
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is marked as
<code class="language-plaintext highlighter-rouge">abstract</code> and there’s an initializer in the constructor:</p>

<pre class="prettyprint lang-dart"><code>abstract class C {
  abstract int f;

  C() : <span class="highlight">f</span> = 0;
}</code></pre>

<h4 id="common-fixes-4">Common fixes</h4>

<p>If the field must be abstract, then remove the initializer:</p>

<pre class="prettyprint lang-dart"><code>abstract class C {
  abstract int f;
}</code></pre>

<p>If the field isn’t required to be abstract, then remove the keyword:</p>

<pre class="prettyprint lang-dart"><code>abstract class C {
  int f = 0;
}</code></pre>

<h3 id="abstract_super_member_reference">
<a class="anchor" href="#abstract_super_member_reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>abstract_super_member_reference</h3>

<p><em>The {0} ‘{1}’ is always abstract in the supertype.</em></p>

<h4 id="description-5">Description</h4>

<p>The analyzer produces this diagnostic when an inherited member is
referenced using <code class="language-plaintext highlighter-rouge">super</code>, but there is no concrete implementation of the
member in the superclass chain. Abstract members can’t be invoked.</p>

<h4 id="example-3">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">B</code> doesn’t inherit a
concrete implementation of <code class="language-plaintext highlighter-rouge">a</code>:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  int get a;
}
class B extends A {
  int get a =&gt; super.<span class="highlight">a</span>;
}</code></pre>

<h4 id="common-fixes-5">Common fixes</h4>

<p>Remove the invocation of the abstract member, possibly replacing it with an
invocation of a concrete member.</p>

<h3 id="ambiguous_export">
<a class="anchor" href="#ambiguous_export" aria-hidden="true"><span class="octicon octicon-link"></span></a>ambiguous_export</h3>

<p><em>The name ‘{0}’ is defined in the libraries ‘{1}’ and ‘{2}’.</em></p>

<h4 id="description-6">Description</h4>

<p>The analyzer produces this diagnostic when two or more export directives
cause the same name to be exported from multiple libraries.</p>

<h4 id="example-4">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">a.dart</code> containing</p>

<pre class="prettyprint lang-dart"><code>class C {}</code></pre>

<p>And a file named <code class="language-plaintext highlighter-rouge">b.dart</code> containing</p>

<pre class="prettyprint lang-dart"><code>class C {}</code></pre>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">C</code> is being
exported from both <code class="language-plaintext highlighter-rouge">a.dart</code> and <code class="language-plaintext highlighter-rouge">b.dart</code>:</p>

<pre class="prettyprint lang-dart"><code>export 'a.dart';
export <span class="highlight">'b.dart'</span>;</code></pre>

<h4 id="common-fixes-6">Common fixes</h4>

<p>If none of the names in one of the libraries needs to be exported, then
remove the unnecessary export directives:</p>

<pre class="prettyprint lang-dart"><code>export 'a.dart';</code></pre>

<p>If all of the export directives are needed, then hide the name in all
except one of the directives:</p>

<pre class="prettyprint lang-dart"><code>export 'a.dart';
export 'b.dart' hide C;</code></pre>

<h3 id="ambiguous_extension_member_access">
<a class="anchor" href="#ambiguous_extension_member_access" aria-hidden="true"><span class="octicon octicon-link"></span></a>ambiguous_extension_member_access</h3>

<p><em>A member named ‘{0}’ is defined in {1}, and none are more specific.</em></p>

<h4 id="description-7">Description</h4>

<p>When code refers to a member of an object (for example, <code class="language-plaintext highlighter-rouge">o.m()</code> or <code class="language-plaintext highlighter-rouge">o.m</code> or
<code class="language-plaintext highlighter-rouge">o[i]</code>) where the static type of <code class="language-plaintext highlighter-rouge">o</code> doesn’t declare the member (<code class="language-plaintext highlighter-rouge">m</code> or
<code class="language-plaintext highlighter-rouge">[]</code>, for example), then the analyzer tries to find the member in an
extension. For example, if the member is <code class="language-plaintext highlighter-rouge">m</code>, then the analyzer looks for
extensions that declare a member named <code class="language-plaintext highlighter-rouge">m</code> and have an extended type that
the static type of <code class="language-plaintext highlighter-rouge">o</code> can be assigned to. When there’s more than one such
extension in scope, the extension whose extended type is most specific is
selected.</p>

<p>The analyzer produces this diagnostic when none of the extensions has an
extended type that’s more specific than the extended types of all of the
other extensions, making the reference to the member ambiguous.</p>

<h4 id="example-5">Example</h4>

<p>The following code produces this diagnostic because there’s no way to
choose between the member in <code class="language-plaintext highlighter-rouge">E1</code> and the member in <code class="language-plaintext highlighter-rouge">E2</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E1 on String {
  int get charCount =&gt; 1;
}

extension E2 on String {
  int get charCount =&gt; 2;
}

void f(String s) {
  print(s.<span class="highlight">charCount</span>);
}</code></pre>

<h4 id="common-fixes-7">Common fixes</h4>

<p>If you don’t need both extensions, then you can delete or hide one of them.</p>

<p>If you need both, then explicitly select the one you want to use by using
an extension override:</p>

<pre class="prettyprint lang-dart"><code>extension E1 on String {
  int get charCount =&gt; length;
}

extension E2 on String {
  int get charCount =&gt; length;
}

void f(String s) {
  print(E2(s).charCount);
}</code></pre>

<h3 id="ambiguous_import">
<a class="anchor" href="#ambiguous_import" aria-hidden="true"><span class="octicon octicon-link"></span></a>ambiguous_import</h3>

<p><em>The name ‘{0}’ is defined in the libraries {1}.</em></p>

<h4 id="description-8">Description</h4>

<p>The analyzer produces this diagnostic when a name is referenced that is
declared in two or more imported libraries.</p>

<h4 id="example-6">Example</h4>

<p>Given a library (<code class="language-plaintext highlighter-rouge">a.dart</code>) that defines a class (<code class="language-plaintext highlighter-rouge">C</code> in this example):</p>

<pre class="prettyprint lang-dart"><code>class A {}
class C {}</code></pre>

<p>And a library (<code class="language-plaintext highlighter-rouge">b.dart</code>) that defines a different class with the same name:</p>

<pre class="prettyprint lang-dart"><code>class B {}
class C {}</code></pre>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart';
import 'b.dart';

void f(<span class="highlight">C</span> c1, <span class="highlight">C</span> c2) {}</code></pre>

<h4 id="common-fixes-8">Common fixes</h4>

<p>If any of the libraries aren’t needed, then remove the import directives
for them:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart';

void f(C c1, C c2) {}</code></pre>

<p>If the name is still defined by more than one library, then add a <code class="language-plaintext highlighter-rouge">hide</code>
clause to the import directives for all except one library:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' hide C;
import 'b.dart';

void f(C c1, C c2) {}</code></pre>

<p>If you must be able to reference more than one of these types, then add a
prefix to each of the import directives, and qualify the references with
the appropriate prefix:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' as a;
import 'b.dart' as b;

void f(a.C c1, b.C c2) {}</code></pre>

<h3 id="ambiguous_set_or_map_literal_both">
<a class="anchor" href="#ambiguous_set_or_map_literal_both" aria-hidden="true"><span class="octicon octicon-link"></span></a>ambiguous_set_or_map_literal_both</h3>

<p><em>The literal can’t be either a map or a set because it contains at least one
literal map entry or a spread operator spreading a ‘Map’, and at least one element which is neither of these.</em></p>

<h4 id="description-9">Description</h4>

<p>Because map and set literals use the same delimiters (<code class="language-plaintext highlighter-rouge">{</code> and <code class="language-plaintext highlighter-rouge">}</code>), the
analyzer looks at the type arguments and the elements to determine which
kind of literal you meant. When there are no type arguments, then the
analyzer uses the types of the elements. If all of the elements are literal
map entries and all of the spread operators are spreading a <code class="language-plaintext highlighter-rouge">Map</code> then it’s
a <code class="language-plaintext highlighter-rouge">Map</code>. If none of the elements are literal map entries and all of the
spread operators are spreading an <code class="language-plaintext highlighter-rouge">Iterable</code>, then it’s a <code class="language-plaintext highlighter-rouge">Set</code>. If neither
of those is true then it’s ambiguous.</p>

<p>The analyzer produces this diagnostic when at least one element is a
literal map entry or a spread operator spreading a <code class="language-plaintext highlighter-rouge">Map</code>, and at least one
element is neither of these, making it impossible for the analyzer to
determine whether you are writing a map literal or a set literal.</p>

<h4 id="example-7">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>union(Map&lt;String, String&gt; a, List&lt;String&gt; b, Map&lt;String, String&gt; c) =&gt;
    <span class="highlight">{...a, ...b, ...c}</span>;</code></pre>

<p>The list <code class="language-plaintext highlighter-rouge">b</code> can only be spread into a set, and the maps <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">c</code> can
only be spread into a map, and the literal can’t be both.</p>

<h4 id="common-fixes-9">Common fixes</h4>

<p>There are two common ways to fix this problem. The first is to remove all
of the spread elements of one kind or another, so that the elements are
consistent. In this case, that likely means removing the list and deciding
what to do about the now unused parameter:</p>

<pre class="prettyprint lang-dart"><code>union(Map&lt;String, String&gt; a, List&lt;String&gt; b, Map&lt;String, String&gt; c) =&gt;
    {...a, ...c};</code></pre>

<p>The second fix is to change the elements of one kind into elements that are
consistent with the other elements. For example, you can add the elements
of the list as keys that map to themselves:</p>

<pre class="prettyprint lang-dart"><code>union(Map&lt;String, String&gt; a, List&lt;String&gt; b, Map&lt;String, String&gt; c) =&gt;
    {...a, for (String s in b) s: s, ...c};</code></pre>

<h3 id="ambiguous_set_or_map_literal_either">
<a class="anchor" href="#ambiguous_set_or_map_literal_either" aria-hidden="true"><span class="octicon octicon-link"></span></a>ambiguous_set_or_map_literal_either</h3>

<p><em>This literal must be either a map or a set, but the elements don’t have enough
information for type inference to work.</em></p>

<h4 id="description-10">Description</h4>

<p>Because map and set literals use the same delimiters (<code class="language-plaintext highlighter-rouge">{</code> and <code class="language-plaintext highlighter-rouge">}</code>), the
analyzer looks at the type arguments and the elements to determine which
kind of literal you meant. When there are no type arguments and all of the
elements are spread elements (which are allowed in both kinds of literals)
then the analyzer uses the types of the expressions that are being spread.
If all of the expressions have the type <code class="language-plaintext highlighter-rouge">Iterable</code>, then it’s a set
literal; if they all have the type <code class="language-plaintext highlighter-rouge">Map</code>, then it’s a map literal.</p>

<p>This diagnostic is produced when none of the expressions being spread have
a type that allows the analyzer to decide whether you were writing a map
literal or a set literal.</p>

<h4 id="example-8">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>union(a, b) =&gt; <span class="highlight">{...a, ...b}</span>;</code></pre>

<p>The problem occurs because there are no type arguments, and there is no
information about the type of either <code class="language-plaintext highlighter-rouge">a</code> or <code class="language-plaintext highlighter-rouge">b</code>.</p>

<h4 id="common-fixes-10">Common fixes</h4>

<p>There are three common ways to fix this problem. The first is to add type
arguments to the literal. For example, if the literal is intended to be a
map literal, you might write something like this:</p>

<pre class="prettyprint lang-dart"><code>union(a, b) =&gt; &lt;String, String&gt;{...a, ...b};</code></pre>

<p>The second fix is to add type information so that the expressions have
either the type <code class="language-plaintext highlighter-rouge">Iterable</code> or the type <code class="language-plaintext highlighter-rouge">Map</code>. You can add an explicit cast
or, in this case, add types to the declarations of the two parameters:</p>

<pre class="prettyprint lang-dart"><code>union(List&lt;int&gt; a, List&lt;int&gt; b) =&gt; {...a, ...b};</code></pre>

<p>The third fix is to add context information. In this case, that means
adding a return type to the function:</p>

<pre class="prettyprint lang-dart"><code>Set&lt;String&gt; union(a, b) =&gt; {...a, ...b};</code></pre>

<p>In other cases, you might add a type somewhere else. For example, say the
original code looks like this:</p>

<pre class="prettyprint lang-dart"><code>union(a, b) {
  var x = <span class="highlight">{...a, ...b}</span>;
  return x;
}</code></pre>

<p>You might add a type annotation on <code class="language-plaintext highlighter-rouge">x</code>, like this:</p>

<pre class="prettyprint lang-dart"><code>union(a, b) {
  Map&lt;String, String&gt; x = {...a, ...b};
  return x;
}</code></pre>

<h3 id="annotation_on_pointer_field">
<a class="anchor" href="#annotation_on_pointer_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>annotation_on_pointer_field</h3>

<p><em>Fields in a struct class whose type is ‘Pointer’ shouldn’t have any
annotations.</em></p>

<h4 id="description-11">Description</h4>

<p>The analyzer produces this diagnostic when a field that’s declared in a
subclass of <code class="language-plaintext highlighter-rouge">Struct</code> and has the type <code class="language-plaintext highlighter-rouge">Pointer</code> also has an annotation
associated with it.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-9">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">p</code>, which
has the type <code class="language-plaintext highlighter-rouge">Pointer</code> and is declared in a subclass of <code class="language-plaintext highlighter-rouge">Struct</code>, has the
annotation <code class="language-plaintext highlighter-rouge">@Double()</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  <span class="highlight">@Double()</span>
  external Pointer&lt;Int8&gt; p;
}</code></pre>

<h4 id="common-fixes-11">Common fixes</h4>

<p>Remove the annotations from the field:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  external Pointer&lt;Int8&gt; p;
}</code></pre>

<h3 id="argument_must_be_a_constant">
<a class="anchor" href="#argument_must_be_a_constant" aria-hidden="true"><span class="octicon octicon-link"></span></a>argument_must_be_a_constant</h3>

<p><em>Argument ‘{0}’ must be a constant.</em></p>

<h4 id="description-12">Description</h4>

<p>The analyzer produces this diagnostic when an invocation of either
<code class="language-plaintext highlighter-rouge">Pointer.asFunction</code> or <code class="language-plaintext highlighter-rouge">DynamicLibrary.lookupFunction</code> has an <code class="language-plaintext highlighter-rouge">isLeaf</code>
argument whose value isn’t a constant expression.</p>

<p>The analyzer also produces this diagnostic when the value of the
<code class="language-plaintext highlighter-rouge">exceptionalReturn</code> argument of <code class="language-plaintext highlighter-rouge">Pointer.fromFunction</code>.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-10">Example</h4>

<p>The following code produces this diagnostic because the value of the
<code class="language-plaintext highlighter-rouge">isLeaf</code> argument is a parameter, and hence isn’t a constant:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

int Function(int) fromPointer(
    Pointer&lt;NativeFunction&lt;Int8 Function(Int8)&gt;&gt; p, bool isLeaf) {
  return p.asFunction(isLeaf: <span class="highlight">isLeaf</span>);
}</code></pre>

<h4 id="common-fixes-12">Common fixes</h4>

<p>If there’s a suitable constant that can be used, then replace the argument
with a constant:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

const isLeaf = false;

int Function(int) fromPointer(Pointer&lt;NativeFunction&lt;Int8 Function(Int8)&gt;&gt; p) {
  return p.asFunction(isLeaf: isLeaf);
}</code></pre>

<p>If there isn’t a suitable constant, then replace the argument with a
boolean literal:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

int Function(int) fromPointer(Pointer&lt;NativeFunction&lt;Int8 Function(Int8)&gt;&gt; p) {
  return p.asFunction(isLeaf: true);
}</code></pre>

<h3 id="argument_type_not_assignable">
<a class="anchor" href="#argument_type_not_assignable" aria-hidden="true"><span class="octicon octicon-link"></span></a>argument_type_not_assignable</h3>

<p><em>The argument type ‘{0}’ can’t be assigned to the parameter type ‘{1}’.</em></p>

<h4 id="description-13">Description</h4>

<p>The analyzer produces this diagnostic when the static type of an argument
can’t be assigned to the static type of the corresponding parameter.</p>

<h4 id="example-11">Example</h4>

<p>The following code produces this diagnostic because a <code class="language-plaintext highlighter-rouge">num</code> can’t be
assigned to a <code class="language-plaintext highlighter-rouge">String</code>:</p>

<pre class="prettyprint lang-dart"><code>String f(String x) =&gt; x;
String g(num y) =&gt; f(<span class="highlight">y</span>);</code></pre>

<h4 id="common-fixes-13">Common fixes</h4>

<p>If possible, rewrite the code so that the static type is assignable. In the
example above you might be able to change the type of the parameter <code class="language-plaintext highlighter-rouge">y</code>:</p>

<pre class="prettyprint lang-dart"><code>String f(String x) =&gt; x;
String g(String y) =&gt; f(y);</code></pre>

<p>If that fix isn’t possible, then add code to handle the case where the
argument value isn’t the required type. One approach is to coerce other
types to the required type:</p>

<pre class="prettyprint lang-dart"><code>String f(String x) =&gt; x;
String g(num y) =&gt; f(y.toString());</code></pre>

<p>Another approach is to add explicit type tests and fallback code:</p>

<pre class="prettyprint lang-dart"><code>String f(String x) =&gt; x;
String g(num y) =&gt; f(y is String ? y : '');</code></pre>

<p>If you believe that the runtime type of the argument will always be the
same as the static type of the parameter, and you’re willing to risk having
an exception thrown at runtime if you’re wrong, then add an explicit cast:</p>

<pre class="prettyprint lang-dart"><code>String f(String x) =&gt; x;
String g(num y) =&gt; f(y as String);</code></pre>

<h3 id="argument_type_not_assignable_to_error_handler">
<a class="anchor" href="#argument_type_not_assignable_to_error_handler" aria-hidden="true"><span class="octicon octicon-link"></span></a>argument_type_not_assignable_to_error_handler</h3>

<p><em>The argument type ‘{0}’ can’t be assigned to the parameter type ‘{1}
Function(Object)’ or ‘{1} Function(Object, StackTrace)’.</em></p>

<h4 id="description-14">Description</h4>

<p>The analyzer produces this diagnostic when an invocation of
<code class="language-plaintext highlighter-rouge">Future.catchError</code> has an argument that is a function whose parameters
aren’t compatible with the arguments that will be passed to the function
when it’s invoked. The static type of the first argument to <code class="language-plaintext highlighter-rouge">catchError</code>
is just <code class="language-plaintext highlighter-rouge">Function</code>, even though the function that is passed in is expected
to have either a single parameter of type <code class="language-plaintext highlighter-rouge">Object</code> or two parameters of
type <code class="language-plaintext highlighter-rouge">Object</code> and <code class="language-plaintext highlighter-rouge">StackTrace</code>.</p>

<h4 id="examples-2">Examples</h4>

<p>The following code produces this diagnostic because the closure being
passed to <code class="language-plaintext highlighter-rouge">catchError</code> doesn’t take any parameters, but the function is
required to take at least one parameter:</p>

<pre class="prettyprint lang-dart"><code>void f(Future&lt;int&gt; f) {
  f.catchError(<span class="highlight">() =&gt; 0</span>);
}</code></pre>

<p>The following code produces this diagnostic because the closure being
passed to <code class="language-plaintext highlighter-rouge">catchError</code> takes three parameters, but it can’t have more than
two required parameters:</p>

<pre class="prettyprint lang-dart"><code>void f(Future&lt;int&gt; f) {
  f.catchError(<span class="highlight">(one, two, three) =&gt; 0</span>);
}</code></pre>

<p>The following code produces this diagnostic because even though the closure
being passed to <code class="language-plaintext highlighter-rouge">catchError</code> takes one parameter, the closure doesn’t have
a type that is compatible with <code class="language-plaintext highlighter-rouge">Object</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(Future&lt;int&gt; f) {
  f.catchError(<span class="highlight">(String error) =&gt; 0</span>);
}</code></pre>

<h4 id="common-fixes-14">Common fixes</h4>

<p>Change the function being passed to <code class="language-plaintext highlighter-rouge">catchError</code> so that it has either one
or two required parameters, and the parameters have the required types:</p>

<pre class="prettyprint lang-dart"><code>void f(Future&lt;int&gt; f) {
  f.catchError((Object error) =&gt; 0);
}</code></pre>

<h3 id="assert_in_redirecting_constructor">
<a class="anchor" href="#assert_in_redirecting_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>assert_in_redirecting_constructor</h3>

<p><em>A redirecting constructor can’t have an ‘assert’ initializer.</em></p>

<h4 id="description-15">Description</h4>

<p>The analyzer produces this diagnostic when a redirecting constructor (a
constructor that redirects to another constructor in the same class) has an
assert in the initializer list.</p>

<h4 id="example-12">Example</h4>

<p>The following code produces this diagnostic because the unnamed constructor
is a redirecting constructor and also has an assert in the initializer
list:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C(int x) : <span class="highlight">assert(x &gt; 0)</span>, this.name();
  C.name() {}
}</code></pre>

<h4 id="common-fixes-15">Common fixes</h4>

<p>If the assert isn’t needed, then remove it:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C(int x) : this.name();
  C.name() {}
}</code></pre>

<p>If the assert is needed, then convert the constructor into a factory
constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  factory C(int x) {
    assert(x &gt; 0);
    return C.name();
  }
  C.name() {}
}</code></pre>

<h3 id="asset_directory_does_not_exist">
<a class="anchor" href="#asset_directory_does_not_exist" aria-hidden="true"><span class="octicon octicon-link"></span></a>asset_directory_does_not_exist</h3>

<p><em>The asset directory ‘{0}’ doesn’t exist.</em></p>

<h4 id="description-16">Description</h4>

<p>The analyzer produces this diagnostic when an asset list contains a value
referencing a directory that doesn’t exist.</p>

<h4 id="example-13">Example</h4>

<p>Assuming that the directory <code class="language-plaintext highlighter-rouge">assets</code> doesn’t exist, the following code
produces this diagnostic because it’s listed as a directory containing
assets:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">flutter</span><span class="pi">:</span>
  <span class="na">assets</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">assets/</span>
</code></pre></div></div>

<h4 id="common-fixes-16">Common fixes</h4>

<p>If the path is correct, then create a directory at that path.</p>

<p>If the path isn’t correct, then change the path to match the path of the
directory containing the assets.</p>

<h3 id="asset_does_not_exist">
<a class="anchor" href="#asset_does_not_exist" aria-hidden="true"><span class="octicon octicon-link"></span></a>asset_does_not_exist</h3>

<p><em>The asset file ‘{0}’ doesn’t exist.</em></p>

<h4 id="description-17">Description</h4>

<p>The analyzer produces this diagnostic when an asset list contains a value
referencing a file that doesn’t exist.</p>

<h4 id="example-14">Example</h4>

<p>Assuming that the file <code class="language-plaintext highlighter-rouge">doesNotExist.gif</code> doesn’t exist, the following code
produces this diagnostic because it’s listed as an asset:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">flutter</span><span class="pi">:</span>
  <span class="na">assets</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">doesNotExist.gif</span>
</code></pre></div></div>

<h4 id="common-fixes-17">Common fixes</h4>

<p>If the path is correct, then create a file at that path.</p>

<p>If the path isn’t correct, then change the path to match the path of the
file containing the asset.</p>

<h3 id="asset_field_not_list">
<a class="anchor" href="#asset_field_not_list" aria-hidden="true"><span class="octicon octicon-link"></span></a>asset_field_not_list</h3>

<p><em>The value of the ‘asset’ field is expected to be a list of relative file
paths.</em></p>

<h4 id="description-18">Description</h4>

<p>The analyzer produces this diagnostic when the value of the <code class="language-plaintext highlighter-rouge">asset</code> key
isn’t a list.</p>

<h4 id="example-15">Example</h4>

<p>The following code produces this diagnostic because the value of the assets
key is a string when a list is expected:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">flutter</span><span class="pi">:</span>
  <span class="na">assets</span><span class="pi">:</span> <span class="s">assets/</span>
</code></pre></div></div>

<h4 id="common-fixes-18">Common fixes</h4>

<p>Change the value of the asset list so that it’s a list:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">flutter</span><span class="pi">:</span>
  <span class="na">assets</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">assets/</span>
</code></pre></div></div>

<h3 id="asset_not_string">
<a class="anchor" href="#asset_not_string" aria-hidden="true"><span class="octicon octicon-link"></span></a>asset_not_string</h3>

<p><em>Assets are required to be file paths (strings).</em></p>

<h4 id="description-19">Description</h4>

<p>The analyzer produces this diagnostic when an asset list contains a value
that isn’t a string.</p>

<h4 id="example-16">Example</h4>

<p>The following code produces this diagnostic because the asset list contains
a map:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">flutter</span><span class="pi">:</span>
  <span class="na">assets</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">image.gif</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div></div>

<h4 id="common-fixes-19">Common fixes</h4>

<p>Change the asset list so that it only contains valid POSIX-style file
paths:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">flutter</span><span class="pi">:</span>
  <span class="na">assets</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">image.gif</span>
</code></pre></div></div>

<h3 id="assignment_of_do_not_store">
<a class="anchor" href="#assignment_of_do_not_store" aria-hidden="true"><span class="octicon octicon-link"></span></a>assignment_of_do_not_store</h3>

<p><em>‘{0}’ is marked ‘doNotStore’ and shouldn’t be assigned to a field or top-level
variable.</em></p>

<h4 id="description-20">Description</h4>

<p>The analyzer produces this diagnostic when the value of a function
(including methods and getters) that is explicitly or implicitly marked by
the <code class="language-plaintext highlighter-rouge">[doNotStore][meta-doNotStore]</code> annotation is stored in either a field
or top-level variable.</p>

<h4 id="example-17">Example</h4>

<p>The following code produces this diagnostic because the value of the
function <code class="language-plaintext highlighter-rouge">f</code> is being stored in the top-level variable <code class="language-plaintext highlighter-rouge">x</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@doNotStore
int f() =&gt; 1;

var x = <span class="highlight">f()</span>;</code></pre>

<h4 id="common-fixes-20">Common fixes</h4>

<p>Replace references to the field or variable with invocations of the
function producing the value.</p>

<h3 id="assignment_to_const">
<a class="anchor" href="#assignment_to_const" aria-hidden="true"><span class="octicon octicon-link"></span></a>assignment_to_const</h3>

<p><em>Constant variables can’t be assigned a value.</em></p>

<h4 id="description-21">Description</h4>

<p>The analyzer produces this diagnostic when it finds an assignment to a
top-level variable, a static field, or a local variable that has the
<code class="language-plaintext highlighter-rouge">const</code> modifier. The value of a compile-time constant can’t be changed at
runtime.</p>

<h4 id="example-18">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">c</code> is being assigned a
value even though it has the <code class="language-plaintext highlighter-rouge">const</code> modifier:</p>

<pre class="prettyprint lang-dart"><code>const c = 0;

void f() {
  <span class="highlight">c</span> = 1;
  print(c);
}</code></pre>

<h4 id="common-fixes-21">Common fixes</h4>

<p>If the variable must be assignable, then remove the <code class="language-plaintext highlighter-rouge">const</code> modifier:</p>

<pre class="prettyprint lang-dart"><code>var c = 0;

void f() {
  c = 1;
  print(c);
}</code></pre>

<p>If the constant shouldn’t be changed, then either remove the assignment or
use a local variable in place of references to the constant:</p>

<pre class="prettyprint lang-dart"><code>const c = 0;

void f() {
  var v = 1;
  print(v);
}</code></pre>

<h3 id="assignment_to_final">
<a class="anchor" href="#assignment_to_final" aria-hidden="true"><span class="octicon octicon-link"></span></a>assignment_to_final</h3>

<p><em>‘{0}’ can’t be used as a setter because it’s final.</em></p>

<h4 id="description-22">Description</h4>

<p>The analyzer produces this diagnostic when it finds an invocation of a
setter, but there’s no setter because the field with the same name was
declared to be <code class="language-plaintext highlighter-rouge">final</code> or <code class="language-plaintext highlighter-rouge">const</code>.</p>

<h4 id="example-19">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">v</code> is final:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final v = 0;
}

f(C c) {
  c.<span class="highlight">v</span> = 1;
}</code></pre>

<h4 id="common-fixes-22">Common fixes</h4>

<p>If you need to be able to set the value of the field, then remove the
modifier <code class="language-plaintext highlighter-rouge">final</code> from the field:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int v = 0;
}

f(C c) {
  c.v = 1;
}</code></pre>

<h3 id="assignment_to_final_local">
<a class="anchor" href="#assignment_to_final_local" aria-hidden="true"><span class="octicon octicon-link"></span></a>assignment_to_final_local</h3>

<p><em>The final variable ‘{0}’ can only be set once.</em></p>

<h4 id="description-23">Description</h4>

<p>The analyzer produces this diagnostic when a local variable that was
declared to be final is assigned after it was initialized.</p>

<h4 id="example-20">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> is final, so it
can’t have a value assigned to it after it was initialized:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  final x = 0;
  <span class="highlight">x</span> = 3;
  print(x);
}</code></pre>

<h4 id="common-fixes-23">Common fixes</h4>

<p>Remove the keyword <code class="language-plaintext highlighter-rouge">final</code>, and replace it with <code class="language-plaintext highlighter-rouge">var</code> if there’s no type
annotation:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  var x = 0;
  x = 3;
  print(x);
}</code></pre>

<h3 id="assignment_to_final_no_setter">
<a class="anchor" href="#assignment_to_final_no_setter" aria-hidden="true"><span class="octicon octicon-link"></span></a>assignment_to_final_no_setter</h3>

<p><em>There isn’t a setter named ‘{0}’ in class ‘{1}’.</em></p>

<h4 id="description-24">Description</h4>

<p>The analyzer produces this diagnostic when a reference to a setter is
found; there is no setter defined for the type; but there is a getter
defined with the same name.</p>

<h4 id="example-21">Example</h4>

<p>The following code produces this diagnostic because there is no setter
named <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">C</code>, but there is a getter named <code class="language-plaintext highlighter-rouge">x</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int get x =&gt; 0;
  set y(int p) {}
}

void f(C c) {
  c.<span class="highlight">x</span> = 1;
}</code></pre>

<h4 id="common-fixes-24">Common fixes</h4>

<p>If you want to invoke an existing setter, then correct the name:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int get x =&gt; 0;
  set y(int p) {}
}

void f(C c) {
  c.y = 1;
}</code></pre>

<p>If you want to invoke the setter but it just doesn’t exist yet, then
declare it:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int get x =&gt; 0;
  set x(int p) {}
  set y(int p) {}
}

void f(C c) {
  c.x = 1;
}</code></pre>

<h3 id="assignment_to_function">
<a class="anchor" href="#assignment_to_function" aria-hidden="true"><span class="octicon octicon-link"></span></a>assignment_to_function</h3>

<p><em>Functions can’t be assigned a value.</em></p>

<h4 id="description-25">Description</h4>

<p>The analyzer produces this diagnostic when the name of a function appears
on the left-hand side of an assignment expression.</p>

<h4 id="example-22">Example</h4>

<p>The following code produces this diagnostic because the assignment to the
function <code class="language-plaintext highlighter-rouge">f</code> is invalid:</p>

<pre class="prettyprint lang-dart"><code>void f() {}

void g() {
  <span class="highlight">f</span> = () {};
}</code></pre>

<h4 id="common-fixes-25">Common fixes</h4>

<p>If the right-hand side should be assigned to something else, such as a
local variable, then change the left-hand side:</p>

<pre class="prettyprint lang-dart"><code>void f() {}

void g() {
  var x = () {};
  print(x);
}</code></pre>

<p>If the intent is to change the implementation of the function, then define
a function-valued variable instead of a function:</p>

<pre class="prettyprint lang-dart"><code>void Function() f = () {};

void g() {
  f = () {};
}</code></pre>

<h3 id="assignment_to_method">
<a class="anchor" href="#assignment_to_method" aria-hidden="true"><span class="octicon octicon-link"></span></a>assignment_to_method</h3>

<p><em>Methods can’t be assigned a value.</em></p>

<h4 id="description-26">Description</h4>

<p>The analyzer produces this diagnostic when the target of an assignment is a
method.</p>

<h4 id="example-23">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> can’t be assigned a
value because it’s a method:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void f() {}

  void g() {
    <span class="highlight">f</span> = null;
  }
}</code></pre>

<h4 id="common-fixes-26">Common fixes</h4>

<p>Rewrite the code so that there isn’t an assignment to a method.</p>

<h3 id="assignment_to_type">
<a class="anchor" href="#assignment_to_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>assignment_to_type</h3>

<p><em>Types can’t be assigned a value.</em></p>

<h4 id="description-27">Description</h4>

<p>The analyzer produces this diagnostic when the name of a type name appears
on the left-hand side of an assignment expression.</p>

<h4 id="example-24">Example</h4>

<p>The following code produces this diagnostic because the assignment to the
class <code class="language-plaintext highlighter-rouge">C</code> is invalid:</p>

<pre class="prettyprint lang-dart"><code>class C {}

void f() {
  <span class="highlight">C</span> = null;
}</code></pre>

<h4 id="common-fixes-27">Common fixes</h4>

<p>If the right-hand side should be assigned to something else, such as a
local variable, then change the left-hand side:</p>

<pre class="prettyprint lang-dart"><code>void f() {}

void g() {
  var c = null;
  print(c);
}</code></pre>

<h3 id="async_for_in_wrong_context">
<a class="anchor" href="#async_for_in_wrong_context" aria-hidden="true"><span class="octicon octicon-link"></span></a>async_for_in_wrong_context</h3>

<p><em>The async for-in loop can only be used in an async function.</em></p>

<h4 id="description-28">Description</h4>

<p>The analyzer produces this diagnostic when an async for-in loop is found in
a function or method whose body isn’t marked as being either <code class="language-plaintext highlighter-rouge">async</code> or
<code class="language-plaintext highlighter-rouge">async*</code>.</p>

<h4 id="example-25">Example</h4>

<p>The following code produces this diagnostic because the body of <code class="language-plaintext highlighter-rouge">f</code> isn’t
marked as being either <code class="language-plaintext highlighter-rouge">async</code> or <code class="language-plaintext highlighter-rouge">async*</code>, but <code class="language-plaintext highlighter-rouge">f</code> contains an async
for-in loop:</p>

<pre class="prettyprint lang-dart"><code>void f(list) {
  await for (var e <span class="highlight">in</span> list) {
    print(e);
  }
}</code></pre>

<h4 id="common-fixes-28">Common fixes</h4>

<p>If the function should return a <code class="language-plaintext highlighter-rouge">Future</code>, then mark the body with <code class="language-plaintext highlighter-rouge">async</code>:</p>

<pre class="prettyprint lang-dart"><code>Future&lt;void&gt; f(list) async {
  await for (var e in list) {
    print(e);
  }
}</code></pre>

<p>If the function should return a <code class="language-plaintext highlighter-rouge">Stream</code> of values, then mark the body with
<code class="language-plaintext highlighter-rouge">async*</code>:</p>

<pre class="prettyprint lang-dart"><code>Stream&lt;void&gt; f(list) async* {
  await for (var e in list) {
    print(e);
  }
}</code></pre>

<p>If the function should be synchronous, then remove the <code class="language-plaintext highlighter-rouge">await</code> before the
loop:</p>

<pre class="prettyprint lang-dart"><code>void f(list) {
  for (var e in list) {
    print(e);
  }
}</code></pre>

<h3 id="await_in_late_local_variable_initializer">
<a class="anchor" href="#await_in_late_local_variable_initializer" aria-hidden="true"><span class="octicon octicon-link"></span></a>await_in_late_local_variable_initializer</h3>

<p><em>The ‘await’ expression can’t be used in a ‘late’ local variable’s initializer.</em></p>

<h4 id="description-29">Description</h4>

<p>The analyzer produces this diagnostic when a local variable that has the
<code class="language-plaintext highlighter-rouge">late</code> modifier uses an <code class="language-plaintext highlighter-rouge">await</code> expression in the initializer.</p>

<h4 id="example-26">Example</h4>

<p>The following code produces this diagnostic because an <code class="language-plaintext highlighter-rouge">await</code> expression
is used in the initializer for <code class="language-plaintext highlighter-rouge">v</code>, a local variable that is marked <code class="language-plaintext highlighter-rouge">late</code>:</p>

<pre class="prettyprint lang-dart"><code>Future&lt;int&gt; f() async {
  late var v = <span class="highlight">await</span> 42;
  return v;
}</code></pre>

<h4 id="common-fixes-29">Common fixes</h4>

<p>If the initializer can be rewritten to not use <code class="language-plaintext highlighter-rouge">await</code>, then rewrite it:</p>

<pre class="prettyprint lang-dart"><code>Future&lt;int&gt; f() async {
  late var v = 42;
  return v;
}</code></pre>

<p>If the initializer can’t be rewritten, then remove the <code class="language-plaintext highlighter-rouge">late</code> modifier:</p>

<pre class="prettyprint lang-dart"><code>Future&lt;int&gt; f() async {
  var v = await 42;
  return v;
}</code></pre>

<h3 id="body_might_complete_normally">
<a class="anchor" href="#body_might_complete_normally" aria-hidden="true"><span class="octicon octicon-link"></span></a>body_might_complete_normally</h3>

<p><em>The body might complete normally, causing ‘null’ to be returned, but the return
type, ‘{0}’, is a potentially non-nullable type.</em></p>

<h4 id="description-30">Description</h4>

<p>The analyzer produces this diagnostic when a method or function has a
return type that’s <a href="#potentially-non-nullable">potentially non-nullable</a> but would implicitly return
<code class="language-plaintext highlighter-rouge">null</code> if control reached the end of the function.</p>

<h4 id="examples-3">Examples</h4>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">m</code> has an
implicit return of <code class="language-plaintext highlighter-rouge">null</code> inserted at the end of the method, but the method
is declared to not return <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int <span class="highlight">m</span>(int t) {
    print(t);
  }
}</code></pre>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">m</code> has an
implicit return of <code class="language-plaintext highlighter-rouge">null</code> inserted at the end of the method, but because
the class <code class="language-plaintext highlighter-rouge">C</code> can be instantiated with a non-nullable type argument, the
method is effectively declared to not return <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  T <span class="highlight">m</span>(T t) {
    print(t);
  }
}</code></pre>

<h4 id="common-fixes-30">Common fixes</h4>

<p>If there’s a reasonable value that can be returned, then add a <code class="language-plaintext highlighter-rouge">return</code>
statement at the end of the method:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  T m(T t) {
    print(t);
    return t;
  }
}</code></pre>

<p>If the method won’t reach the implicit return, then add a <code class="language-plaintext highlighter-rouge">throw</code> at the
end of the method:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  T m(T t) {
    print(t);
    throw '';
  }
}</code></pre>

<p>If the method intentionally returns <code class="language-plaintext highlighter-rouge">null</code> at the end, then add an
explicit return of <code class="language-plaintext highlighter-rouge">null</code> at the end of the method and change the
return type so that it’s valid to return <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  T? m(T t) {
    print(t);
    return null;
  }
}</code></pre>

<h3 id="body_might_complete_normally_nullable">
<a class="anchor" href="#body_might_complete_normally_nullable" aria-hidden="true"><span class="octicon octicon-link"></span></a>body_might_complete_normally_nullable</h3>

<p><em>This function has a nullable return type of ‘{0}’, but ends without returning a
value.</em></p>

<h4 id="description-31">Description</h4>

<p>The analyzer produces this diagnostic when a method or function can
implicitly return <code class="language-plaintext highlighter-rouge">null</code> by falling off the end. While this is valid Dart
code, it’s better for the return of <code class="language-plaintext highlighter-rouge">null</code> to be explicit.</p>

<h4 id="example-27">Example</h4>

<p>The following code produces this diagnostic because the function <code class="language-plaintext highlighter-rouge">f</code>
implicitly returns <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>String? <span class="highlight">f</span>() {}</code></pre>

<h4 id="common-fixes-31">Common fixes</h4>

<p>If the return of <code class="language-plaintext highlighter-rouge">null</code> is intentional, then make it explicit:</p>

<pre class="prettyprint lang-dart"><code>String? f() {
  return null;
}</code></pre>

<p>If the function should return a non-null value along that path, then add
the missing return statement:</p>

<pre class="prettyprint lang-dart"><code>String? f() {
  return '';
}</code></pre>

<h3 id="break_label_on_switch_member">
<a class="anchor" href="#break_label_on_switch_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>break_label_on_switch_member</h3>

<p><em>A break label resolves to the ‘case’ or ‘default’ statement.</em></p>

<h4 id="description-32">Description</h4>

<p>The analyzer produces this diagnostic when a break in a case clause inside
a switch statement has a label that is associated with another case clause.</p>

<h4 id="example-28">Example</h4>

<p>The following code produces this diagnostic because the label <code class="language-plaintext highlighter-rouge">l</code> is
associated with the case clause for <code class="language-plaintext highlighter-rouge">0</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(int i) {
  switch (i) {
    l: case 0:
      break;
    case 1:
      break <span class="highlight">l</span>;
  }
}</code></pre>

<h4 id="common-fixes-32">Common fixes</h4>

<p>If the intent is to transfer control to the statement after the switch,
then remove the label from the break statement:</p>

<pre class="prettyprint lang-dart"><code>void f(int i) {
  switch (i) {
    case 0:
      break;
    case 1:
      break;
  }
}</code></pre>

<p>If the intent is to transfer control to a different case block, then use
<code class="language-plaintext highlighter-rouge">continue</code> rather than <code class="language-plaintext highlighter-rouge">break</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(int i) {
  switch (i) {
    l: case 0:
      break;
    case 1:
      continue l;
  }
}</code></pre>

<h3 id="built_in_identifier_as_type">
<a class="anchor" href="#built_in_identifier_as_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>built_in_identifier_as_type</h3>

<p><em>The built-in identifier ‘{0}’ can’t be used as a type.</em></p>

<h4 id="description-33">Description</h4>

<p>The analyzer produces this diagnostic when a built-in identifier is used
where a type name is expected.</p>

<h4 id="example-29">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">import</code> can’t be used
as a type because it’s a built-in identifier:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">import</span>&lt;int&gt; x;</code></pre>

<h4 id="common-fixes-33">Common fixes</h4>

<p>Replace the built-in identifier with the name of a valid type:</p>

<pre class="prettyprint lang-dart"><code>List&lt;int&gt; x;</code></pre>

<h3 id="built_in_identifier_in_declaration">
<a class="anchor" href="#built_in_identifier_in_declaration" aria-hidden="true"><span class="octicon octicon-link"></span></a>built_in_identifier_in_declaration</h3>

<p><em>The built-in identifier ‘{0}’ can’t be used as a prefix name.</em></p>

<p><em>The built-in identifier ‘{0}’ can’t be used as a type name.</em></p>

<p><em>The built-in identifier ‘{0}’ can’t be used as a type parameter name.</em></p>

<p><em>The built-in identifier ‘{0}’ can’t be used as a typedef name.</em></p>

<p><em>The built-in identifier ‘{0}’ can’t be used as an extension name.</em></p>

<h4 id="description-34">Description</h4>

<p>The analyzer produces this diagnostic when the name used in the declaration
of a class, extension, mixin, typedef, type parameter, or import prefix is
a built-in identifier. Built-in identifiers can’t be used to name any of
these kinds of declarations.</p>

<h4 id="example-30">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">mixin</code> is a built-in
identifier:</p>

<pre class="prettyprint lang-dart"><code>extension <span class="highlight">mixin</span> on int {}</code></pre>

<h4 id="common-fixes-34">Common fixes</h4>

<p>Choose a different name for the declaration.</p>

<h3 id="case_block_not_terminated">
<a class="anchor" href="#case_block_not_terminated" aria-hidden="true"><span class="octicon octicon-link"></span></a>case_block_not_terminated</h3>

<p><em>The last statement of the ‘case’ should be ‘break’, ‘continue’, ‘rethrow’,
‘return’, or ‘throw’.</em></p>

<h4 id="description-35">Description</h4>

<p>The analyzer produces this diagnostic when the last statement in a <code class="language-plaintext highlighter-rouge">case</code>
block isn’t one of the required terminators: <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code>,
<code class="language-plaintext highlighter-rouge">rethrow</code>, <code class="language-plaintext highlighter-rouge">return</code>, or <code class="language-plaintext highlighter-rouge">throw</code>.</p>

<h4 id="example-31">Example</h4>

<p>The following code produces this diagnostic because the <code class="language-plaintext highlighter-rouge">case</code> block ends
with an assignment:</p>

<pre class="prettyprint lang-dart"><code>void f(int x) {
  switch (x) {
    <span class="highlight">case</span> 0:
      x += 2;
    default:
      x += 1;
  }
}</code></pre>

<h4 id="common-fixes-35">Common fixes</h4>

<p>Add one of the required terminators:</p>

<pre class="prettyprint lang-dart"><code>void f(int x) {
  switch (x) {
    case 0:
      x += 2;
      break;
    default:
      x += 1;
  }
}</code></pre>

<h3 id="case_expression_type_implements_equals">
<a class="anchor" href="#case_expression_type_implements_equals" aria-hidden="true"><span class="octicon octicon-link"></span></a>case_expression_type_implements_equals</h3>

<p><em>The switch case expression type ‘{0}’ can’t override the ‘==’ operator.</em></p>

<h4 id="description-36">Description</h4>

<p>The analyzer produces this diagnostic when the type of the expression
following the keyword <code class="language-plaintext highlighter-rouge">case</code> has an implementation of the <code class="language-plaintext highlighter-rouge">==</code> operator
other than the one in <code class="language-plaintext highlighter-rouge">Object</code>.</p>

<h4 id="example-32">Example</h4>

<p>The following code produces this diagnostic because the expression
following the keyword <code class="language-plaintext highlighter-rouge">case</code> (<code class="language-plaintext highlighter-rouge">C(0)</code>) has the type <code class="language-plaintext highlighter-rouge">C</code>, and the class <code class="language-plaintext highlighter-rouge">C</code>
overrides the <code class="language-plaintext highlighter-rouge">==</code> operator:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int value;

  const C(this.value);

  bool operator ==(Object other) {
    return false;
  }
}

void f(C c) {
  switch (c) {
    case <span class="highlight">C(0)</span>:
      break;
  }
}</code></pre>

<h4 id="common-fixes-36">Common fixes</h4>

<p>If there isn’t a strong reason not to do so, then rewrite the code to use
an if-else structure:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int value;

  const C(this.value);

  bool operator ==(Object other) {
    return false;
  }
}

void f(C c) {
  if (c == C(0)) {
    // ...
  }
}</code></pre>

<p>If you can’t rewrite the switch statement and the implementation of <code class="language-plaintext highlighter-rouge">==</code>
isn’t necessary, then remove it:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int value;

  const C(this.value);
}

void f(C c) {
  switch (c) {
    case C(0):
      break;
  }
}</code></pre>

<p>If you can’t rewrite the switch statement and you can’t remove the
definition of <code class="language-plaintext highlighter-rouge">==</code>, then find some other value that can be used to control
the switch:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int value;

  const C(this.value);

  bool operator ==(Object other) {
    return false;
  }
}

void f(C c) {
  switch (c.value) {
    case 0:
      break;
  }
}</code></pre>

<h3 id="case_expression_type_is_not_switch_expression_subtype">
<a class="anchor" href="#case_expression_type_is_not_switch_expression_subtype" aria-hidden="true"><span class="octicon octicon-link"></span></a>case_expression_type_is_not_switch_expression_subtype</h3>

<p><em>The switch case expression type ‘{0}’ must be a subtype of the switch
expression type ‘{1}’.</em></p>

<h4 id="description-37">Description</h4>

<p>The analyzer produces this diagnostic when the expression following <code class="language-plaintext highlighter-rouge">case</code>
in a <code class="language-plaintext highlighter-rouge">switch</code> statement has a static type that isn’t a subtype of the
static type of the expression following <code class="language-plaintext highlighter-rouge">switch</code>.</p>

<h4 id="example-33">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">1</code> is an <code class="language-plaintext highlighter-rouge">int</code>, which
isn’t a subtype of <code class="language-plaintext highlighter-rouge">String</code> (the type of <code class="language-plaintext highlighter-rouge">s</code>):</p>

<pre class="prettyprint lang-dart"><code>void f(String s) {
  switch (s) {
    case <span class="highlight">1</span>:
      break;
  }
}</code></pre>

<h4 id="common-fixes-37">Common fixes</h4>

<p>If the value of the <code class="language-plaintext highlighter-rouge">case</code> expression is wrong, then change the <code class="language-plaintext highlighter-rouge">case</code>
expression so that it has the required type:</p>

<pre class="prettyprint lang-dart"><code>void f(String s) {
  switch (s) {
    case '1':
      break;
  }
}</code></pre>

<p>If the value of the <code class="language-plaintext highlighter-rouge">case</code> expression is correct, then change the <code class="language-plaintext highlighter-rouge">switch</code>
expression to have the required type:</p>

<pre class="prettyprint lang-dart"><code>void f(int s) {
  switch (s) {
    case 1:
      break;
  }
}</code></pre>

<h3 id="cast_to_non_type">
<a class="anchor" href="#cast_to_non_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>cast_to_non_type</h3>

<p><em>The name ‘{0}’ isn’t a type, so it can’t be used in an ‘as’ expression.</em></p>

<h4 id="description-38">Description</h4>

<p>The analyzer produces this diagnostic when the name following the <code class="language-plaintext highlighter-rouge">as</code> in a
cast expression is defined to be something other than a type.</p>

<h4 id="example-34">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> is a variable, not
a type:</p>

<pre class="prettyprint lang-dart"><code>num x = 0;
int y = x as <span class="highlight">x</span>;</code></pre>

<h4 id="common-fixes-38">Common fixes</h4>

<p>Replace the name with the name of a type:</p>

<pre class="prettyprint lang-dart"><code>num x = 0;
int y = x as int;</code></pre>

<h3 id="collection_element_from_deferred_library">
<a class="anchor" href="#collection_element_from_deferred_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>collection_element_from_deferred_library</h3>

<p><em>Constant values from a deferred library can’t be used as keys in a ‘const’ map
literal.</em></p>

<p><em>Constant values from a deferred library can’t be used as values in a ‘const’
list literal.</em></p>

<p><em>Constant values from a deferred library can’t be used as values in a ‘const’
map literal.</em></p>

<p><em>Constant values from a deferred library can’t be used as values in a ‘const’
set literal.</em></p>

<h4 id="description-39">Description</h4>

<p>The analyzer produces this diagnostic when a collection literal that is
either explicitly (because it’s prefixed by the <code class="language-plaintext highlighter-rouge">const</code> keyword) or
implicitly (because it appears in a <a href="#constant-context">constant context</a>) a constant
contains a value that is declared in a library that is imported using a
deferred import. Constants are evaluated at compile time, and values from
deferred libraries aren’t available at compile time.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-35">Example</h4>

<p>Given a file (<code class="language-plaintext highlighter-rouge">a.dart</code>) that defines the constant <code class="language-plaintext highlighter-rouge">zero</code>:</p>

<pre class="prettyprint lang-dart"><code>const zero = 0;</code></pre>

<p>The following code produces this diagnostic because the constant list
literal contains <code class="language-plaintext highlighter-rouge">a.zero</code>, which is imported using a <code class="language-plaintext highlighter-rouge">deferred</code> import:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' deferred as a;

var l = const [<span class="highlight">a.zero</span>];</code></pre>

<h4 id="common-fixes-39">Common fixes</h4>

<p>If the collection literal isn’t required to be constant, then remove the
<code class="language-plaintext highlighter-rouge">const</code> keyword:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' deferred as a;

var l = [a.zero];</code></pre>

<p>If the collection is required to be constant and the imported constant must
be referenced, then remove the keyword <code class="language-plaintext highlighter-rouge">deferred</code> from the import:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' as a;

var l = const [a.zero];</code></pre>

<p>If you don’t need to reference the constant, then replace it with a
suitable value:</p>

<pre class="prettyprint lang-dart"><code>var l = const [0];</code></pre>

<h3 id="compound_implements_finalizable">
<a class="anchor" href="#compound_implements_finalizable" aria-hidden="true"><span class="octicon octicon-link"></span></a>compound_implements_finalizable</h3>

<p><em>The class ‘{0}’ can’t implement Finalizable.</em></p>

<h4 id="description-40">Description</h4>

<p>The analyzer produces this diagnostic when a subclass of either <code class="language-plaintext highlighter-rouge">Struct</code>
or <code class="language-plaintext highlighter-rouge">Union</code> implements <code class="language-plaintext highlighter-rouge">Finalizable</code>.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-36">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">S</code>
implements <code class="language-plaintext highlighter-rouge">Finalizable</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class <span class="highlight">S</span> extends Struct implements Finalizable {
  external Pointer notEmpty;
}</code></pre>

<h4 id="common-fixes-40">Common fixes</h4>

<p>Try removing the implements clause from the class:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class S extends Struct {
  external Pointer notEmpty;
}</code></pre>

<h3 id="concrete_class_has_enum_superinterface">
<a class="anchor" href="#concrete_class_has_enum_superinterface" aria-hidden="true"><span class="octicon octicon-link"></span></a>concrete_class_has_enum_superinterface</h3>

<p><em>Concrete classes can’t have ‘Enum’ as a superinterface.</em></p>

<h4 id="description-41">Description</h4>

<p>The analyzer produces this diagnostic when a concrete class indirectly has
the class <code class="language-plaintext highlighter-rouge">Enum</code> as a superinterface.</p>

<h4 id="example-37">Example</h4>

<p>The following code produces this diagnostic because the concrete class <code class="language-plaintext highlighter-rouge">B</code>
has <code class="language-plaintext highlighter-rouge">Enum</code> as a superinterface as a result of implementing <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>abstract class A implements Enum {}

class <span class="highlight">B</span> implements A {}</code></pre>

<h4 id="common-fixes-41">Common fixes</h4>

<p>If the implemented class isn’t the class you intend to implement, then
change it:</p>

<pre class="prettyprint lang-dart"><code>abstract class A implements Enum {}

class B implements C {}

class C {}</code></pre>

<p>If the implemented class can be changed to not implement <code class="language-plaintext highlighter-rouge">Enum</code>, then do
so:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {}

class B implements A {}</code></pre>

<p>If the implemented class can’t be changed to not implement <code class="language-plaintext highlighter-rouge">Enum</code>, then
remove it from the <code class="language-plaintext highlighter-rouge">implements</code> clause:</p>

<pre class="prettyprint lang-dart"><code>abstract class A implements Enum {}

class B {}</code></pre>

<h3 id="concrete_class_with_abstract_member">
<a class="anchor" href="#concrete_class_with_abstract_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>concrete_class_with_abstract_member</h3>

<p><em>‘{0}’ must have a method body because ‘{1}’ isn’t abstract.</em></p>

<h4 id="description-42">Description</h4>

<p>The analyzer produces this diagnostic when a member of a concrete class is
found that doesn’t have a concrete implementation. Concrete classes aren’t
allowed to contain abstract members.</p>

<h4 id="example-38">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">m</code> is an abstract
method but <code class="language-plaintext highlighter-rouge">C</code> isn’t an abstract class:</p>

<pre class="prettyprint lang-dart"><code>class C {
  <span class="highlight">void m();</span>
}</code></pre>

<h4 id="common-fixes-42">Common fixes</h4>

<p>If it’s valid to create instances of the class, provide an implementation
for the member:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void m() {}
}</code></pre>

<p>If it isn’t valid to create instances of the class, mark the class as being
abstract:</p>

<pre class="prettyprint lang-dart"><code>abstract class C {
  void m();
}</code></pre>

<h3 id="conflicting_constructor_and_static_member">
<a class="anchor" href="#conflicting_constructor_and_static_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>conflicting_constructor_and_static_member</h3>

<p><em>‘{0}’ can’t be used to name both a constructor and a static field in this
class.</em></p>

<p><em>‘{0}’ can’t be used to name both a constructor and a static getter in this
class.</em></p>

<p><em>‘{0}’ can’t be used to name both a constructor and a static method in this
class.</em></p>

<p><em>‘{0}’ can’t be used to name both a constructor and a static setter in this
class.</em></p>

<h4 id="description-43">Description</h4>

<p>The analyzer produces this diagnostic when a named constructor and either a
static method or static field have the same name. Both are accessed using
the name of the class, so having the same name makes the reference
ambiguous.</p>

<h4 id="examples-4">Examples</h4>

<p>The following code produces this diagnostic because the static field <code class="language-plaintext highlighter-rouge">foo</code>
and the named constructor <code class="language-plaintext highlighter-rouge">foo</code> have the same name:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.<span class="highlight">foo</span>();
  static int foo = 0;
}</code></pre>

<p>The following code produces this diagnostic because the static method <code class="language-plaintext highlighter-rouge">foo</code>
and the named constructor <code class="language-plaintext highlighter-rouge">foo</code> have the same name:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.<span class="highlight">foo</span>();
  static void foo() {}
}</code></pre>

<h4 id="common-fixes-43">Common fixes</h4>

<p>Rename either the member or the constructor.</p>

<h3 id="conflicting_generic_interfaces">
<a class="anchor" href="#conflicting_generic_interfaces" aria-hidden="true"><span class="octicon octicon-link"></span></a>conflicting_generic_interfaces</h3>

<p><em>The class ‘{0}’ can’t implement both ‘{1}’ and ‘{2}’ because the type arguments
are different.</em></p>

<h4 id="description-44">Description</h4>

<p>The analyzer produces this diagnostic when a class attempts to implement a
generic interface multiple times, and the values of the type arguments
aren’t the same.</p>

<h4 id="example-39">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">C</code> is defined to
implement both <code class="language-plaintext highlighter-rouge">I&lt;int&gt;</code> (because it extends <code class="language-plaintext highlighter-rouge">A</code>) and <code class="language-plaintext highlighter-rouge">I&lt;String&gt;</code> (because
it implements<code class="language-plaintext highlighter-rouge">B</code>), but <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">String</code> aren’t the same type:</p>

<pre class="prettyprint lang-dart"><code>class I&lt;T&gt; {}
class A implements I&lt;int&gt; {}
class B implements I&lt;String&gt; {}
class <span class="highlight">C</span> extends A implements B {}</code></pre>

<h4 id="common-fixes-44">Common fixes</h4>

<p>Rework the type hierarchy to avoid this situation. For example, you might
make one or both of the inherited types generic so that <code class="language-plaintext highlighter-rouge">C</code> can specify the
same type for both type arguments:</p>

<pre class="prettyprint lang-dart"><code>class I&lt;T&gt; {}
class A&lt;S&gt; implements I&lt;S&gt; {}
class B implements I&lt;String&gt; {}
class C extends A&lt;String&gt; implements B {}</code></pre>

<h3 id="conflicting_type_variable_and_container">
<a class="anchor" href="#conflicting_type_variable_and_container" aria-hidden="true"><span class="octicon octicon-link"></span></a>conflicting_type_variable_and_container</h3>

<p><em>‘{0}’ can’t be used to name both a type variable and the class in which the
type variable is defined.</em></p>

<p><em>‘{0}’ can’t be used to name both a type variable and the enum in which the type
variable is defined.</em></p>

<p><em>‘{0}’ can’t be used to name both a type variable and the extension in which the
type variable is defined.</em></p>

<p><em>‘{0}’ can’t be used to name both a type variable and the mixin in which the
type variable is defined.</em></p>

<h4 id="description-45">Description</h4>

<p>The analyzer produces this diagnostic when a class, mixin, or extension
declaration declares a type parameter with the same name as the class,
mixin, or extension that declares it.</p>

<h4 id="example-40">Example</h4>

<p>The following code produces this diagnostic because the type parameter <code class="language-plaintext highlighter-rouge">C</code>
has the same name as the class <code class="language-plaintext highlighter-rouge">C</code> of which it’s a part:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;<span class="highlight">C</span>&gt; {}</code></pre>

<h4 id="common-fixes-45">Common fixes</h4>

<p>Rename either the type parameter, or the class, mixin, or extension:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {}</code></pre>

<h3 id="conflicting_type_variable_and_member">
<a class="anchor" href="#conflicting_type_variable_and_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>conflicting_type_variable_and_member</h3>

<p><em>‘{0}’ can’t be used to name both a type variable and a member in this class.</em></p>

<p><em>‘{0}’ can’t be used to name both a type variable and a member in this enum.</em></p>

<p><em>‘{0}’ can’t be used to name both a type variable and a member in this
extension.</em></p>

<p><em>‘{0}’ can’t be used to name both a type variable and a member in this mixin.</em></p>

<h4 id="description-46">Description</h4>

<p>The analyzer produces this diagnostic when a class, mixin, or extension
declaration declares a type parameter with the same name as one of the
members of the class, mixin, or extension that declares it.</p>

<h4 id="example-41">Example</h4>

<p>The following code produces this diagnostic because the type parameter <code class="language-plaintext highlighter-rouge">T</code>
has the same name as the field <code class="language-plaintext highlighter-rouge">T</code>:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;<span class="highlight">T</span>&gt; {
  int T = 0;
}</code></pre>

<h4 id="common-fixes-46">Common fixes</h4>

<p>Rename either the type parameter or the member with which it conflicts:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  int total = 0;
}</code></pre>

<h3 id="const_constructor_param_type_mismatch">
<a class="anchor" href="#const_constructor_param_type_mismatch" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_constructor_param_type_mismatch</h3>

<p><em>A value of type ‘{0}’ can’t be assigned to a parameter of type ‘{1}’ in a const
constructor.</em></p>

<h4 id="description-47">Description</h4>

<p>The analyzer produces this diagnostic when the runtime type of a constant
value can’t be assigned to the static type of a constant constructor’s
parameter.</p>

<h4 id="example-42">Example</h4>

<p>The following code produces this diagnostic because the runtime type of <code class="language-plaintext highlighter-rouge">i</code>
is <code class="language-plaintext highlighter-rouge">int</code>, which can’t be assigned to the static type of <code class="language-plaintext highlighter-rouge">s</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String s;

  const C(this.s);
}

const dynamic i = 0;

void f() {
  const C(<span class="highlight">i</span>);
}</code></pre>

<h4 id="common-fixes-47">Common fixes</h4>

<p>Pass a value of the correct type to the constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String s;

  const C(this.s);
}

const dynamic i = 0;

void f() {
  const C('$i');
}</code></pre>

<h3 id="const_constructor_with_field_initialized_by_non_const">
<a class="anchor" href="#const_constructor_with_field_initialized_by_non_const" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_constructor_with_field_initialized_by_non_const</h3>

<p><em>Can’t define the ‘const’ constructor because the field ‘{0}’ is initialized
with a non-constant value.</em></p>

<h4 id="description-48">Description</h4>

<p>The analyzer produces this diagnostic when a constructor has the keyword
<code class="language-plaintext highlighter-rouge">const</code>, but a field in the class is initialized to a non-constant value.</p>

<h4 id="example-43">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">s</code> is
initialized to a non-constant value:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String s = 3.toString();
  <span class="highlight">const</span> C();
}</code></pre>

<h4 id="common-fixes-48">Common fixes</h4>

<p>If the field can be initialized to a constant value, then change the
initializer to a constant expression:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String s = '3';
  const C();
}</code></pre>

<p>If the field can’t be initialized to a constant value, then remove the
keyword <code class="language-plaintext highlighter-rouge">const</code> from the constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String s = 3.toString();
  C();
}</code></pre>

<h3 id="const_constructor_with_non_const_super">
<a class="anchor" href="#const_constructor_with_non_const_super" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_constructor_with_non_const_super</h3>

<p><em>A constant constructor can’t call a non-constant super constructor of ‘{0}’.</em></p>

<h4 id="description-49">Description</h4>

<p>The analyzer produces this diagnostic when a constructor that is marked as
<code class="language-plaintext highlighter-rouge">const</code> invokes a constructor from its superclass that isn’t marked as
<code class="language-plaintext highlighter-rouge">const</code>.</p>

<h4 id="example-44">Example</h4>

<p>The following code produces this diagnostic because the <code class="language-plaintext highlighter-rouge">const</code> constructor
in <code class="language-plaintext highlighter-rouge">B</code> invokes the constructor <code class="language-plaintext highlighter-rouge">nonConst</code> from the class <code class="language-plaintext highlighter-rouge">A</code>, and the
superclass constructor isn’t a <code class="language-plaintext highlighter-rouge">const</code> constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  const A();
  A.nonConst();
}

class B extends A {
  const B() : <span class="highlight">super.nonConst()</span>;
}</code></pre>

<h4 id="common-fixes-49">Common fixes</h4>

<p>If it isn’t essential to invoke the superclass constructor that is
currently being invoked, then invoke a constant constructor from the
superclass:</p>

<pre class="prettyprint lang-dart"><code>class A {
  const A();
  A.nonConst();
}

class B extends A {
  const B() : super();
}</code></pre>

<p>If it’s essential that the current constructor be invoked and if you can
modify it, then add <code class="language-plaintext highlighter-rouge">const</code> to the constructor in the superclass:</p>

<pre class="prettyprint lang-dart"><code>class A {
  const A();
  const A.nonConst();
}

class B extends A {
  const B() : super.nonConst();
}</code></pre>

<p>If it’s essential that the current constructor be invoked and you can’t
modify it, then remove <code class="language-plaintext highlighter-rouge">const</code> from the constructor in the subclass:</p>

<pre class="prettyprint lang-dart"><code>class A {
  const A();
  A.nonConst();
}

class B extends A {
  B() : super.nonConst();
}</code></pre>

<h3 id="const_constructor_with_non_final_field">
<a class="anchor" href="#const_constructor_with_non_final_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_constructor_with_non_final_field</h3>

<p><em>Can’t define a const constructor for a class with non-final fields.</em></p>

<h4 id="description-50">Description</h4>

<p>The analyzer produces this diagnostic when a constructor is marked as a
const constructor, but the constructor is defined in a class that has at
least one non-final instance field (either directly or by inheritance).</p>

<h4 id="example-45">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">x</code> isn’t
final:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  const <span class="highlight">C</span>(this.x);
}</code></pre>

<h4 id="common-fixes-50">Common fixes</h4>

<p>If it’s possible to mark all of the fields as final, then do so:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int x;

  const C(this.x);
}</code></pre>

<p>If it isn’t possible to mark all of the fields as final, then remove the
keyword <code class="language-plaintext highlighter-rouge">const</code> from the constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  C(this.x);
}</code></pre>

<h3 id="const_deferred_class">
<a class="anchor" href="#const_deferred_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_deferred_class</h3>

<p><em>Deferred classes can’t be created with ‘const’.</em></p>

<h4 id="description-51">Description</h4>

<p>The analyzer produces this diagnostic when a class from a library that is
imported using a deferred import is used to create a <code class="language-plaintext highlighter-rouge">const</code> object.
Constants are evaluated at compile time, and classes from deferred
libraries aren’t available at compile time.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-46">Example</h4>

<p>The following code produces this diagnostic because it attempts to create a
<code class="language-plaintext highlighter-rouge">const</code> instance of a class from a deferred library:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:convert' deferred as convert;

const json2 = <span class="highlight">convert.JsonCodec()</span>;</code></pre>

<h4 id="common-fixes-51">Common fixes</h4>

<p>If the object isn’t required to be a constant, then change the code so that
a non-constant instance is created:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:convert' deferred as convert;

final json2 = convert.JsonCodec();</code></pre>

<p>If the object must be a constant, then remove <code class="language-plaintext highlighter-rouge">deferred</code> from the import
directive:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:convert' as convert;

const json2 = convert.JsonCodec();</code></pre>

<h3 id="const_initialized_with_non_constant_value">
<a class="anchor" href="#const_initialized_with_non_constant_value" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_initialized_with_non_constant_value</h3>

<p><em>Const variables must be initialized with a constant value.</em></p>

<h4 id="description-52">Description</h4>

<p>The analyzer produces this diagnostic when a value that isn’t statically
known to be a constant is assigned to a variable that’s declared to be a
<code class="language-plaintext highlighter-rouge">const</code> variable.</p>

<h4 id="example-47">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> isn’t declared to
be <code class="language-plaintext highlighter-rouge">const</code>:</p>

<pre class="prettyprint lang-dart"><code>var x = 0;
const y = <span class="highlight">x</span>;</code></pre>

<h4 id="common-fixes-52">Common fixes</h4>

<p>If the value being assigned can be declared to be <code class="language-plaintext highlighter-rouge">const</code>, then change the
declaration:</p>

<pre class="prettyprint lang-dart"><code>const x = 0;
const y = x;</code></pre>

<p>If the value can’t be declared to be <code class="language-plaintext highlighter-rouge">const</code>, then remove the <code class="language-plaintext highlighter-rouge">const</code>
modifier from the variable, possibly using <code class="language-plaintext highlighter-rouge">final</code> in its place:</p>

<pre class="prettyprint lang-dart"><code>var x = 0;
final y = x;</code></pre>

<h3 id="const_initialized_with_non_constant_value_from_deferred_library">
<a class="anchor" href="#const_initialized_with_non_constant_value_from_deferred_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_initialized_with_non_constant_value_from_deferred_library</h3>

<p><em>Constant values from a deferred library can’t be used to initialize a ‘const’
variable.</em></p>

<h4 id="description-53">Description</h4>

<p>The analyzer produces this diagnostic when a <code class="language-plaintext highlighter-rouge">const</code> variable is
initialized using a <code class="language-plaintext highlighter-rouge">const</code> variable from a library that is imported using
a deferred import. Constants are evaluated at compile time, and values from
deferred libraries aren’t available at compile time.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-48">Example</h4>

<p>The following code produces this diagnostic because the variable <code class="language-plaintext highlighter-rouge">pi</code> is
being initialized using the constant <code class="language-plaintext highlighter-rouge">math.pi</code> from the library
<code class="language-plaintext highlighter-rouge">dart:math</code>, and <code class="language-plaintext highlighter-rouge">dart:math</code> is imported as a deferred library:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' deferred as math;

const pi = <span class="highlight">math.pi</span>;</code></pre>

<h4 id="common-fixes-53">Common fixes</h4>

<p>If you need to reference the value of the constant from the imported
library, then remove the keyword <code class="language-plaintext highlighter-rouge">deferred</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' as math;

const pi = math.pi;</code></pre>

<p>If you don’t need to reference the imported constant, then remove the
reference:</p>

<pre class="prettyprint lang-dart"><code>const pi = 3.14;</code></pre>

<h3 id="const_instance_field">
<a class="anchor" href="#const_instance_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_instance_field</h3>

<p><em>Only static fields can be declared as const.</em></p>

<h4 id="description-54">Description</h4>

<p>The analyzer produces this diagnostic when an instance field is marked as
being const.</p>

<h4 id="example-49">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is an instance
field:</p>

<pre class="prettyprint lang-dart"><code>class C {
  <span class="highlight">const</span> int f = 3;
}</code></pre>

<h4 id="common-fixes-54">Common fixes</h4>

<p>If the field needs to be an instance field, then remove the keyword
<code class="language-plaintext highlighter-rouge">const</code>, or replace it with <code class="language-plaintext highlighter-rouge">final</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int f = 3;
}</code></pre>

<p>If the field really should be a const field, then make it a static field:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static const int f = 3;
}</code></pre>

<h3 id="const_map_key_expression_type_implements_equals">
<a class="anchor" href="#const_map_key_expression_type_implements_equals" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_map_key_expression_type_implements_equals</h3>

<p><em>The type of a key in a constant map can’t override the ‘==’ operator, but the
class ‘{0}’ does.</em></p>

<h4 id="description-55">Description</h4>

<p>The analyzer produces this diagnostic when the class of object used as a
key in a constant map literal implements the <code class="language-plaintext highlighter-rouge">==</code> operator. The
implementation of constant maps uses the <code class="language-plaintext highlighter-rouge">==</code> operator, so any
implementation other than the one inherited from <code class="language-plaintext highlighter-rouge">Object</code> requires
executing arbitrary code at compile time, which isn’t supported.</p>

<h4 id="example-50">Example</h4>

<p>The following code produces this diagnostic because the constant map
contains a key whose type is <code class="language-plaintext highlighter-rouge">C</code>, and the class <code class="language-plaintext highlighter-rouge">C</code> overrides the
implementation of <code class="language-plaintext highlighter-rouge">==</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  const C();

  bool operator ==(Object other) =&gt; true;
}

const map = {<span class="highlight">C()</span> : 0};</code></pre>

<h4 id="common-fixes-55">Common fixes</h4>

<p>If you can remove the implementation of <code class="language-plaintext highlighter-rouge">==</code> from the class, then do so:</p>

<pre class="prettyprint lang-dart"><code>class C {
  const C();
}

const map = {C() : 0};</code></pre>

<p>If you can’t remove the implementation of <code class="language-plaintext highlighter-rouge">==</code> from the class, then make
the map be non-constant:</p>

<pre class="prettyprint lang-dart"><code>class C {
  const C();

  bool operator ==(Object other) =&gt; true;
}

final map = {C() : 0};</code></pre>

<h3 id="const_not_initialized">
<a class="anchor" href="#const_not_initialized" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_not_initialized</h3>

<p><em>The constant ‘{0}’ must be initialized.</em></p>

<h4 id="description-56">Description</h4>

<p>The analyzer produces this diagnostic when a variable that is declared to
be a constant doesn’t have an initializer.</p>

<h4 id="example-51">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">c</code> isn’t initialized:</p>

<pre class="prettyprint lang-dart"><code>const <span class="highlight">c</span>;</code></pre>

<h4 id="common-fixes-56">Common fixes</h4>

<p>Add an initializer:</p>

<pre class="prettyprint lang-dart"><code>const c = 'c';</code></pre>

<h3 id="const_set_element_type_implements_equals">
<a class="anchor" href="#const_set_element_type_implements_equals" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_set_element_type_implements_equals</h3>

<p><em>The type of an element in a constant set can’t override the ‘==’ operator, but
the type ‘{0}’ does.</em></p>

<h4 id="description-57">Description</h4>

<p>The analyzer produces this diagnostic when the class of object used as an
element in a constant set literal implements the <code class="language-plaintext highlighter-rouge">==</code> operator. The
implementation of constant sets uses the <code class="language-plaintext highlighter-rouge">==</code> operator, so any
implementation other than the one inherited from <code class="language-plaintext highlighter-rouge">Object</code> requires
executing arbitrary code at compile time, which isn’t supported.</p>

<h4 id="example-52">Example</h4>

<p>The following code produces this diagnostic because the constant set
contains an element whose type is <code class="language-plaintext highlighter-rouge">C</code>, and the class <code class="language-plaintext highlighter-rouge">C</code> overrides the
implementation of <code class="language-plaintext highlighter-rouge">==</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  const C();

  bool operator ==(Object other) =&gt; true;
}

const set = {<span class="highlight">C()</span>};</code></pre>

<h4 id="common-fixes-57">Common fixes</h4>

<p>If you can remove the implementation of <code class="language-plaintext highlighter-rouge">==</code> from the class, then do so:</p>

<pre class="prettyprint lang-dart"><code>class C {
  const C();
}

const set = {C()};</code></pre>

<p>If you can’t remove the implementation of <code class="language-plaintext highlighter-rouge">==</code> from the class, then make
the set be non-constant:</p>

<pre class="prettyprint lang-dart"><code>class C {
  const C();

  bool operator ==(Object other) =&gt; true;
}

final set = {C()};</code></pre>

<h3 id="const_spread_expected_list_or_set">
<a class="anchor" href="#const_spread_expected_list_or_set" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_spread_expected_list_or_set</h3>

<p><em>A list or a set is expected in this spread.</em></p>

<h4 id="description-58">Description</h4>

<p>The analyzer produces this diagnostic when the expression of a spread
operator in a constant list or set evaluates to something other than a list
or a set.</p>

<h4 id="example-53">Example</h4>

<p>The following code produces this diagnostic because the value of <code class="language-plaintext highlighter-rouge">list1</code> is
<code class="language-plaintext highlighter-rouge">null</code>, which is neither a list nor a set:</p>

<pre class="prettyprint lang-dart"><code>const List&lt;int&gt; list1 = null;
const List&lt;int&gt; list2 = [...<span class="highlight">list1</span>];</code></pre>

<h4 id="common-fixes-58">Common fixes</h4>

<p>Change the expression to something that evaluates to either a constant list
or a constant set:</p>

<pre class="prettyprint lang-dart"><code>const List&lt;int&gt; list1 = [];
const List&lt;int&gt; list2 = [...list1];</code></pre>

<h3 id="const_spread_expected_map">
<a class="anchor" href="#const_spread_expected_map" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_spread_expected_map</h3>

<p><em>A map is expected in this spread.</em></p>

<h4 id="description-59">Description</h4>

<p>The analyzer produces this diagnostic when the expression of a spread
operator in a constant map evaluates to something other than a map.</p>

<h4 id="example-54">Example</h4>

<p>The following code produces this diagnostic because the value of <code class="language-plaintext highlighter-rouge">map1</code> is
<code class="language-plaintext highlighter-rouge">null</code>, which isn’t a map:</p>

<pre class="prettyprint lang-dart"><code>const Map&lt;String, int&gt; map1 = null;
const Map&lt;String, int&gt; map2 = {...<span class="highlight">map1</span>};</code></pre>

<h4 id="common-fixes-59">Common fixes</h4>

<p>Change the expression to something that evaluates to a constant map:</p>

<pre class="prettyprint lang-dart"><code>const Map&lt;String, int&gt; map1 = {};
const Map&lt;String, int&gt; map2 = {...map1};</code></pre>

<h3 id="const_with_non_const">
<a class="anchor" href="#const_with_non_const" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_with_non_const</h3>

<p><em>The constructor being called isn’t a const constructor.</em></p>

<h4 id="description-60">Description</h4>

<p>The analyzer produces this diagnostic when the keyword <code class="language-plaintext highlighter-rouge">const</code> is used to
invoke a constructor that isn’t marked with <code class="language-plaintext highlighter-rouge">const</code>.</p>

<h4 id="example-55">Example</h4>

<p>The following code produces this diagnostic because the constructor in <code class="language-plaintext highlighter-rouge">A</code>
isn’t a const constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A();
}

A f() =&gt; <span class="highlight">const</span> A();</code></pre>

<h4 id="common-fixes-60">Common fixes</h4>

<p>If it’s desirable and possible to make the class a constant class (by
making all of the fields of the class, including inherited fields, final),
then add the keyword <code class="language-plaintext highlighter-rouge">const</code> to the constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  const A();
}

A f() =&gt; const A();</code></pre>

<p>Otherwise, remove the keyword <code class="language-plaintext highlighter-rouge">const</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A();
}

A f() =&gt; A();</code></pre>

<h3 id="const_with_non_constant_argument">
<a class="anchor" href="#const_with_non_constant_argument" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_with_non_constant_argument</h3>

<p><em>Arguments of a constant creation must be constant expressions.</em></p>

<h4 id="description-61">Description</h4>

<p>The analyzer produces this diagnostic when a const constructor is invoked
with an argument that isn’t a constant expression.</p>

<h4 id="example-56">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">i</code> isn’t a constant:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int i;
  const C(this.i);
}
C f(int i) =&gt; const C(<span class="highlight">i</span>);</code></pre>

<h4 id="common-fixes-61">Common fixes</h4>

<p>Either make all of the arguments constant expressions, or remove the
<code class="language-plaintext highlighter-rouge">const</code> keyword to use the non-constant form of the constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int i;
  const C(this.i);
}
C f(int i) =&gt; C(i);</code></pre>

<h3 id="const_with_type_parameters">
<a class="anchor" href="#const_with_type_parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>const_with_type_parameters</h3>

<p><em>A constant constructor tearoff can’t use a type parameter as a type argument.</em></p>

<p><em>A constant creation can’t use a type parameter as a type argument.</em></p>

<p><em>A constant function tearoff can’t use a type parameter as a type argument.</em></p>

<h4 id="description-62">Description</h4>

<p>The analyzer produces this diagnostic when a type parameter is used as a
type argument in a <code class="language-plaintext highlighter-rouge">const</code> invocation of a constructor. This isn’t allowed
because the value of the type parameter (the actual type that will be used
at runtime) can’t be known at compile time.</p>

<h4 id="example-57">Example</h4>

<p>The following code produces this diagnostic because the type parameter <code class="language-plaintext highlighter-rouge">T</code>
is being used as a type argument when creating a constant:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  const C();
}

C&lt;T&gt; newC&lt;T&gt;() =&gt; const C&lt;<span class="highlight">T</span>&gt;();</code></pre>

<h4 id="common-fixes-62">Common fixes</h4>

<p>If the type that will be used for the type parameter can be known at
compile time, then remove the use of the type parameter:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  const C();
}

C&lt;int&gt; newC() =&gt; const C&lt;int&gt;();</code></pre>

<p>If the type that will be used for the type parameter can’t be known until
runtime, then remove the keyword <code class="language-plaintext highlighter-rouge">const</code>:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  const C();
}

C&lt;T&gt; newC&lt;T&gt;() =&gt; C&lt;T&gt;();</code></pre>

<h3 id="continue_label_on_switch">
<a class="anchor" href="#continue_label_on_switch" aria-hidden="true"><span class="octicon octicon-link"></span></a>continue_label_on_switch</h3>

<p><em>A <code class="language-plaintext highlighter-rouge">continue</code> label resolves to a <code class="language-plaintext highlighter-rouge">switch</code> statement, but the label must be on a
loop or a switch member.</em></p>

<h4 id="description-63">Description</h4>

<p>The analyzer produces this diagnostic when the label in a <code class="language-plaintext highlighter-rouge">continue</code>
statement resolves to a label on a <code class="language-plaintext highlighter-rouge">switch</code> statement.</p>

<h4 id="example-58">Example</h4>

<p>The following code produces this diagnostic because the label <code class="language-plaintext highlighter-rouge">l</code>, used to
label a <code class="language-plaintext highlighter-rouge">switch</code> statement, is used in the <code class="language-plaintext highlighter-rouge">continue</code> statement:</p>

<pre class="prettyprint lang-dart"><code>void f(int i) {
  l: switch (i) {
    case 0:
      continue <span class="highlight">l</span>;
  }
}</code></pre>

<h4 id="common-fixes-63">Common fixes</h4>

<p>Find a different way to achieve the control flow you need; for example, by
introducing a loop that re-executes the <code class="language-plaintext highlighter-rouge">switch</code> statement.</p>

<h3 id="creation_of_struct_or_union">
<a class="anchor" href="#creation_of_struct_or_union" aria-hidden="true"><span class="octicon octicon-link"></span></a>creation_of_struct_or_union</h3>

<p><em>Subclasses of ‘Struct’ and ‘Union’ are backed by native memory, and can’t be
instantiated by a generative constructor.</em></p>

<h4 id="description-64">Description</h4>

<p>The analyzer produces this diagnostic when a subclass of either <code class="language-plaintext highlighter-rouge">Struct</code>
or <code class="language-plaintext highlighter-rouge">Union</code> is instantiated using a generative constructor.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-59">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code> is being
instantiated using a generative constructor:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Int32()
  external int a;
}

void f() {
  <span class="highlight">C</span>();
}</code></pre>

<h4 id="common-fixes-64">Common fixes</h4>

<p>If you need to allocate the structure described by the class, then use the
<code class="language-plaintext highlighter-rouge">ffi</code> package to do so:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';
import 'package:ffi/ffi.dart';

class C extends Struct {
  @Int32()
  external int a;
}

void f() {
  final pointer = calloc.allocate&lt;C&gt;(4);
  final c = pointer.ref;
  print(c);
  calloc.free(pointer);
}</code></pre>

<h3 id="creation_with_non_type">
<a class="anchor" href="#creation_with_non_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>creation_with_non_type</h3>

<p><em>The name ‘{0}’ isn’t a class.</em></p>

<h4 id="description-65">Description</h4>

<p>The analyzer produces this diagnostic when an instance creation using
either <code class="language-plaintext highlighter-rouge">new</code> or <code class="language-plaintext highlighter-rouge">const</code> specifies a name that isn’t defined as a class.</p>

<h4 id="example-60">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is a function
rather than a class:</p>

<pre class="prettyprint lang-dart"><code>int f() =&gt; 0;

void g() {
  new <span class="highlight">f</span>();
}</code></pre>

<h4 id="common-fixes-65">Common fixes</h4>

<p>If a class should be created, then replace the invalid name with the name
of a valid class:</p>

<pre class="prettyprint lang-dart"><code>int f() =&gt; 0;

void g() {
  new Object();
}</code></pre>

<p>If the name is the name of a function and you want that function to be
invoked, then remove the <code class="language-plaintext highlighter-rouge">new</code> or <code class="language-plaintext highlighter-rouge">const</code> keyword:</p>

<pre class="prettyprint lang-dart"><code>int f() =&gt; 0;

void g() {
  f();
}</code></pre>

<h3 id="dead_code">
<a class="anchor" href="#dead_code" aria-hidden="true"><span class="octicon octicon-link"></span></a>dead_code</h3>

<p><em>Dead code.</em></p>

<h4 id="description-66">Description</h4>

<p>The analyzer produces this diagnostic when code is found that won’t be
executed because execution will never reach the code.</p>

<h4 id="example-61">Example</h4>

<p>The following code produces this diagnostic because the invocation of
<code class="language-plaintext highlighter-rouge">print</code> occurs after the function has returned:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  return;
  <span class="highlight">print('here');</span>
}</code></pre>

<h4 id="common-fixes-66">Common fixes</h4>

<p>If the code isn’t needed, then remove it:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  return;
}</code></pre>

<p>If the code needs to be executed, then either move the code to a place
where it will be executed:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  print('here');
  return;
}</code></pre>

<p>Or, rewrite the code before it, so that it can be reached:</p>

<pre class="prettyprint lang-dart"><code>void f({bool skipPrinting = true}) {
  if (skipPrinting) {
    return;
  }
  print('here');
}</code></pre>

<h3 id="dead_code_catch_following_catch">
<a class="anchor" href="#dead_code_catch_following_catch" aria-hidden="true"><span class="octicon octicon-link"></span></a>dead_code_catch_following_catch</h3>

<p><em>Dead code: Catch clauses after a ‘catch (e)’ or an ‘on Object catch (e)’ are
never reached.</em></p>

<h4 id="description-67">Description</h4>

<p>The analyzer produces this diagnostic when a <code class="language-plaintext highlighter-rouge">catch</code> clause is found that
can’t be executed because it’s after a <code class="language-plaintext highlighter-rouge">catch</code> clause of the form
<code class="language-plaintext highlighter-rouge">catch (e)</code> or <code class="language-plaintext highlighter-rouge">on Object catch (e)</code>. The first <code class="language-plaintext highlighter-rouge">catch</code> clause that matches
the thrown object is selected, and both of those forms will match any
object, so no <code class="language-plaintext highlighter-rouge">catch</code> clauses that follow them will be selected.</p>

<h4 id="example-62">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
  } catch (e) {
  } <span class="highlight">on String {
  }</span>
}</code></pre>

<h4 id="common-fixes-67">Common fixes</h4>

<p>If the clause should be selectable, then move the clause before the general
clause:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
  } on String {
  } catch (e) {
  }
}</code></pre>

<p>If the clause doesn’t need to be selectable, then remove it:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
  } catch (e) {
  }
}</code></pre>

<h3 id="dead_code_on_catch_subtype">
<a class="anchor" href="#dead_code_on_catch_subtype" aria-hidden="true"><span class="octicon octicon-link"></span></a>dead_code_on_catch_subtype</h3>

<p><em>Dead code: This on-catch block won’t be executed because ‘{0}’ is a subtype of
‘{1}’ and hence will have been caught already.</em></p>

<h4 id="description-68">Description</h4>

<p>The analyzer produces this diagnostic when a <code class="language-plaintext highlighter-rouge">catch</code> clause is found that
can’t be executed because it is after a <code class="language-plaintext highlighter-rouge">catch</code> clause that catches either
the same type or a supertype of the clause’s type. The first <code class="language-plaintext highlighter-rouge">catch</code> clause
that matches the thrown object is selected, and the earlier clause always
matches anything matchable by the highlighted clause, so the highlighted
clause will never be selected.</p>

<h4 id="example-63">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
  } on num {
  } <span class="highlight">on int {
  }</span>
}</code></pre>

<h4 id="common-fixes-68">Common fixes</h4>

<p>If the clause should be selectable, then move the clause before the general
clause:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
  } on int {
  } on num {
  }
}</code></pre>

<p>If the clause doesn’t need to be selectable, then remove it:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
  } on num {
  }
}</code></pre>

<h3 id="dead_null_aware_expression">
<a class="anchor" href="#dead_null_aware_expression" aria-hidden="true"><span class="octicon octicon-link"></span></a>dead_null_aware_expression</h3>

<p><em>The left operand can’t be null, so the right operand is never executed.</em></p>

<h4 id="description-69">Description</h4>

<p>The analyzer produces this diagnostic in two cases.</p>

<p>The first is when the left operand of an <code class="language-plaintext highlighter-rouge">??</code> operator can’t be <code class="language-plaintext highlighter-rouge">null</code>.
The right operand is only evaluated if the left operand has the value
<code class="language-plaintext highlighter-rouge">null</code>, and because the left operand can’t be <code class="language-plaintext highlighter-rouge">null</code>, the right operand is
never evaluated.</p>

<p>The second is when the left-hand side of an assignment using the <code class="language-plaintext highlighter-rouge">??=</code>
operator can’t be <code class="language-plaintext highlighter-rouge">null</code>. The right-hand side is only evaluated if the
left-hand side has the value <code class="language-plaintext highlighter-rouge">null</code>, and because the left-hand side can’t
be <code class="language-plaintext highlighter-rouge">null</code>, the right-hand side is never evaluated.</p>

<h4 id="examples-5">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> can’t be <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>int f(int x) {
  return x ?? <span class="highlight">0</span>;
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> can’t be <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f = -1;

  void m(int x) {
    f ??= <span class="highlight">x</span>;
  }
}</code></pre>

<h4 id="common-fixes-69">Common fixes</h4>

<p>If the diagnostic is reported for an <code class="language-plaintext highlighter-rouge">??</code> operator, then remove the <code class="language-plaintext highlighter-rouge">??</code>
operator and the right operand:</p>

<pre class="prettyprint lang-dart"><code>int f(int x) {
  return x;
}</code></pre>

<p>If the diagnostic is reported for an assignment, and the assignment isn’t
needed, then remove the assignment:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f = -1;

  void m(int x) {
  }
}</code></pre>

<p>If the assignment is needed, but should be based on a different condition,
then rewrite the code to use <code class="language-plaintext highlighter-rouge">=</code> and the different condition:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f = -1;

  void m(int x) {
    if (f &lt; 0) {
      f = x;
    }
  }
}</code></pre>

<h3 id="default_list_constructor">
<a class="anchor" href="#default_list_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>default_list_constructor</h3>

<p><em>The default ‘List’ constructor isn’t available when null safety is enabled.</em></p>

<h4 id="description-70">Description</h4>

<p>The analyzer produces this diagnostic when it finds a use of the default
constructor for the class <code class="language-plaintext highlighter-rouge">List</code> in code that has opted in to null safety.</p>

<h4 id="example-64">Example</h4>

<p>Assuming the following code is opted in to null safety, it produces this
diagnostic because it uses the default <code class="language-plaintext highlighter-rouge">List</code> constructor:</p>

<pre class="prettyprint lang-dart"><code>var l = <span class="highlight">List&lt;int&gt;</span>();</code></pre>

<h4 id="common-fixes-70">Common fixes</h4>

<p>If no initial size is provided, then convert the code to use a list
literal:</p>

<pre class="prettyprint lang-dart"><code>var l = &lt;int&gt;[];</code></pre>

<p>If an initial size needs to be provided and there is a single reasonable
initial value for the elements, then use <code class="language-plaintext highlighter-rouge">List.filled</code>:</p>

<pre class="prettyprint lang-dart"><code>var l = List.filled(3, 0);</code></pre>

<p>If an initial size needs to be provided but each element needs to be
computed, then use <code class="language-plaintext highlighter-rouge">List.generate</code>:</p>

<pre class="prettyprint lang-dart"><code>var l = List.generate(3, (i) =&gt; i);</code></pre>

<h3 id="default_value_in_function_type">
<a class="anchor" href="#default_value_in_function_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>default_value_in_function_type</h3>

<p><em>Parameters in a function type can’t have default values.</em></p>

<h4 id="description-71">Description</h4>

<p>The analyzer produces this diagnostic when a function type associated with
a parameter includes optional parameters that have a default value. This
isn’t allowed because the default values of parameters aren’t part of the
function’s type, and therefore including them doesn’t provide any value.</p>

<h4 id="example-65">Example</h4>

<p>The following code produces this diagnostic because the parameter <code class="language-plaintext highlighter-rouge">p</code> has a
default value even though it’s part of the type of the parameter <code class="language-plaintext highlighter-rouge">g</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(void Function([int p <span class="highlight">=</span> 0]) g) {
}</code></pre>

<h4 id="common-fixes-71">Common fixes</h4>

<p>Remove the default value from the function-type’s parameter:</p>

<pre class="prettyprint lang-dart"><code>void f(void Function([int p]) g) {
}</code></pre>

<h3 id="default_value_in_redirecting_factory_constructor">
<a class="anchor" href="#default_value_in_redirecting_factory_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>default_value_in_redirecting_factory_constructor</h3>

<p><em>Default values aren’t allowed in factory constructors that redirect to another
constructor.</em></p>

<h4 id="description-72">Description</h4>

<p>The analyzer produces this diagnostic when a factory constructor that
redirects to another constructor specifies a default value for an optional
parameter.</p>

<h4 id="example-66">Example</h4>

<p>The following code produces this diagnostic because the factory constructor
in <code class="language-plaintext highlighter-rouge">A</code> has a default value for the optional parameter <code class="language-plaintext highlighter-rouge">x</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A([int <span class="highlight">x</span> = 0]) = B;
}

class B implements A {
  B([int x = 1]) {}
}</code></pre>

<h4 id="common-fixes-72">Common fixes</h4>

<p>Remove the default value from the factory constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A([int x]) = B;
}

class B implements A {
  B([int x = 1]) {}
}</code></pre>

<p>Note that this fix might change the value used when the optional parameter
is omitted. If that happens, and if that change is a problem, then consider
making the optional parameter a required parameter in the factory method:</p>

<pre class="prettyprint lang-dart"><code>class A {
 factory A(int x) = B;
}

class B implements A {
  B([int x = 1]) {}
}</code></pre>

<h3 id="default_value_on_required_parameter">
<a class="anchor" href="#default_value_on_required_parameter" aria-hidden="true"><span class="octicon octicon-link"></span></a>default_value_on_required_parameter</h3>

<p><em>Required named parameters can’t have a default value.</em></p>

<h4 id="description-73">Description</h4>

<p>The analyzer produces this diagnostic when a named parameter has both the
<code class="language-plaintext highlighter-rouge">required</code> modifier and a default value. If the parameter is required, then
a value for the parameter is always provided at the call sites, so the
default value can never be used.</p>

<h4 id="example-67">Example</h4>

<p>The following code generates this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>void log({required String <span class="highlight">message</span> = 'no message'}) {}</code></pre>

<h4 id="common-fixes-73">Common fixes</h4>

<p>If the parameter is really required, then remove the default value:</p>

<pre class="prettyprint lang-dart"><code>void log({required String message}) {}</code></pre>

<p>If the parameter isn’t always required, then remove the <code class="language-plaintext highlighter-rouge">required</code>
modifier:</p>

<pre class="prettyprint lang-dart"><code>void log({String message = 'no message'}) {}</code></pre>

<h3 id="deferred_import_of_extension">
<a class="anchor" href="#deferred_import_of_extension" aria-hidden="true"><span class="octicon octicon-link"></span></a>deferred_import_of_extension</h3>

<p><em>Imports of deferred libraries must hide all extensions.</em></p>

<h4 id="description-74">Description</h4>

<p>The analyzer produces this diagnostic when a library that is imported using
a deferred import declares an extension that is visible in the importing
library. Extension methods are resolved at compile time, and extensions
from deferred libraries aren’t available at compile time.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-68">Example</h4>

<p>Given a file (<code class="language-plaintext highlighter-rouge">a.dart</code>) that defines a named extension:</p>

<pre class="prettyprint lang-dart"><code>class C {}

extension E on String {
  int get size =&gt; length;
}</code></pre>

<p>The following code produces this diagnostic because the named extension is
visible to the library:</p>

<pre class="prettyprint lang-dart"><code>import <span class="highlight">'a.dart'</span> deferred as a;

void f() {
  a.C();
}</code></pre>

<h4 id="common-fixes-74">Common fixes</h4>

<p>If the library must be imported as <code class="language-plaintext highlighter-rouge">deferred</code>, then either add a <code class="language-plaintext highlighter-rouge">show</code>
clause listing the names being referenced or add a <code class="language-plaintext highlighter-rouge">hide</code> clause listing
all of the named extensions. Adding a <code class="language-plaintext highlighter-rouge">show</code> clause would look like this:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' deferred as a show C;

void f() {
  a.C();
}</code></pre>

<p>Adding a <code class="language-plaintext highlighter-rouge">hide</code> clause would look like this:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' deferred as a hide E;

void f() {
  a.C();
}</code></pre>

<p>With the first fix, the benefit is that if new extensions are added to the
imported library, then the extensions won’t cause a diagnostic to be
generated.</p>

<p>If the library doesn’t need to be imported as <code class="language-plaintext highlighter-rouge">deferred</code>, or if you need to
make use of the extension method declared in it, then remove the keyword
<code class="language-plaintext highlighter-rouge">deferred</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' as a;

void f() {
  a.C();
}</code></pre>

<h3 id="definitely_unassigned_late_local_variable">
<a class="anchor" href="#definitely_unassigned_late_local_variable" aria-hidden="true"><span class="octicon octicon-link"></span></a>definitely_unassigned_late_local_variable</h3>

<p><em>The late local variable ‘{0}’ is definitely unassigned at this point.</em></p>

<h4 id="description-75">Description</h4>

<p>The analyzer produces this diagnostic when <a href="#definite-assignment">definite assignment</a> analysis
shows that a local variable that’s marked as <code class="language-plaintext highlighter-rouge">late</code> is read before being
assigned.</p>

<h4 id="example-69">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> wasn’t assigned a
value before being read:</p>

<pre class="prettyprint lang-dart"><code>void f(bool b) {
  late int x;
  print(<span class="highlight">x</span>);
}</code></pre>

<h4 id="common-fixes-75">Common fixes</h4>

<p>Assign a value to the variable before reading from it:</p>

<pre class="prettyprint lang-dart"><code>void f(bool b) {
  late int x;
  x = b ? 1 : 0;
  print(x);
}</code></pre>

<h3 id="dependencies_field_not_map">
<a class="anchor" href="#dependencies_field_not_map" aria-hidden="true"><span class="octicon octicon-link"></span></a>dependencies_field_not_map</h3>

<p><em>The value of the ‘{0}’ field is expected to be a map.</em></p>

<h4 id="description-76">Description</h4>

<p>The analyzer produces this diagnostic when the value of either the
<code class="language-plaintext highlighter-rouge">dependencies</code> or <code class="language-plaintext highlighter-rouge">dev_dependencies</code> key isn’t a map.</p>

<h4 id="example-70">Example</h4>

<p>The following code produces this diagnostic because the value of the
top-level <code class="language-plaintext highlighter-rouge">dependencies</code> key is a list:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">meta</span>
</code></pre></div></div>

<h4 id="common-fixes-76">Common fixes</h4>

<p>Use a map as the value of the <code class="language-plaintext highlighter-rouge">dependencies</code> key:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">meta</span><span class="pi">:</span> <span class="s">^1.0.2</span>
</code></pre></div></div>

<h3 id="deprecated_field">
<a class="anchor" href="#deprecated_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>deprecated_field</h3>

<p><em>The ‘{0}’ field is no longer used and can be removed.</em></p>

<h4 id="description-77">Description</h4>

<p>The analyzer produces this diagnostic when a key is used in a
<code class="language-plaintext highlighter-rouge">pubspec.yaml</code> file that was deprecated. Unused keys take up space and
might imply semantics that are no longer valid.</p>

<h4 id="example-71">Example</h4>

<p>The following code produces this diagnostic because the <code class="language-plaintext highlighter-rouge">author</code> key is no
longer being used:</p>

<pre class="prettyprint lang-dart"><code>name: example
author: 'Dash'</code></pre>

<h4 id="common-fixes-77">Common fixes</h4>

<p>Remove the deprecated key:</p>

<pre class="prettyprint lang-dart"><code>name: example</code></pre>

<h3 id="deprecated_member_use">
<a class="anchor" href="#deprecated_member_use" aria-hidden="true"><span class="octicon octicon-link"></span></a>deprecated_member_use</h3>

<p><em>‘{0}’ is deprecated and shouldn’t be used.</em></p>

<p><em>‘{0}’ is deprecated and shouldn’t be used. {1}.</em></p>

<h4 id="description-78">Description</h4>

<p>The analyzer produces this diagnostic when a deprecated library or class
member is used in a different package.</p>

<h4 id="example-72">Example</h4>

<p>If the method <code class="language-plaintext highlighter-rouge">m</code> in the class <code class="language-plaintext highlighter-rouge">C</code> is annotated with <code class="language-plaintext highlighter-rouge">@deprecated</code>, then
the following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>void f(C c) {
  c.<span class="highlight">m</span>();
}</code></pre>

<h4 id="common-fixes-78">Common fixes</h4>

<p>The documentation for declarations that are annotated with <code class="language-plaintext highlighter-rouge">@deprecated</code>
should indicate what code to use in place of the deprecated code.</p>

<h3 id="deprecated_member_use_from_same_package">
<a class="anchor" href="#deprecated_member_use_from_same_package" aria-hidden="true"><span class="octicon octicon-link"></span></a>deprecated_member_use_from_same_package</h3>

<p><em>‘{0}’ is deprecated and shouldn’t be used.</em></p>

<p><em>‘{0}’ is deprecated and shouldn’t be used. {1}.</em></p>

<h4 id="description-79">Description</h4>

<p>The analyzer produces this diagnostic when a deprecated library member or
class member is used in the same package in which it’s declared.</p>

<h4 id="example-73">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> is deprecated:</p>

<pre class="prettyprint lang-dart"><code>@deprecated
var x = 0;
var y = <span class="highlight">x</span>;</code></pre>

<h4 id="common-fixes-79">Common fixes</h4>

<p>The fix depends on what’s been deprecated and what the replacement is. The
documentation for deprecated declarations should indicate what code to use
in place of the deprecated code.</p>

<h3 id="deprecated_new_in_comment_reference">
<a class="anchor" href="#deprecated_new_in_comment_reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>deprecated_new_in_comment_reference</h3>

<p><em>Using the ‘new’ keyword in a comment reference is deprecated.</em></p>

<h4 id="description-80">Description</h4>

<p>The analyzer produces this diagnostic when a comment reference (the name
of a declaration enclosed in square brackets in a documentation comment)
uses the keyword <code class="language-plaintext highlighter-rouge">new</code> to refer to a constructor. This form is deprecated.</p>

<h4 id="examples-6">Examples</h4>

<p>The following code produces this diagnostic because the unnamed
constructor is being referenced using <code class="language-plaintext highlighter-rouge">new C</code>:</p>

<pre class="prettyprint lang-dart"><code>/// See [<span class="highlight">new</span> C].
class C {
  C();
}</code></pre>

<p>The following code produces this diagnostic because the constructor named
<code class="language-plaintext highlighter-rouge">c</code> is being referenced using <code class="language-plaintext highlighter-rouge">new C.c</code>:</p>

<pre class="prettyprint lang-dart"><code>/// See [<span class="highlight">new</span> C.c].
class C {
  C.c();
}</code></pre>

<h4 id="common-fixes-80">Common fixes</h4>

<p>If you’re referencing a named constructor, then remove the keyword <code class="language-plaintext highlighter-rouge">new</code>:</p>

<pre class="prettyprint lang-dart"><code>/// See [C.c].
class C {
  C.c();
}</code></pre>

<p>If you’re referencing the unnamed constructor, then remove the keyword
<code class="language-plaintext highlighter-rouge">new</code> and append <code class="language-plaintext highlighter-rouge">.new</code> after the class name:</p>

<pre class="prettyprint lang-dart"><code>/// See [C.new].
class C {
  C.c();
}</code></pre>

<h3 id="deprecated_subtype_of_function">
<a class="anchor" href="#deprecated_subtype_of_function" aria-hidden="true"><span class="octicon octicon-link"></span></a>deprecated_subtype_of_function</h3>

<p><em>Extending ‘Function’ is deprecated.</em></p>

<p><em>Implementing ‘Function’ has no effect.</em></p>

<p><em>Mixing in ‘Function’ is deprecated.</em></p>

<h4 id="description-81">Description</h4>

<p>The analyzer produces this diagnostic when the class <code class="language-plaintext highlighter-rouge">Function</code> is used in
either the <code class="language-plaintext highlighter-rouge">extends</code>, <code class="language-plaintext highlighter-rouge">implements</code>, or <code class="language-plaintext highlighter-rouge">with</code> clause of a class or mixin.
Using the class <code class="language-plaintext highlighter-rouge">Function</code> in this way has no semantic value, so it’s
effectively dead code.</p>

<h4 id="example-74">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">Function</code> is used as
the superclass of <code class="language-plaintext highlighter-rouge">F</code>:</p>

<pre class="prettyprint lang-dart"><code>class F extends <span class="highlight">Function</span> {}</code></pre>

<h4 id="common-fixes-81">Common fixes</h4>

<p>Remove the class <code class="language-plaintext highlighter-rouge">Function</code> from whichever clause it’s in, and remove the
whole clause if <code class="language-plaintext highlighter-rouge">Function</code> is the only type in the clause:</p>

<pre class="prettyprint lang-dart"><code>class F {}</code></pre>

<h3 id="disallowed_type_instantiation_expression">
<a class="anchor" href="#disallowed_type_instantiation_expression" aria-hidden="true"><span class="octicon octicon-link"></span></a>disallowed_type_instantiation_expression</h3>

<p><em>Only a generic type, generic function, generic instance method, or generic
constructor can have type arguments.</em></p>

<h4 id="description-82">Description</h4>

<p>The analyzer produces this diagnostic when an expression with a value that
is anything other than one of the allowed kinds of values is followed by
type arguments. The allowed kinds of values are:</p>
<ul>
  <li>generic types,</li>
  <li>generic constructors, and</li>
  <li>generic functions, including top-level functions, static and instance
members, and local functions.</li>
</ul>

<h4 id="example-75">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">i</code> is a top-level
variable, which isn’t one of the allowed cases:</p>

<pre class="prettyprint lang-dart"><code>int i = 1;

void f() {
  print(<span class="highlight">i</span>&lt;int&gt;);
}</code></pre>

<h4 id="common-fixes-82">Common fixes</h4>

<p>If the referenced value is correct, then remove the type arguments:</p>

<pre class="prettyprint lang-dart"><code>int i = 1;

void f() {
  print(i);
}</code></pre>

<h3 id="division_optimization">
<a class="anchor" href="#division_optimization" aria-hidden="true"><span class="octicon octicon-link"></span></a>division_optimization</h3>

<p><em>The operator x ~/ y is more efficient than (x / y).toInt().</em></p>

<h4 id="description-83">Description</h4>

<p>The analyzer produces this diagnostic when the result of dividing two
numbers is converted to an integer using <code class="language-plaintext highlighter-rouge">toInt</code>. Dart has a built-in
integer division operator that is both more efficient and more concise.</p>

<h4 id="example-76">Example</h4>

<p>The following code produces this diagnostic because the result of dividing
<code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> is converted to an integer using <code class="language-plaintext highlighter-rouge">toInt</code>:</p>

<pre class="prettyprint lang-dart"><code>int divide(num x, num y) =&gt; <span class="highlight">(x / y).toInt()</span>;</code></pre>

<h4 id="common-fixes-83">Common fixes</h4>

<p>Use the integer division operator (<code class="language-plaintext highlighter-rouge">~/</code>):</p>

<pre class="prettyprint lang-dart"><code>int divide(num x, num y) =&gt; x ~/ y;</code></pre>

<h3 id="duplicate_constructor">
<a class="anchor" href="#duplicate_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>duplicate_constructor</h3>

<p><em>The constructor with name ‘{0}’ is already defined.</em></p>

<p><em>The unnamed constructor is already defined.</em></p>

<h4 id="description-84">Description</h4>

<p>The analyzer produces this diagnostic when a class declares more than one
unnamed constructor or when it declares more than one constructor with the
same name.</p>

<h4 id="examples-7">Examples</h4>

<p>The following code produces this diagnostic because there are two
declarations for the unnamed constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C();

  <span class="highlight">C</span>();
}</code></pre>

<p>The following code produces this diagnostic because there are two
declarations for the constructor named <code class="language-plaintext highlighter-rouge">m</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.m();

  <span class="highlight">C.m</span>();
}</code></pre>

<h4 id="common-fixes-84">Common fixes</h4>

<p>If there are multiple unnamed constructors and all of the constructors are
needed, then give all of them, or all except one of them, a name:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C();

  C.n();
}</code></pre>

<p>If there are multiple unnamed constructors and all except one of them are
unneeded, then remove the constructors that aren’t needed:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C();
}</code></pre>

<p>If there are multiple named constructors and all of the constructors are
needed, then rename all except one of them:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.m();

  C.n();
}</code></pre>

<p>If there are multiple named constructors and all except one of them are
unneeded, then remove the constructorsthat aren’t needed:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.m();
}</code></pre>

<h3 id="duplicate_definition">
<a class="anchor" href="#duplicate_definition" aria-hidden="true"><span class="octicon octicon-link"></span></a>duplicate_definition</h3>

<p><em>The name ‘{0}’ is already defined.</em></p>

<h4 id="description-85">Description</h4>

<p>The analyzer produces this diagnostic when a name is declared, and there is
a previous declaration with the same name in the same scope.</p>

<h4 id="example-77">Example</h4>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">x</code> is
declared twice:</p>

<pre class="prettyprint lang-dart"><code>int x = 0;
int <span class="highlight">x</span> = 1;</code></pre>

<h4 id="common-fixes-85">Common fixes</h4>

<p>Choose a different name for one of the declarations.</p>

<pre class="prettyprint lang-dart"><code>int x = 0;
int y = 1;</code></pre>

<h3 id="duplicate_field_formal_parameter">
<a class="anchor" href="#duplicate_field_formal_parameter" aria-hidden="true"><span class="octicon octicon-link"></span></a>duplicate_field_formal_parameter</h3>

<p><em>The field ‘{0}’ can’t be initialized by multiple parameters in the same
constructor.</em></p>

<h4 id="description-86">Description</h4>

<p>The analyzer produces this diagnostic when there’s more than one
initializing formal parameter for the same field in a constructor’s
parameter list. It isn’t useful to assign a value that will immediately be
overwritten.</p>

<h4 id="example-78">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">this.f</code> appears twice
in the parameter list:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(this.f, this.<span class="highlight">f</span>) {}
}</code></pre>

<h4 id="common-fixes-86">Common fixes</h4>

<p>Remove one of the initializing formal parameters:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(this.f) {}
}</code></pre>

<h3 id="duplicate_hidden_name">
<a class="anchor" href="#duplicate_hidden_name" aria-hidden="true"><span class="octicon octicon-link"></span></a>duplicate_hidden_name</h3>

<p><em>Duplicate hidden name.</em></p>

<h4 id="description-87">Description</h4>

<p>The analyzer produces this diagnostic when a name occurs multiple times in
a <code class="language-plaintext highlighter-rouge">hide</code> clause. Repeating the name is unnecessary.</p>

<h4 id="example-79">Example</h4>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">min</code> is
hidden more than once:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' hide min, <span class="highlight">min</span>;

var x = pi;</code></pre>

<h4 id="common-fixes-87">Common fixes</h4>

<p>If the name was mistyped in one or more places, then correct the mistyped
names:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' hide max, min;

var x = pi;</code></pre>

<p>If the name wasn’t mistyped, then remove the unnecessary name from the
list:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' hide min;

var x = pi;</code></pre>

<h3 id="duplicate_ignore">
<a class="anchor" href="#duplicate_ignore" aria-hidden="true"><span class="octicon octicon-link"></span></a>duplicate_ignore</h3>

<p><em>The diagnostic ‘{0}’ doesn’t need to be ignored here because it’s already being
ignored.</em></p>

<h4 id="description-88">Description</h4>

<p>The analyzer produces this diagnostic when a diagnostic name appears in an
<code class="language-plaintext highlighter-rouge">ignore</code> comment, but the diagnostic is already being ignored, either
because it’s already included in the same <code class="language-plaintext highlighter-rouge">ignore</code> comment or because it
appears in an <code class="language-plaintext highlighter-rouge">ignore-in-file</code> comment.</p>

<h4 id="examples-8">Examples</h4>

<p>The following code produces this diagnostic because the diagnostic named
<code class="language-plaintext highlighter-rouge">unused_local_variable</code> is already being ignored for the whole file so it
doesn’t need to be ignored on a specific line:</p>

<pre class="prettyprint lang-dart"><code>// ignore_for_file: unused_local_variable
void f() {
  // ignore: <span class="highlight">unused_local_variable</span>
  var x = 0;
}</code></pre>

<p>The following code produces this diagnostic because the diagnostic named
<code class="language-plaintext highlighter-rouge">unused_local_variable</code> is being ignored twice on the same line:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  // ignore: unused_local_variable, <span class="highlight">unused_local_variable</span>
  var x = 0;
}</code></pre>

<h4 id="common-fixes-88">Common fixes</h4>

<p>Remove the ignore comment, or remove the unnecessary diagnostic name if the
ignore comment is ignoring more than one diagnostic:</p>

<pre class="prettyprint lang-dart"><code>// ignore_for_file: unused_local_variable
void f() {
  var x = 0;
}</code></pre>

<h3 id="duplicate_import">
<a class="anchor" href="#duplicate_import" aria-hidden="true"><span class="octicon octicon-link"></span></a>duplicate_import</h3>

<p><em>Duplicate import.</em></p>

<h4 id="description-89">Description</h4>

<p>The analyzer produces this diagnostic when an import directive is found
that is the same as an import before it in the file. The second import
doesn’t add value and should be removed.</p>

<h4 id="example-80">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';
import <span class="highlight">'package:meta/meta.dart'</span>;

@sealed class C {}</code></pre>

<h4 id="common-fixes-89">Common fixes</h4>

<p>Remove the unnecessary import:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@sealed class C {}</code></pre>

<h3 id="duplicate_named_argument">
<a class="anchor" href="#duplicate_named_argument" aria-hidden="true"><span class="octicon octicon-link"></span></a>duplicate_named_argument</h3>

<p><em>The argument for the named parameter ‘{0}’ was already specified.</em></p>

<h4 id="description-90">Description</h4>

<p>The analyzer produces this diagnostic when an invocation has two or more
named arguments that have the same name.</p>

<h4 id="example-81">Example</h4>

<p>The following code produces this diagnostic because there are two arguments
with the name <code class="language-plaintext highlighter-rouge">a</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(C c) {
  c.m(a: 0, <span class="highlight">a</span>: 1);
}

class C {
  void m({int a, int b}) {}
}</code></pre>

<h4 id="common-fixes-90">Common fixes</h4>

<p>If one of the arguments should have a different name, then change the name:</p>

<pre class="prettyprint lang-dart"><code>void f(C c) {
  c.m(a: 0, b: 1);
}

class C {
  void m({int a, int b}) {}
}</code></pre>

<p>If one of the arguments is wrong, then remove it:</p>

<pre class="prettyprint lang-dart"><code>void f(C c) {
  c.m(a: 1);
}

class C {
  void m({int a, int b}) {}
}</code></pre>

<h3 id="duplicate_part">
<a class="anchor" href="#duplicate_part" aria-hidden="true"><span class="octicon octicon-link"></span></a>duplicate_part</h3>

<p><em>The library already contains a part with the URI ‘{0}’.</em></p>

<h4 id="description-91">Description</h4>

<p>The analyzer produces this diagnostic when a single file is referenced in
multiple part directives.</p>

<h4 id="example-82">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">part.dart</code> containing</p>

<pre class="prettyprint lang-dart"><code>part of lib;</code></pre>

<p>The following code produces this diagnostic because the file <code class="language-plaintext highlighter-rouge">part.dart</code> is
included multiple times:</p>

<pre class="prettyprint lang-dart"><code>library lib;

part 'part.dart';
part <span class="highlight">'part.dart'</span>;</code></pre>

<h4 id="common-fixes-91">Common fixes</h4>

<p>Remove all except the first of the duplicated part directives:</p>

<pre class="prettyprint lang-dart"><code>library lib;

part 'part.dart';</code></pre>

<h3 id="duplicate_shown_name">
<a class="anchor" href="#duplicate_shown_name" aria-hidden="true"><span class="octicon octicon-link"></span></a>duplicate_shown_name</h3>

<p><em>Duplicate shown name.</em></p>

<h4 id="description-92">Description</h4>

<p>The analyzer produces this diagnostic when a name occurs multiple times in
a <code class="language-plaintext highlighter-rouge">show</code> clause. Repeating the name is unnecessary.</p>

<h4 id="example-83">Example</h4>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">min</code> is shown
more than once:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' show min, <span class="highlight">min</span>;

var x = min(2, min(0, 1));</code></pre>

<h4 id="common-fixes-92">Common fixes</h4>

<p>If the name was mistyped in one or more places, then correct the mistyped
names:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' show max, min;

var x = max(2, min(0, 1));</code></pre>

<p>If the name wasn’t mistyped, then remove the unnecessary name from the
list:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' show min;

var x = min(2, min(0, 1));</code></pre>

<h3 id="empty_struct">
<a class="anchor" href="#empty_struct" aria-hidden="true"><span class="octicon octicon-link"></span></a>empty_struct</h3>

<p><em>The class ‘{0}’ can’t be empty because it’s a subclass of ‘{1}’.</em></p>

<h4 id="description-93">Description</h4>

<p>The analyzer produces this diagnostic when a subclass of <code class="language-plaintext highlighter-rouge">Struct</code> or
<code class="language-plaintext highlighter-rouge">Union</code> doesn’t have any fields. Having an empty <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code>
isn’t supported.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-84">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code>, which
extends <code class="language-plaintext highlighter-rouge">Struct</code>, doesn’t declare any fields:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class <span class="highlight">C</span> extends Struct {}</code></pre>

<h4 id="common-fixes-93">Common fixes</h4>

<p>If the class is intended to be a struct, then declare one or more fields:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Int32()
  external int x;
}</code></pre>

<p>If the class is intended to be used as a type argument to <code class="language-plaintext highlighter-rouge">Pointer</code>, then
make it a subclass of <code class="language-plaintext highlighter-rouge">Opaque</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Opaque {}</code></pre>

<p>If the class isn’t intended to be a struct, then remove or change the
extends clause:</p>

<pre class="prettyprint lang-dart"><code>class C {}</code></pre>

<h3 id="enum_constant_same_name_as_enclosing">
<a class="anchor" href="#enum_constant_same_name_as_enclosing" aria-hidden="true"><span class="octicon octicon-link"></span></a>enum_constant_same_name_as_enclosing</h3>

<p><em>The name of the enum constant can’t be the same as the enum’s name.</em></p>

<h4 id="description-94">Description</h4>

<p>The analyzer produces this diagnostic when an enum constant has the same
name as the enum in which it’s declared.</p>

<h4 id="example-85">Example</h4>

<p>The following code produces this diagnostic because the enum constant <code class="language-plaintext highlighter-rouge">E</code>
has the same name as the enclosing enum <code class="language-plaintext highlighter-rouge">E</code>:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  <span class="highlight">E</span>
}</code></pre>

<h4 id="common-fixes-94">Common fixes</h4>

<p>If the name of the enum is correct, then rename the constant:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  e
}</code></pre>

<p>If the name of the constant is correct, then rename the enum:</p>

<pre class="prettyprint lang-dart"><code>enum F {
  E
}</code></pre>

<h3 id="enum_constant_with_non_const_constructor">
<a class="anchor" href="#enum_constant_with_non_const_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>enum_constant_with_non_const_constructor</h3>

<p><em>The invoked constructor isn’t a ‘const’ constructor.</em></p>

<h4 id="description-95">Description</h4>

<p>The analyzer produces this diagnostic when an enum constant is being
created using either a factory constructor or a generative constructor
that isn’t marked as being <code class="language-plaintext highlighter-rouge">const</code>.</p>

<h4 id="example-86">Example</h4>

<p>The following code produces this diagnostic because the enum constant <code class="language-plaintext highlighter-rouge">e</code>
is being initialized by a factory constructor:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  <span class="highlight">e</span>();

  factory E() =&gt; e;
}</code></pre>

<h4 id="common-fixes-95">Common fixes</h4>

<p>Use a generative constructor marked as <code class="language-plaintext highlighter-rouge">const</code>:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  e._();

  factory E() =&gt; e;

  const E._();
}</code></pre>

<h3 id="enum_mixin_with_instance_variable">
<a class="anchor" href="#enum_mixin_with_instance_variable" aria-hidden="true"><span class="octicon octicon-link"></span></a>enum_mixin_with_instance_variable</h3>

<p><em>Mixins applied to enums can’t have instance variables.</em></p>

<h4 id="description-96">Description</h4>

<p>The analyzer produces this diagnostic when a mixin that’s applied to an
enum declares one or more instance variables. This isn’t allowed because
the enum constants are constant, and there isn’t any way for the
constructor in the enum to initialize any of the mixin’s fields.</p>

<h4 id="example-87">Example</h4>

<p>The following code produces this diagnostic because the mixin <code class="language-plaintext highlighter-rouge">M</code> defines
the instance field <code class="language-plaintext highlighter-rouge">x</code>:</p>

<pre class="prettyprint lang-dart"><code>mixin M {
  int x = 0;
}

enum E with <span class="highlight">M</span> {
  a
}</code></pre>

<h4 id="common-fixes-96">Common fixes</h4>

<p>If you need to apply the mixin, then change all instance fields into
getter and setter pairs and implement them in the enum if necessary:</p>

<pre class="prettyprint lang-dart"><code>mixin M {
  int get x =&gt; 0;
}

enum E with M {
  a
}</code></pre>

<p>If you don’t need to apply the mixin, then remove it:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  a
}</code></pre>

<h3 id="enum_with_abstract_member">
<a class="anchor" href="#enum_with_abstract_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>enum_with_abstract_member</h3>

<p><em>‘{0}’ must have a method body because ‘{1}’ is an enum.</em></p>

<h4 id="description-97">Description</h4>

<p>The analyzer produces this diagnostic when a member of an enum is found
that doesn’t have a concrete implementation. Enums aren’t allowed to
contain abstract members.</p>

<h4 id="example-88">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">m</code> is an abstract
method and <code class="language-plaintext highlighter-rouge">E</code> is an enum:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  e;

  <span class="highlight">void m();</span>
}</code></pre>

<h4 id="common-fixes-97">Common fixes</h4>

<p>Provide an implementation for the member:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  e;

  void m() {}
}</code></pre>

<h3 id="enum_with_name_values">
<a class="anchor" href="#enum_with_name_values" aria-hidden="true"><span class="octicon octicon-link"></span></a>enum_with_name_values</h3>

<p><em>The name ‘values’ is not a valid name for an enum.</em></p>

<h4 id="description-98">Description</h4>

<p>The analyzer produces this diagnostic when an enum is declared to have the
name <code class="language-plaintext highlighter-rouge">values</code>. This isn’t allowed because the enum has an implicit static
field named <code class="language-plaintext highlighter-rouge">values</code>, and the two would collide.</p>

<h4 id="example-89">Example</h4>

<p>The following code produces this diagnostic because there’s an enum
declaration that has the name <code class="language-plaintext highlighter-rouge">values</code>:</p>

<pre class="prettyprint lang-dart"><code>enum <span class="highlight">values</span> {
  c
}</code></pre>

<h4 id="common-fixes-98">Common fixes</h4>

<p>Rename the enum to something other than <code class="language-plaintext highlighter-rouge">values</code>.</p>

<h3 id="equal_elements_in_const_set">
<a class="anchor" href="#equal_elements_in_const_set" aria-hidden="true"><span class="octicon octicon-link"></span></a>equal_elements_in_const_set</h3>

<p><em>Two elements in a constant set literal can’t be equal.</em></p>

<h4 id="description-99">Description</h4>

<p>The analyzer produces this diagnostic when two elements in a constant set
literal have the same value. The set can only contain each value once,
which means that one of the values is unnecessary.</p>

<h4 id="example-90">Example</h4>

<p>The following code produces this diagnostic because the string <code class="language-plaintext highlighter-rouge">'a'</code> is
specified twice:</p>

<pre class="prettyprint lang-dart"><code>const Set&lt;String&gt; set = {'a', <span class="highlight">'a'</span>};</code></pre>

<h4 id="common-fixes-99">Common fixes</h4>

<p>Remove one of the duplicate values:</p>

<pre class="prettyprint lang-dart"><code>const Set&lt;String&gt; set = {'a'};</code></pre>

<p>Note that literal sets preserve the order of their elements, so the choice
of which element to remove might affect the order in which elements are
returned by an iterator.</p>

<h3 id="equal_elements_in_set">
<a class="anchor" href="#equal_elements_in_set" aria-hidden="true"><span class="octicon octicon-link"></span></a>equal_elements_in_set</h3>

<p><em>Two elements in a set literal shouldn’t be equal.</em></p>

<h4 id="description-100">Description</h4>

<p>The analyzer produces this diagnostic when an element in a non-constant set
is the same as a previous element in the same set. If two elements are the
same, then the second value is ignored, which makes having both elements
pointless and likely signals a bug.</p>

<h4 id="example-91">Example</h4>

<p>The following code produces this diagnostic because the element <code class="language-plaintext highlighter-rouge">1</code> appears
twice:</p>

<pre class="prettyprint lang-dart"><code>const a = 1;
const b = 1;
var s = &lt;int&gt;{a, <span class="highlight">b</span>};</code></pre>

<h4 id="common-fixes-100">Common fixes</h4>

<p>If both elements should be included in the set, then change one of the
elements:</p>

<pre class="prettyprint lang-dart"><code>const a = 1;
const b = 2;
var s = &lt;int&gt;{a, b};</code></pre>

<p>If only one of the elements is needed, then remove the one that isn’t
needed:</p>

<pre class="prettyprint lang-dart"><code>const a = 1;
var s = &lt;int&gt;{a};</code></pre>

<p>Note that literal sets preserve the order of their elements, so the choice
of which element to remove might affect the order in which elements are
returned by an iterator.</p>

<h3 id="equal_keys_in_const_map">
<a class="anchor" href="#equal_keys_in_const_map" aria-hidden="true"><span class="octicon octicon-link"></span></a>equal_keys_in_const_map</h3>

<p><em>Two keys in a constant map literal can’t be equal.</em></p>

<h4 id="description-101">Description</h4>

<p>The analyzer produces this diagnostic when a key in a constant map is the
same as a previous key in the same map. If two keys are the same, then the
second value would overwrite the first value, which makes having both pairs
pointless.</p>

<h4 id="example-92">Example</h4>

<p>The following code produces this diagnostic because the key <code class="language-plaintext highlighter-rouge">1</code> is used
twice:</p>

<pre class="prettyprint lang-dart"><code>const map = &lt;int, String&gt;{1: 'a', 2: 'b', <span class="highlight">1</span>: 'c', 4: 'd'};</code></pre>

<h4 id="common-fixes-101">Common fixes</h4>

<p>If both entries should be included in the map, then change one of the keys
to be different:</p>

<pre class="prettyprint lang-dart"><code>const map = &lt;int, String&gt;{1: 'a', 2: 'b', 3: 'c', 4: 'd'};</code></pre>

<p>If only one of the entries is needed, then remove the one that isn’t
needed:</p>

<pre class="prettyprint lang-dart"><code>const map = &lt;int, String&gt;{1: 'a', 2: 'b', 4: 'd'};</code></pre>

<p>Note that literal maps preserve the order of their entries, so the choice
of which entry to remove might affect the order in which keys and values
are returned by an iterator.</p>

<h3 id="equal_keys_in_map">
<a class="anchor" href="#equal_keys_in_map" aria-hidden="true"><span class="octicon octicon-link"></span></a>equal_keys_in_map</h3>

<p><em>Two keys in a map literal shouldn’t be equal.</em></p>

<h4 id="description-102">Description</h4>

<p>The analyzer produces this diagnostic when a key in a non-constant map is
the same as a previous key in the same map. If two keys are the same, then
the second value overwrites the first value, which makes having both pairs
pointless and likely signals a bug.</p>

<h4 id="example-93">Example</h4>

<p>The following code produces this diagnostic because the keys <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>
have the same value:</p>

<pre class="prettyprint lang-dart"><code>const a = 1;
const b = 1;
var m = &lt;int, String&gt;{a: 'a', <span class="highlight">b</span>: 'b'};</code></pre>

<h4 id="common-fixes-102">Common fixes</h4>

<p>If both entries should be included in the map, then change one of the keys:</p>

<pre class="prettyprint lang-dart"><code>const a = 1;
const b = 2;
var m = &lt;int, String&gt;{a: 'a', b: 'b'};</code></pre>

<p>If only one of the entries is needed, then remove the one that isn’t
needed:</p>

<pre class="prettyprint lang-dart"><code>const a = 1;
var m = &lt;int, String&gt;{a: 'a'};</code></pre>

<p>Note that literal maps preserve the order of their entries, so the choice
of which entry to remove might affect the order in which the keys and
values are returned by an iterator.</p>

<h3 id="expected_one_list_type_arguments">
<a class="anchor" href="#expected_one_list_type_arguments" aria-hidden="true"><span class="octicon octicon-link"></span></a>expected_one_list_type_arguments</h3>

<p><em>List literals require one type argument or none, but {0} found.</em></p>

<h4 id="description-103">Description</h4>

<p>The analyzer produces this diagnostic when a list literal has more than one
type argument.</p>

<h4 id="example-94">Example</h4>

<p>The following code produces this diagnostic because the list literal has
two type arguments when it can have at most one:</p>

<pre class="prettyprint lang-dart"><code>var l = <span class="highlight">&lt;int, int&gt;</span>[];</code></pre>

<h4 id="common-fixes-103">Common fixes</h4>

<p>Remove all except one of the type arguments:</p>

<pre class="prettyprint lang-dart"><code>var l = &lt;int&gt;[];</code></pre>

<h3 id="expected_one_set_type_arguments">
<a class="anchor" href="#expected_one_set_type_arguments" aria-hidden="true"><span class="octicon octicon-link"></span></a>expected_one_set_type_arguments</h3>

<p><em>Set literals require one type argument or none, but {0} were found.</em></p>

<h4 id="description-104">Description</h4>

<p>The analyzer produces this diagnostic when a set literal has more than one
type argument.</p>

<h4 id="example-95">Example</h4>

<p>The following code produces this diagnostic because the set literal has
three type arguments when it can have at most one:</p>

<pre class="prettyprint lang-dart"><code>var s = <span class="highlight">&lt;int, String, int&gt;</span>{0, 'a', 1};</code></pre>

<h4 id="common-fixes-104">Common fixes</h4>

<p>Remove all except one of the type arguments:</p>

<pre class="prettyprint lang-dart"><code>var s = &lt;int&gt;{0, 1};</code></pre>

<h3 id="expected_two_map_type_arguments">
<a class="anchor" href="#expected_two_map_type_arguments" aria-hidden="true"><span class="octicon octicon-link"></span></a>expected_two_map_type_arguments</h3>

<p><em>Map literals require two type arguments or none, but {0} found.</em></p>

<h4 id="description-105">Description</h4>

<p>The analyzer produces this diagnostic when a map literal has either one or
more than two type arguments.</p>

<h4 id="example-96">Example</h4>

<p>The following code produces this diagnostic because the map literal has
three type arguments when it can have either two or zero:</p>

<pre class="prettyprint lang-dart"><code>var m = <span class="highlight">&lt;int, String, int&gt;</span>{};</code></pre>

<h4 id="common-fixes-105">Common fixes</h4>

<p>Remove all except two of the type arguments:</p>

<pre class="prettyprint lang-dart"><code>var m = &lt;int, String&gt;{};</code></pre>

<h3 id="export_internal_library">
<a class="anchor" href="#export_internal_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>export_internal_library</h3>

<p><em>The library ‘{0}’ is internal and can’t be exported.</em></p>

<h4 id="description-106">Description</h4>

<p>The analyzer produces this diagnostic when it finds an export whose <code class="language-plaintext highlighter-rouge">dart:</code>
URI references an internal library.</p>

<h4 id="example-97">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">_interceptors</code> is an
internal library:</p>

<pre class="prettyprint lang-dart"><code>export <span class="highlight">'dart:_interceptors'</span>;</code></pre>

<h4 id="common-fixes-106">Common fixes</h4>

<p>Remove the export directive.</p>

<h3 id="export_legacy_symbol">
<a class="anchor" href="#export_legacy_symbol" aria-hidden="true"><span class="octicon octicon-link"></span></a>export_legacy_symbol</h3>

<p><em>The symbol ‘{0}’ is defined in a legacy library, and can’t be re-exported from
a library with null safety enabled.</em></p>

<h4 id="description-107">Description</h4>

<p>The analyzer produces this diagnostic when a library that was opted in to
null safety exports another library, and the exported library is opted out
of null safety.</p>

<h4 id="example-98">Example</h4>

<p>Given a library that is opted out of null safety:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.8
String s;</code></pre>

<p>The following code produces this diagnostic because it’s exporting symbols
from an opted-out library:</p>

<pre class="prettyprint lang-dart"><code>export <span class="highlight">'optedOut.dart'</span>;

class C {}</code></pre>

<h4 id="common-fixes-107">Common fixes</h4>

<p>If you’re able to do so, migrate the exported library so that it doesn’t
need to opt out:</p>

<pre class="prettyprint lang-dart"><code>String? s;</code></pre>

<p>If you can’t migrate the library, then remove the export:</p>

<pre class="prettyprint lang-dart"><code>class C {}</code></pre>

<p>If the exported library (the one that is opted out) itself exports an
opted-in library, then it’s valid for your library to indirectly export the
symbols from the opted-in library. You can do so by adding a hide
combinator to the export directive in your library that hides all of the
names declared in the opted-out library.</p>

<h3 id="export_of_non_library">
<a class="anchor" href="#export_of_non_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>export_of_non_library</h3>

<p><em>The exported library ‘{0}’ can’t have a part-of directive.</em></p>

<h4 id="description-108">Description</h4>

<p>The analyzer produces this diagnostic when an export directive references a
part rather than a library.</p>

<h4 id="example-99">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">part.dart</code> containing</p>

<pre class="prettyprint lang-dart"><code>part of lib;</code></pre>

<p>The following code produces this diagnostic because the file <code class="language-plaintext highlighter-rouge">part.dart</code> is
a part, and only libraries can be exported:</p>

<pre class="prettyprint lang-dart"><code>library lib;

export <span class="highlight">'part.dart'</span>;</code></pre>

<h4 id="common-fixes-108">Common fixes</h4>

<p>Either remove the export directive, or change the URI to be the URI of the
library containing the part.</p>

<h3 id="expression_in_map">
<a class="anchor" href="#expression_in_map" aria-hidden="true"><span class="octicon octicon-link"></span></a>expression_in_map</h3>

<p><em>Expressions can’t be used in a map literal.</em></p>

<h4 id="description-109">Description</h4>

<p>The analyzer produces this diagnostic when the analyzer finds an
expression, rather than a map entry, in what appears to be a map literal.</p>

<h4 id="example-100">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>var map = &lt;String, int&gt;{'a': 0, 'b': 1, <span class="highlight">'c'</span>};</code></pre>

<h4 id="common-fixes-109">Common fixes</h4>

<p>If the expression is intended to compute either a key or a value in an
entry, fix the issue by replacing the expression with the key or the value.
For example:</p>

<pre class="prettyprint lang-dart"><code>var map = &lt;String, int&gt;{'a': 0, 'b': 1, 'c': 2};</code></pre>

<h3 id="extends_non_class">
<a class="anchor" href="#extends_non_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>extends_non_class</h3>

<p><em>Classes can only extend other classes.</em></p>

<h4 id="description-110">Description</h4>

<p>The analyzer produces this diagnostic when an <code class="language-plaintext highlighter-rouge">extends</code> clause contains a
name that is declared to be something other than a class.</p>

<h4 id="example-101">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is declared to be a
function:</p>

<pre class="prettyprint lang-dart"><code>void f() {}

class C extends <span class="highlight">f</span> {}</code></pre>

<h4 id="common-fixes-110">Common fixes</h4>

<p>If you want the class to extend a class other than <code class="language-plaintext highlighter-rouge">Object</code>, then replace
the name in the <code class="language-plaintext highlighter-rouge">extends</code> clause with the name of that class:</p>

<pre class="prettyprint lang-dart"><code>void f() {}

class C extends B {}

class B {}</code></pre>

<p>If you want the class to extend <code class="language-plaintext highlighter-rouge">Object</code>, then remove the <code class="language-plaintext highlighter-rouge">extends</code> clause:</p>

<pre class="prettyprint lang-dart"><code>void f() {}

class C {}</code></pre>

<h3 id="extension_as_expression">
<a class="anchor" href="#extension_as_expression" aria-hidden="true"><span class="octicon octicon-link"></span></a>extension_as_expression</h3>

<p><em>Extension ‘{0}’ can’t be used as an expression.</em></p>

<h4 id="description-111">Description</h4>

<p>The analyzer produces this diagnostic when the name of an extension is used
in an expression other than in an extension override or to qualify an
access to a static member of the extension. Because classes define a type,
the name of a class can be used to refer to the instance of <code class="language-plaintext highlighter-rouge">Type</code>
representing the type of the class. Extensions, on the other hand, don’t
define a type and can’t be used as a type literal.</p>

<h4 id="example-102">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">E</code> is an extension:</p>

<pre class="prettyprint lang-dart"><code>extension E on int {
  static String m() =&gt; '';
}

var x = <span class="highlight">E</span>;</code></pre>

<h4 id="common-fixes-111">Common fixes</h4>

<p>Replace the name of the extension with a name that can be referenced, such
as a static member defined on the extension:</p>

<pre class="prettyprint lang-dart"><code>extension E on int {
  static String m() =&gt; '';
}

var x = E.m();</code></pre>

<h3 id="extension_conflicting_static_and_instance">
<a class="anchor" href="#extension_conflicting_static_and_instance" aria-hidden="true"><span class="octicon octicon-link"></span></a>extension_conflicting_static_and_instance</h3>

<p><em>An extension can’t define static member ‘{0}’ and an instance member with the
same name.</em></p>

<h4 id="description-112">Description</h4>

<p>The analyzer produces this diagnostic when an extension declaration
contains both an instance member and a static member that have the same
name. The instance member and the static member can’t have the same name
because it’s unclear which member is being referenced by an unqualified use
of the name within the body of the extension.</p>

<h4 id="example-103">Example</h4>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">a</code> is being
used for two different members:</p>

<pre class="prettyprint lang-dart"><code>extension E on Object {
  int get a =&gt; 0;
  static int <span class="highlight">a</span>() =&gt; 0;
}</code></pre>

<h4 id="common-fixes-112">Common fixes</h4>

<p>Rename or remove one of the members:</p>

<pre class="prettyprint lang-dart"><code>extension E on Object {
  int get a =&gt; 0;
  static int b() =&gt; 0;
}</code></pre>

<h3 id="extension_declares_abstract_member">
<a class="anchor" href="#extension_declares_abstract_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>extension_declares_abstract_member</h3>

<p><em>Extensions can’t declare abstract members.</em></p>

<h4 id="description-113">Description</h4>

<p>The analyzer produces this diagnostic when an abstract declaration is
declared in an extension. Extensions can declare only concrete members.</p>

<h4 id="example-104">Example</h4>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">a</code> doesn’t
have a body:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  int <span class="highlight">a</span>();
}</code></pre>

<h4 id="common-fixes-113">Common fixes</h4>

<p>Either provide an implementation for the member or remove it.</p>

<h3 id="extension_declares_constructor">
<a class="anchor" href="#extension_declares_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>extension_declares_constructor</h3>

<p><em>Extensions can’t declare constructors.</em></p>

<h4 id="description-114">Description</h4>

<p>The analyzer produces this diagnostic when a constructor declaration is
found in an extension. It isn’t valid to define a constructor because
extensions aren’t classes, and it isn’t possible to create an instance of
an extension.</p>

<h4 id="example-105">Example</h4>

<p>The following code produces this diagnostic because there is a constructor
declaration in <code class="language-plaintext highlighter-rouge">E</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  <span class="highlight">E</span>() : super();
}</code></pre>

<h4 id="common-fixes-114">Common fixes</h4>

<p>Remove the constructor or replace it with a static method.</p>

<h3 id="extension_declares_instance_field">
<a class="anchor" href="#extension_declares_instance_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>extension_declares_instance_field</h3>

<p><em>Extensions can’t declare instance fields</em></p>

<h4 id="description-115">Description</h4>

<p>The analyzer produces this diagnostic when an instance field declaration is
found in an extension. It isn’t valid to define an instance field because
extensions can only add behavior, not state.</p>

<h4 id="example-106">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">s</code> is an instance
field:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String <span class="highlight">s</span>;
}</code></pre>

<h4 id="common-fixes-115">Common fixes</h4>

<p>Remove the field, make it a static field, or convert it to be a getter,
setter, or method.</p>

<h3 id="extension_declares_member_of_object">
<a class="anchor" href="#extension_declares_member_of_object" aria-hidden="true"><span class="octicon octicon-link"></span></a>extension_declares_member_of_object</h3>

<p><em>Extensions can’t declare members with the same name as a member declared by
‘Object’.</em></p>

<h4 id="description-116">Description</h4>

<p>The analyzer produces this diagnostic when an extension declaration
declares a member with the same name as a member declared in the class
<code class="language-plaintext highlighter-rouge">Object</code>. Such a member can never be used because the member in <code class="language-plaintext highlighter-rouge">Object</code> is
always found first.</p>

<h4 id="example-107">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">toString</code> is defined
by <code class="language-plaintext highlighter-rouge">Object</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String <span class="highlight">toString</span>() =&gt; this;
}</code></pre>

<h4 id="common-fixes-116">Common fixes</h4>

<p>Remove the member or rename it so that the name doesn’t conflict with the
member in <code class="language-plaintext highlighter-rouge">Object</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String displayString() =&gt; this;
}</code></pre>

<h3 id="extension_override_access_to_static_member">
<a class="anchor" href="#extension_override_access_to_static_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>extension_override_access_to_static_member</h3>

<p><em>An extension override can’t be used to access a static member from an
extension.</em></p>

<h4 id="description-117">Description</h4>

<p>The analyzer produces this diagnostic when an extension override is the
receiver of the invocation of a static member. Similar to static members in
classes, the static members of an extension should be accessed using the
name of the extension, not an extension override.</p>

<h4 id="example-108">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">m</code> is static:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  static void m() {}
}

void f() {
  E('').<span class="highlight">m</span>();
}</code></pre>

<h4 id="common-fixes-117">Common fixes</h4>

<p>Replace the extension override with the name of the extension:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  static void m() {}
}

void f() {
  E.m();
}</code></pre>

<h3 id="extension_override_argument_not_assignable">
<a class="anchor" href="#extension_override_argument_not_assignable" aria-hidden="true"><span class="octicon octicon-link"></span></a>extension_override_argument_not_assignable</h3>

<p><em>The type of the argument to the extension override ‘{0}’ isn’t assignable to
the extended type ‘{1}’.</em></p>

<h4 id="description-118">Description</h4>

<p>The analyzer produces this diagnostic when the argument to an extension
override isn’t assignable to the type being extended by the extension.</p>

<h4 id="example-109">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">3</code> isn’t a <code class="language-plaintext highlighter-rouge">String</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  void method() {}
}

void f() {
  E(<span class="highlight">3</span>).method();
}</code></pre>

<h4 id="common-fixes-118">Common fixes</h4>

<p>If you’re using the correct extension, then update the argument to have the
correct type:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  void method() {}
}

void f() {
  E(3.toString()).method();
}</code></pre>

<p>If there’s a different extension that’s valid for the type of the argument,
then either replace the name of the extension or unwrap the argument so
that the correct extension is found.</p>

<h3 id="extension_override_without_access">
<a class="anchor" href="#extension_override_without_access" aria-hidden="true"><span class="octicon octicon-link"></span></a>extension_override_without_access</h3>

<p><em>An extension override can only be used to access instance members.</em></p>

<h4 id="description-119">Description</h4>

<p>The analyzer produces this diagnostic when an extension override is found
that isn’t being used to access one of the members of the extension. The
extension override syntax doesn’t have any runtime semantics; it only
controls which member is selected at compile time.</p>

<h4 id="example-110">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">E(i)</code> isn’t an
expression:</p>

<pre class="prettyprint lang-dart"><code>extension E on int {
  int get a =&gt; 0;
}

void f(int i) {
  print(<span class="highlight">E(i)</span>);
}</code></pre>

<h4 id="common-fixes-119">Common fixes</h4>

<p>If you want to invoke one of the members of the extension, then add the
invocation:</p>

<pre class="prettyprint lang-dart"><code>extension E on int {
  int get a =&gt; 0;
}

void f(int i) {
  print(E(i).a);
}</code></pre>

<p>If you don’t want to invoke a member, then unwrap the argument:</p>

<pre class="prettyprint lang-dart"><code>extension E on int {
  int get a =&gt; 0;
}

void f(int i) {
  print(i);
}</code></pre>

<h3 id="extension_override_with_cascade">
<a class="anchor" href="#extension_override_with_cascade" aria-hidden="true"><span class="octicon octicon-link"></span></a>extension_override_with_cascade</h3>

<p><em>Extension overrides have no value so they can’t be used as the receiver of a
cascade expression.</em></p>

<h4 id="description-120">Description</h4>

<p>The analyzer produces this diagnostic when an extension override is used as
the receiver of a cascade expression. The value of a cascade expression
<code class="language-plaintext highlighter-rouge">e..m</code> is the value of the receiver <code class="language-plaintext highlighter-rouge">e</code>, but extension overrides aren’t
expressions and don’t have a value.</p>

<h4 id="example-111">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">E(3)</code> isn’t an
expression:</p>

<pre class="prettyprint lang-dart"><code>extension E on int {
  void m() {}
}
f() {
  <span class="highlight">E</span>(3)..m();
}</code></pre>

<h4 id="common-fixes-120">Common fixes</h4>

<p>Use <code class="language-plaintext highlighter-rouge">.</code> rather than <code class="language-plaintext highlighter-rouge">..</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on int {
  void m() {}
}
f() {
  E(3).m();
}</code></pre>

<p>If there are multiple cascaded accesses, you’ll need to duplicate the
extension override for each one.</p>

<h3 id="external_with_initializer">
<a class="anchor" href="#external_with_initializer" aria-hidden="true"><span class="octicon octicon-link"></span></a>external_with_initializer</h3>

<p><em>External fields can’t have initializers.</em></p>

<p><em>External variables can’t have initializers.</em></p>

<h4 id="description-121">Description</h4>

<p>The analyzer produces this diagnostic when a field or variable marked with
the keyword <code class="language-plaintext highlighter-rouge">external</code> has an initializer, or when an external field is
initialized in a constructor.</p>

<h4 id="examples-9">Examples</h4>

<p>The following code produces this diagnostic because the external field <code class="language-plaintext highlighter-rouge">x</code>
is assigned a value in an initializer:</p>

<pre class="prettyprint lang-dart"><code>class C {
  external int x;
  C() : <span class="highlight">x</span> = 0;
}</code></pre>

<p>The following code produces this diagnostic because the external field <code class="language-plaintext highlighter-rouge">x</code>
has an initializer:</p>

<pre class="prettyprint lang-dart"><code>class C {
  external final int <span class="highlight">x</span> = 0;
}</code></pre>

<p>The following code produces this diagnostic because the external top level
variable <code class="language-plaintext highlighter-rouge">x</code> has an initializer:</p>

<pre class="prettyprint lang-dart"><code>external final int <span class="highlight">x</span> = 0;</code></pre>

<h4 id="common-fixes-121">Common fixes</h4>

<p>Remove the initializer:</p>

<pre class="prettyprint lang-dart"><code>class C {
  external final int x;
}</code></pre>

<h3 id="extra_annotation_on_struct_field">
<a class="anchor" href="#extra_annotation_on_struct_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>extra_annotation_on_struct_field</h3>

<p><em>Fields in a struct class must have exactly one annotation indicating the native
type.</em></p>

<h4 id="description-122">Description</h4>

<p>The analyzer produces this diagnostic when a field in a subclass of
<code class="language-plaintext highlighter-rouge">Struct</code> has more than one annotation describing the native type of the
field.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-112">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">x</code> has two
annotations describing the native type of the field:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Int32()
  <span class="highlight">@Int16()</span>
  external int x;
}</code></pre>

<h4 id="common-fixes-122">Common fixes</h4>

<p>Remove all but one of the annotations:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';
class C extends Struct {
  @Int32()
  external int x;
}</code></pre>

<h3 id="extra_positional_arguments">
<a class="anchor" href="#extra_positional_arguments" aria-hidden="true"><span class="octicon octicon-link"></span></a>extra_positional_arguments</h3>

<p><em>Too many positional arguments: {0} expected, but {1} found.</em></p>

<h4 id="description-123">Description</h4>

<p>The analyzer produces this diagnostic when a method or function invocation
has more positional arguments than the method or function allows.</p>

<h4 id="example-113">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> defines 2
parameters but is invoked with 3 arguments:</p>

<pre class="prettyprint lang-dart"><code>void f(int a, int b) {}
void g() {
  f(1, 2, <span class="highlight">3</span>);
}</code></pre>

<h4 id="common-fixes-123">Common fixes</h4>

<p>Remove the arguments that don’t correspond to parameters:</p>

<pre class="prettyprint lang-dart"><code>void f(int a, int b) {}
void g() {
  f(1, 2);
}</code></pre>

<h3 id="extra_positional_arguments_could_be_named">
<a class="anchor" href="#extra_positional_arguments_could_be_named" aria-hidden="true"><span class="octicon octicon-link"></span></a>extra_positional_arguments_could_be_named</h3>

<p><em>Too many positional arguments: {0} expected, but {1} found.</em></p>

<h4 id="description-124">Description</h4>

<p>The analyzer produces this diagnostic when a method or function invocation
has more positional arguments than the method or function allows, but the
method or function defines named parameters.</p>

<h4 id="example-114">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> defines 2
positional parameters but has a named parameter that could be used for the
third argument:</p>

<pre class="prettyprint lang-dart"><code>void f(int a, int b, {int c}) {}
void g() {
  f(1, 2, <span class="highlight">3</span>);
}</code></pre>

<h4 id="common-fixes-124">Common fixes</h4>

<p>If some of the arguments should be values for named parameters, then add
the names before the arguments:</p>

<pre class="prettyprint lang-dart"><code>void f(int a, int b, {int c}) {}
void g() {
  f(1, 2, c: 3);
}</code></pre>

<p>Otherwise, remove the arguments that don’t correspond to positional
parameters:</p>

<pre class="prettyprint lang-dart"><code>void f(int a, int b, {int c}) {}
void g() {
  f(1, 2);
}</code></pre>

<h3 id="extra_size_annotation_carray">
<a class="anchor" href="#extra_size_annotation_carray" aria-hidden="true"><span class="octicon octicon-link"></span></a>extra_size_annotation_carray</h3>

<p><em>‘Array’s must have exactly one ‘Array’ annotation.</em></p>

<h4 id="description-125">Description</h4>

<p>The analyzer produces this diagnostic when a field in a subclass of
<code class="language-plaintext highlighter-rouge">Struct</code> has more than one annotation describing the size of the native
array.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-115">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">a0</code> has two
annotations that specify the size of the native array:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Array(4)
  <span class="highlight">@Array(8)</span>
  external Array&lt;Uint8&gt; a0;
}</code></pre>

<h4 id="common-fixes-125">Common fixes</h4>

<p>Remove all but one of the annotations:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Array(8)
  external Array&lt;Uint8&gt; a0;
}</code></pre>

<h3 id="field_initialized_by_multiple_initializers">
<a class="anchor" href="#field_initialized_by_multiple_initializers" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_initialized_by_multiple_initializers</h3>

<p><em>The field ‘{0}’ can’t be initialized twice in the same constructor.</em></p>

<h4 id="description-126">Description</h4>

<p>The analyzer produces this diagnostic when the initializer list of a
constructor initializes a field more than once. There is no value to allow
both initializers because only the last value is preserved.</p>

<h4 id="example-116">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">f</code> is being
initialized twice:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C() : f = 0, <span class="highlight">f</span> = 1;
}</code></pre>

<h4 id="common-fixes-126">Common fixes</h4>

<p>Remove one of the initializers:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C() : f = 0;
}</code></pre>

<h3 id="field_initialized_in_initializer_and_declaration">
<a class="anchor" href="#field_initialized_in_initializer_and_declaration" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_initialized_in_initializer_and_declaration</h3>

<p><em>Fields can’t be initialized in the constructor if they are final and were
already initialized at their declaration.</em></p>

<h4 id="description-127">Description</h4>

<p>The analyzer produces this diagnostic when a final field is initialized in
both the declaration of the field and in an initializer in a constructor.
Final fields can only be assigned once, so it can’t be initialized in both
places.</p>

<h4 id="example-117">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is :</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int f = 0;
  C() : <span class="highlight">f</span> = 1;
}</code></pre>

<h4 id="common-fixes-127">Common fixes</h4>

<p>If the initialization doesn’t depend on any values passed to the
constructor, and if all of the constructors need to initialize the field to
the same value, then remove the initializer from the constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int f = 0;
  C();
}</code></pre>

<p>If the initialization depends on a value passed to the constructor, or if
different constructors need to initialize the field differently, then
remove the initializer in the field’s declaration:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int f;
  C() : f = 1;
}</code></pre>

<h3 id="field_initialized_in_parameter_and_initializer">
<a class="anchor" href="#field_initialized_in_parameter_and_initializer" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_initialized_in_parameter_and_initializer</h3>

<p><em>Fields can’t be initialized in both the parameter list and the initializers.</em></p>

<h4 id="description-128">Description</h4>

<p>The analyzer produces this diagnostic when a field is initialized in both
the parameter list and in the initializer list of a constructor.</p>

<h4 id="example-118">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">f</code> is
initialized both by an initializing formal parameter and in the
initializer list:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(this.f) : <span class="highlight">f</span> = 0;
}</code></pre>

<h4 id="common-fixes-128">Common fixes</h4>

<p>If the field should be initialized by the parameter, then remove the
initialization in the initializer list:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(this.f);
}</code></pre>

<p>If the field should be initialized in the initializer list and the
parameter isn’t needed, then remove the parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C() : f = 0;
}</code></pre>

<p>If the field should be initialized in the initializer list and the
parameter is needed, then make it a normal parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(int g) : f = g * 2;
}</code></pre>

<h3 id="field_initializer_factory_constructor">
<a class="anchor" href="#field_initializer_factory_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_initializer_factory_constructor</h3>

<p><em>Initializing formal parameters can’t be used in factory constructors.</em></p>

<h4 id="description-129">Description</h4>

<p>The analyzer produces this diagnostic when a factory constructor has an
initializing formal parameter. Factory constructors can’t assign values to
fields because no instance is created; hence, there is no field to assign.</p>

<h4 id="example-119">Example</h4>

<p>The following code produces this diagnostic because the factory constructor
uses an initializing formal parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int? f;

  factory C(<span class="highlight">this.f</span>) =&gt; throw 0;
}</code></pre>

<h4 id="common-fixes-129">Common fixes</h4>

<p>Replace the initializing formal parameter with a normal parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int? f;

  factory C(int f) =&gt; throw 0;
}</code></pre>

<h3 id="field_initializer_in_struct">
<a class="anchor" href="#field_initializer_in_struct" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_initializer_in_struct</h3>

<p><em>Constructors in subclasses of ‘Struct’ and ‘Union’ can’t have field
initializers.</em></p>

<h4 id="description-130">Description</h4>

<p>The analyzer produces this diagnostic when a constructor in a subclass of
either <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code> has one or more field initializers.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-120">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code> has a
constructor with an initializer for the field <code class="language-plaintext highlighter-rouge">f</code>:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.9
import 'dart:ffi';

class C extends Struct {
  @Int32()
  int f;

  C() : <span class="highlight">f = 0</span>;
}</code></pre>

<h4 id="common-fixes-130">Common fixes</h4>

<p>Remove the field initializer:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.9
import 'dart:ffi';

class C extends Struct {
  @Int32()
  int f;

  C();
}</code></pre>

<h3 id="field_initializer_not_assignable">
<a class="anchor" href="#field_initializer_not_assignable" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_initializer_not_assignable</h3>

<p><em>The initializer type ‘{0}’ can’t be assigned to the field type ‘{1}’ in a const
constructor.</em></p>

<p><em>The initializer type ‘{0}’ can’t be assigned to the field type ‘{1}’.</em></p>

<h4 id="description-131">Description</h4>

<p>The analyzer produces this diagnostic when the initializer list of a
constructor initializes a field to a value that isn’t assignable to the
field.</p>

<h4 id="example-121">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">0</code> has the type <code class="language-plaintext highlighter-rouge">int</code>,
and an <code class="language-plaintext highlighter-rouge">int</code> can’t be assigned to a field of type <code class="language-plaintext highlighter-rouge">String</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  String s;

  C() : s = <span class="highlight">0</span>;
}</code></pre>

<h4 id="common-fixes-131">Common fixes</h4>

<p>If the type of the field is correct, then change the value assigned to it
so that the value has a valid type:</p>

<pre class="prettyprint lang-dart"><code>class C {
  String s;

  C() : s = '0';
}</code></pre>

<p>If the type of the value is correct, then change the type of the field to
allow the assignment:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int s;

  C() : s = 0;
}</code></pre>

<h3 id="field_initializer_outside_constructor">
<a class="anchor" href="#field_initializer_outside_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_initializer_outside_constructor</h3>

<p><em>Field formal parameters can only be used in a constructor.</em></p>

<p><em>Initializing formal parameters can only be used in constructors.</em></p>

<h4 id="description-132">Description</h4>

<p>The analyzer produces this diagnostic when an initializing formal
parameter is used in the parameter list for anything other than a
constructor.</p>

<h4 id="example-122">Example</h4>

<p>The following code produces this diagnostic because the initializing
formal parameter <code class="language-plaintext highlighter-rouge">this.x</code> is being used in the method <code class="language-plaintext highlighter-rouge">m</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  int x = 0;

  m([<span class="highlight">this.x</span> = 0]) {}
}</code></pre>

<h4 id="common-fixes-132">Common fixes</h4>

<p>Replace the initializing formal parameter with a normal parameter and
assign the field within the body of the method:</p>

<pre class="prettyprint lang-dart"><code>class A {
  int x = 0;

  m([int x = 0]) {
    this.x = x;
  }
}</code></pre>

<h3 id="field_initializer_redirecting_constructor">
<a class="anchor" href="#field_initializer_redirecting_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_initializer_redirecting_constructor</h3>

<p><em>The redirecting constructor can’t have a field initializer.</em></p>

<h4 id="description-133">Description</h4>

<p>The analyzer produces this diagnostic when a redirecting constructor
initializes a field in the object. This isn’t allowed because the instance
that has the field hasn’t been created at the point at which it should be
initialized.</p>

<h4 id="examples-10">Examples</h4>

<p>The following code produces this diagnostic because the constructor
<code class="language-plaintext highlighter-rouge">C.zero</code>, which redirects to the constructor <code class="language-plaintext highlighter-rouge">C</code>, has an initializing
formal parameter that initializes the field <code class="language-plaintext highlighter-rouge">f</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(this.f);

  C.zero(<span class="highlight">this.f</span>) : this(f);
}</code></pre>

<p>The following code produces this diagnostic because the constructor
<code class="language-plaintext highlighter-rouge">C.zero</code>, which redirects to the constructor <code class="language-plaintext highlighter-rouge">C</code>, has an initializer that
initializes the field <code class="language-plaintext highlighter-rouge">f</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(this.f);

  C.zero() : <span class="highlight">f = 0</span>, this(1);
}</code></pre>

<h4 id="common-fixes-133">Common fixes</h4>

<p>If the initialization is done by an initializing formal parameter, then
use a normal parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(this.f);

  C.zero(int f) : this(f);
}</code></pre>

<p>If the initialization is done in an initializer, then remove the
initializer:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(this.f);

  C.zero() : this(0);
}</code></pre>

<h3 id="field_initializing_formal_not_assignable">
<a class="anchor" href="#field_initializing_formal_not_assignable" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_initializing_formal_not_assignable</h3>

<p><em>The parameter type ‘{0}’ is incompatible with the field type ‘{1}’.</em></p>

<h4 id="description-134">Description</h4>

<p>The analyzer produces this diagnostic when the type of an initializing
formal parameter isn’t assignable to the type of the field being
initialized.</p>

<h4 id="example-123">Example</h4>

<p>The following code produces this diagnostic because the initializing
formal parameter has the type <code class="language-plaintext highlighter-rouge">String</code>, but the type of the field is
<code class="language-plaintext highlighter-rouge">int</code>. The parameter must have a type that is a subtype of the field’s
type.</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(<span class="highlight">String this.f</span>);
}</code></pre>

<h4 id="common-fixes-134">Common fixes</h4>

<p>If the type of the field is incorrect, then change the type of the field to
match the type of the parameter, and consider removing the type from the
parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  String f;

  C(this.f);
}</code></pre>

<p>If the type of the parameter is incorrect, then remove the type of the
parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(this.f);
}</code></pre>

<p>If the types of both the field and the parameter are correct, then use an
initializer rather than an initializing formal parameter to convert the
parameter value into a value of the correct type:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int f;

  C(String s) : f = int.parse(s);
}</code></pre>

<h3 id="field_in_struct_with_initializer">
<a class="anchor" href="#field_in_struct_with_initializer" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_in_struct_with_initializer</h3>

<p><em>Fields in subclasses of ‘Struct’ and ‘Union’ can’t have initializers.</em></p>

<h4 id="description-135">Description</h4>

<p>The analyzer produces this diagnostic when a field in a subclass of
<code class="language-plaintext highlighter-rouge">Struct</code> has an initializer.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-124">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">p</code> has an
initializer:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.9
import 'dart:ffi';

class C extends Struct {
  Pointer <span class="highlight">p</span> = nullptr;
}</code></pre>

<h4 id="common-fixes-135">Common fixes</h4>

<p>Remove the initializer:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.9
import 'dart:ffi';

class C extends Struct {
  Pointer p;
}</code></pre>

<h3 id="field_must_be_external_in_struct">
<a class="anchor" href="#field_must_be_external_in_struct" aria-hidden="true"><span class="octicon octicon-link"></span></a>field_must_be_external_in_struct</h3>

<p><em>Fields of ‘Struct’ and ‘Union’ subclasses must be marked external.</em></p>

<h4 id="description-136">Description</h4>

<p>The analyzer produces this diagnostic when a field in a subclass of either
<code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code> isn’t marked as being <code class="language-plaintext highlighter-rouge">external</code>.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-125">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">a</code> isn’t
marked as being <code class="language-plaintext highlighter-rouge">external</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Int16()
  int <span class="highlight">a</span>;
}</code></pre>

<h4 id="common-fixes-136">Common fixes</h4>

<p>Add the required <code class="language-plaintext highlighter-rouge">external</code> modifier:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Int16()
  external int a;
}</code></pre>

<h3 id="final_initialized_in_declaration_and_constructor">
<a class="anchor" href="#final_initialized_in_declaration_and_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>final_initialized_in_declaration_and_constructor</h3>

<p><em>‘{0}’ is final and was given a value when it was declared, so it can’t be set
to a new value.</em></p>

<h4 id="description-137">Description</h4>

<p>The analyzer produces this diagnostic when a final field is initialized
twice: once where it’s declared and once by a constructor’s parameter.</p>

<h4 id="example-126">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">f</code> is
initialized twice:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int f = 0;

  C(this.<span class="highlight">f</span>);
}</code></pre>

<h4 id="common-fixes-137">Common fixes</h4>

<p>If the field should have the same value for all instances, then remove the
initialization in the parameter list:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int f = 0;

  C();
}</code></pre>

<p>If the field can have different values in different instances, then remove
the initialization in the declaration:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int f;

  C(this.f);
}</code></pre>

<h3 id="final_not_initialized">
<a class="anchor" href="#final_not_initialized" aria-hidden="true"><span class="octicon octicon-link"></span></a>final_not_initialized</h3>

<p><em>The final variable ‘{0}’ must be initialized.</em></p>

<h4 id="description-138">Description</h4>

<p>The analyzer produces this diagnostic when a final field or variable isn’t
initialized.</p>

<h4 id="example-127">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> doesn’t have an
initializer:</p>

<pre class="prettyprint lang-dart"><code>final <span class="highlight">x</span>;</code></pre>

<h4 id="common-fixes-138">Common fixes</h4>

<p>For variables and static fields, you can add an initializer:</p>

<pre class="prettyprint lang-dart"><code>final x = 0;</code></pre>

<p>For instance fields, you can add an initializer as shown in the previous
example, or you can initialize the field in every constructor. You can
initialize the field by using an initializing formal parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int x;
  C(this.x);
}</code></pre>

<p>You can also initialize the field by using an initializer in the
constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final int x;
  C(int y) : x = y * 2;
}</code></pre>

<h3 id="final_not_initialized_constructor">
<a class="anchor" href="#final_not_initialized_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>final_not_initialized_constructor</h3>

<p><em>All final variables must be initialized, but ‘{0}’ and ‘{1}’ aren’t.</em></p>

<p><em>All final variables must be initialized, but ‘{0}’ isn’t.</em></p>

<p><em>All final variables must be initialized, but ‘{0}’, ‘{1}’, and {2} others
aren’t.</em></p>

<h4 id="description-139">Description</h4>

<p>The analyzer produces this diagnostic when a class defines one or more
final instance fields without initializers and has at least one constructor
that doesn’t initialize those fields. All final instance fields must be
initialized when the instance is created, either by the field’s initializer
or by the constructor.</p>

<h4 id="example-128">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String value;

  <span class="highlight">C</span>();
}</code></pre>

<h4 id="common-fixes-139">Common fixes</h4>

<p>If the value should be passed in to the constructor directly, then use an
initializing formal parameter to initialize the field <code class="language-plaintext highlighter-rouge">value</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String value;

  C(this.value);
}</code></pre>

<p>If the value should be computed indirectly from a value provided by the
caller, then add a parameter and include an initializer:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String value;

  C(Object o) : value = o.toString();
}</code></pre>

<p>If the value of the field doesn’t depend on values that can be passed to
the constructor, then add an initializer for the field as part of the field
declaration:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String value = '';

  C();
}</code></pre>

<p>If the value of the field doesn’t depend on values that can be passed to
the constructor but different constructors need to initialize it to
different values, then add an initializer for the field in the initializer
list:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String value;

  C() : value = '';

  C.named() : value = 'c';
}</code></pre>

<p>However, if the value is the same for all instances, then consider using a
static field instead of an instance field:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static const String value = '';

  C();
}</code></pre>

<h3 id="flutter_field_not_map">
<a class="anchor" href="#flutter_field_not_map" aria-hidden="true"><span class="octicon octicon-link"></span></a>flutter_field_not_map</h3>

<p><em>The value of the ‘flutter’ field is expected to be a map.</em></p>

<h4 id="description-140">Description</h4>

<p>The analyzer produces this diagnostic when the value of the <code class="language-plaintext highlighter-rouge">flutter</code> key
isn’t a map.</p>

<h4 id="example-129">Example</h4>

<p>The following code produces this diagnostic because the value of the
top-level <code class="language-plaintext highlighter-rouge">flutter</code> key is a string:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">flutter</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div></div>

<h4 id="common-fixes-140">Common fixes</h4>

<p>If you need to specify Flutter-specific options, then change the value to
be a map:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">flutter</span><span class="pi">:</span>
  <span class="na">uses-material-design</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div></div>

<p>If you don’t need to specify Flutter-specific options, then remove the
<code class="language-plaintext highlighter-rouge">flutter</code> key:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
</code></pre></div></div>

<h3 id="for_in_of_invalid_element_type">
<a class="anchor" href="#for_in_of_invalid_element_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>for_in_of_invalid_element_type</h3>

<p><em>The type ‘{0}’ used in the ‘for’ loop must implement ‘{1}’ with a type argument
that can be assigned to ‘{2}’.</em></p>

<h4 id="description-141">Description</h4>

<p>The analyzer produces this diagnostic when the <code class="language-plaintext highlighter-rouge">Iterable</code> or <code class="language-plaintext highlighter-rouge">Stream</code> in a
for-in loop has an element type that can’t be assigned to the loop
variable.</p>

<h4 id="example-130">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">&lt;String&gt;[]</code> has an
element type of <code class="language-plaintext highlighter-rouge">String</code>, and <code class="language-plaintext highlighter-rouge">String</code> can’t be assigned to the type of <code class="language-plaintext highlighter-rouge">e</code>
(<code class="language-plaintext highlighter-rouge">int</code>):</p>

<pre class="prettyprint lang-dart"><code>void f() {
  for (int e in <span class="highlight">&lt;String&gt;[]</span>) {
    print(e);
  }
}</code></pre>

<h4 id="common-fixes-141">Common fixes</h4>

<p>If the type of the loop variable is correct, then update the type of the
iterable:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  for (int e in &lt;int&gt;[]) {
    print(e);
  }
}</code></pre>

<p>If the type of the iterable is correct, then update the type of the loop
variable:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  for (String e in &lt;String&gt;[]) {
    print(e);
  }
}</code></pre>

<h3 id="for_in_of_invalid_type">
<a class="anchor" href="#for_in_of_invalid_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>for_in_of_invalid_type</h3>

<p><em>The type ‘{0}’ used in the ‘for’ loop must implement {1}.</em></p>

<h4 id="description-142">Description</h4>

<p>The analyzer produces this diagnostic when the expression following <code class="language-plaintext highlighter-rouge">in</code> in
a for-in loop has a type that isn’t a subclass of <code class="language-plaintext highlighter-rouge">Iterable</code>.</p>

<h4 id="example-131">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">m</code> is a <code class="language-plaintext highlighter-rouge">Map</code>, and
<code class="language-plaintext highlighter-rouge">Map</code> isn’t a subclass of <code class="language-plaintext highlighter-rouge">Iterable</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(Map&lt;String, String&gt; m) {
  for (String s in <span class="highlight">m</span>) {
    print(s);
  }
}</code></pre>

<h4 id="common-fixes-142">Common fixes</h4>

<p>Replace the expression with one that produces an iterable value:</p>

<pre class="prettyprint lang-dart"><code>void f(Map&lt;String, String&gt; m) {
  for (String s in m.values) {
    print(s);
  }
}</code></pre>

<h3 id="for_in_with_const_variable">
<a class="anchor" href="#for_in_with_const_variable" aria-hidden="true"><span class="octicon octicon-link"></span></a>for_in_with_const_variable</h3>

<p><em>A for-in loop variable can’t be a ‘const’.</em></p>

<h4 id="description-143">Description</h4>

<p>The analyzer produces this diagnostic when the loop variable declared in a
for-in loop is declared to be a <code class="language-plaintext highlighter-rouge">const</code>. The variable can’t be a <code class="language-plaintext highlighter-rouge">const</code>
because the value can’t be computed at compile time.</p>

<h4 id="example-132">Example</h4>

<p>The following code produces this diagnostic because the loop variable <code class="language-plaintext highlighter-rouge">x</code>
is declared to be a <code class="language-plaintext highlighter-rouge">const</code>:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  for (<span class="highlight">const</span> x in [0, 1, 2]) {
    print(x);
  }
}</code></pre>

<h4 id="common-fixes-143">Common fixes</h4>

<p>If there’s a type annotation, then remove the <code class="language-plaintext highlighter-rouge">const</code> modifier from the
declaration.</p>

<p>If there’s no type, then replace the <code class="language-plaintext highlighter-rouge">const</code> modifier with <code class="language-plaintext highlighter-rouge">final</code>, <code class="language-plaintext highlighter-rouge">var</code>,
or a type annotation:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  for (final x in [0, 1, 2]) {
    print(x);
  }
}</code></pre>

<h3 id="generic_method_type_instantiation_on_dynamic">
<a class="anchor" href="#generic_method_type_instantiation_on_dynamic" aria-hidden="true"><span class="octicon octicon-link"></span></a>generic_method_type_instantiation_on_dynamic</h3>

<p><em>A method tear-off on a receiver whose type is ‘dynamic’ can’t have type
arguments.</em></p>

<h4 id="description-144">Description</h4>

<p>The analyzer produces this diagnostic when an instance method is being torn
off from a receiver whose type is <code class="language-plaintext highlighter-rouge">dynamic</code>, and the tear-off includes type
arguments. Because the analyzer can’t know how many type parameters the
method has, or whether it has any type parameters, there’s no way it can
validate that the type arguments are correct. As a result, the type
arguments aren’t allowed.</p>

<h4 id="example-133">Example</h4>

<p>The following code produces this diagnostic because the type of <code class="language-plaintext highlighter-rouge">p</code> is
<code class="language-plaintext highlighter-rouge">dynamic</code> and the tear-off of <code class="language-plaintext highlighter-rouge">m</code> has type arguments:</p>

<pre class="prettyprint lang-dart"><code>void f(dynamic list) {
  <span class="highlight">list.fold</span>&lt;int&gt;;
}</code></pre>

<h4 id="common-fixes-144">Common fixes</h4>

<p>If you can use a more specific type than <code class="language-plaintext highlighter-rouge">dynamic</code>, then change the type of
the receiver:</p>

<pre class="prettyprint lang-dart"><code>void f(List&lt;Object&gt; list) {
  list.fold&lt;int&gt;;
}</code></pre>

<p>If you can’t use a more specific type, then remove the type arguments:</p>

<pre class="prettyprint lang-dart"><code>void f(dynamic list) {
  list.cast;
}</code></pre>

<h3 id="generic_struct_subclass">
<a class="anchor" href="#generic_struct_subclass" aria-hidden="true"><span class="octicon octicon-link"></span></a>generic_struct_subclass</h3>

<p><em>The class ‘{0}’ can’t extend ‘Struct’ or ‘Union’ because ‘{0}’ is generic.</em></p>

<h4 id="description-145">Description</h4>

<p>The analyzer produces this diagnostic when a subclass of either <code class="language-plaintext highlighter-rouge">Struct</code>
or <code class="language-plaintext highlighter-rouge">Union</code> has a type parameter.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-134">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">S</code> defines
the type parameter <code class="language-plaintext highlighter-rouge">T</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class <span class="highlight">S</span>&lt;T&gt; extends Struct {
  external Pointer notEmpty;
}</code></pre>

<h4 id="common-fixes-145">Common fixes</h4>

<p>Remove the type parameters from the class:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class S extends Struct {
  external Pointer notEmpty;
}</code></pre>

<h3 id="getter_not_subtype_setter_types">
<a class="anchor" href="#getter_not_subtype_setter_types" aria-hidden="true"><span class="octicon octicon-link"></span></a>getter_not_subtype_setter_types</h3>

<p><em>The return type of getter ‘{0}’ is ‘{1}’ which isn’t a subtype of the type
‘{2}’ of its setter ‘{3}’.</em></p>

<h4 id="description-146">Description</h4>

<p>The analyzer produces this diagnostic when the return type of a getter
isn’t a subtype of the type of the parameter of a setter with the same
name.</p>

<p>The subtype relationship is a requirement whether the getter and setter are
in the same class or whether one of them is in a superclass of the other.</p>

<h4 id="example-135">Example</h4>

<p>The following code produces this diagnostic because the return type of the
getter <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">num</code>, the parameter type of the setter <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">int</code>, and
<code class="language-plaintext highlighter-rouge">num</code> isn’t a subtype of <code class="language-plaintext highlighter-rouge">int</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  num get <span class="highlight">x</span> =&gt; 0;

  set x(int y) {}
}</code></pre>

<h4 id="common-fixes-146">Common fixes</h4>

<p>If the type of the getter is correct, then change the type of the setter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  num get x =&gt; 0;

  set x(num y) {}
}</code></pre>

<p>If the type of the setter is correct, then change the type of the getter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int get x =&gt; 0;

  set x(int y) {}
}</code></pre>

<h3 id="illegal_async_generator_return_type">
<a class="anchor" href="#illegal_async_generator_return_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>illegal_async_generator_return_type</h3>

<p>_Functions marked ‘async*’ must have a return type that is a supertype of
‘Stream<t>' for some type 'T'._</t></p>

<h4 id="description-147">Description</h4>

<p>The analyzer produces this diagnostic when the body of a function has the
<code class="language-plaintext highlighter-rouge">async*</code> modifier even though the return type of the function isn’t either
<code class="language-plaintext highlighter-rouge">Stream</code> or a supertype of <code class="language-plaintext highlighter-rouge">Stream</code>.</p>

<h4 id="example-136">Example</h4>

<p>The following code produces this diagnostic because the body of the
function <code class="language-plaintext highlighter-rouge">f</code> has the ‘async*’ modifier even though the return type <code class="language-plaintext highlighter-rouge">int</code>
isn’t a supertype of <code class="language-plaintext highlighter-rouge">Stream</code>:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">int</span> f() async* {}</code></pre>

<h4 id="common-fixes-147">Common fixes</h4>

<p>If the function should be asynchronous, then change the return type to be
either <code class="language-plaintext highlighter-rouge">Stream</code> or a supertype of <code class="language-plaintext highlighter-rouge">Stream</code>:</p>

<pre class="prettyprint lang-dart"><code>Stream&lt;int&gt; f() async* {}</code></pre>

<p>If the function should be synchronous, then remove the <code class="language-plaintext highlighter-rouge">async*</code> modifier:</p>

<pre class="prettyprint lang-dart"><code>int f() =&gt; 0;</code></pre>

<h3 id="illegal_async_return_type">
<a class="anchor" href="#illegal_async_return_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>illegal_async_return_type</h3>

<p><em>Functions marked ‘async’ must have a return type assignable to ‘Future’.</em></p>

<h4 id="description-148">Description</h4>

<p>The analyzer produces this diagnostic when the body of a function has the
<code class="language-plaintext highlighter-rouge">async</code> modifier even though the return type of the function isn’t
assignable to <code class="language-plaintext highlighter-rouge">Future</code>.</p>

<h4 id="example-137">Example</h4>

<p>The following code produces this diagnostic because the body of the
function <code class="language-plaintext highlighter-rouge">f</code> has the <code class="language-plaintext highlighter-rouge">async</code> modifier even though the return type isn’t
assignable to <code class="language-plaintext highlighter-rouge">Future</code>:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">int</span> f() async {
  return 0;
}</code></pre>

<h4 id="common-fixes-148">Common fixes</h4>

<p>If the function should be asynchronous, then change the return type to be
assignable to <code class="language-plaintext highlighter-rouge">Future</code>:</p>

<pre class="prettyprint lang-dart"><code>Future&lt;int&gt; f() async {
  return 0;
}</code></pre>

<p>If the function should be synchronous, then remove the <code class="language-plaintext highlighter-rouge">async</code> modifier:</p>

<pre class="prettyprint lang-dart"><code>int f() =&gt; 0;</code></pre>

<h3 id="illegal_concrete_enum_member">
<a class="anchor" href="#illegal_concrete_enum_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>illegal_concrete_enum_member</h3>

<p><em>A concrete instance member named ‘{0}’ can’t be declared in a class that
implements ‘Enum’.</em></p>

<p><em>A concrete instance member named ‘{0}’ can’t be inherited from ‘{1}’ in a class
that implements ‘Enum’.</em></p>

<h4 id="description-149">Description</h4>

<p>The analyzer produces this diagnostic when either an enum declaration, a
class that implements <code class="language-plaintext highlighter-rouge">Enum</code>, or a mixin with a superclass constraint of
<code class="language-plaintext highlighter-rouge">Enum</code>, declares or inherits a concrete instance member named either
<code class="language-plaintext highlighter-rouge">index</code>, <code class="language-plaintext highlighter-rouge">hashCode</code>, or <code class="language-plaintext highlighter-rouge">==</code>.</p>

<h4 id="examples-11">Examples</h4>

<p>The following code produces this diagnostic because the enum <code class="language-plaintext highlighter-rouge">E</code> declares
an instance getter named <code class="language-plaintext highlighter-rouge">index</code>:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  v;

  int get <span class="highlight">index</span> =&gt; 0;
}</code></pre>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code>, which
implements <code class="language-plaintext highlighter-rouge">Enum</code>, declares an instance field named <code class="language-plaintext highlighter-rouge">hashCode</code>:</p>

<pre class="prettyprint lang-dart"><code>abstract class C implements Enum {
  int <span class="highlight">hashCode</span> = 0;
}</code></pre>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code>, which
indirectly implements <code class="language-plaintext highlighter-rouge">Enum</code> through the class <code class="language-plaintext highlighter-rouge">A</code>, declares an instance
getter named <code class="language-plaintext highlighter-rouge">hashCode</code>:</p>

<pre class="prettyprint lang-dart"><code>abstract class A implements Enum {}

abstract class C implements A {
  int get <span class="highlight">hashCode</span> =&gt; 0;
}</code></pre>

<p>The following code produces this diagnostic because the mixin <code class="language-plaintext highlighter-rouge">M</code>, which
has <code class="language-plaintext highlighter-rouge">Enum</code> in the <code class="language-plaintext highlighter-rouge">on</code> clause, declares an explicit operator named <code class="language-plaintext highlighter-rouge">==</code>:</p>

<pre class="prettyprint lang-dart"><code>mixin M on Enum {
  bool operator <span class="highlight">==</span>(Object? other) =&gt; false;
}</code></pre>

<h4 id="common-fixes-149">Common fixes</h4>

<p>Rename the conflicting member:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  v;

  int get getIndex =&gt; 0;
}</code></pre>

<h3 id="illegal_enum_values">
<a class="anchor" href="#illegal_enum_values" aria-hidden="true"><span class="octicon octicon-link"></span></a>illegal_enum_values</h3>

<p><em>An instance member named ‘values’ can’t be declared in a class that implements
‘Enum’.</em></p>

<p><em>An instance member named ‘values’ can’t be inherited from ‘{0}’ in a class that
implements ‘Enum’.</em></p>

<h4 id="description-150">Description</h4>

<p>The analyzer produces this diagnostic when either a class that implements
<code class="language-plaintext highlighter-rouge">Enum</code> or a mixin with a superclass constraint of <code class="language-plaintext highlighter-rouge">Enum</code> has an instance
member named <code class="language-plaintext highlighter-rouge">values</code>.</p>

<h4 id="examples-12">Examples</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code>, which
implements <code class="language-plaintext highlighter-rouge">Enum</code>, declares an instance field named <code class="language-plaintext highlighter-rouge">values</code>:</p>

<pre class="prettyprint lang-dart"><code>abstract class C implements Enum {
  int get <span class="highlight">values</span> =&gt; 0;
}</code></pre>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">B</code>, which
implements <code class="language-plaintext highlighter-rouge">Enum</code>, inherits an instance method named <code class="language-plaintext highlighter-rouge">values</code> from <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  int values() =&gt; 0;
}

abstract class <span class="highlight">B</span> extends A implements Enum {}</code></pre>

<h4 id="common-fixes-150">Common fixes</h4>

<p>Change the name of the conflicting member:</p>

<pre class="prettyprint lang-dart"><code>abstract class C implements Enum {
  int get value =&gt; 0;
}</code></pre>

<h3 id="illegal_sync_generator_return_type">
<a class="anchor" href="#illegal_sync_generator_return_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>illegal_sync_generator_return_type</h3>

<p>_Functions marked ‘sync*’ must have a return type that is a supertype of
‘Iterable<t>' for some type 'T'._</t></p>

<h4 id="description-151">Description</h4>

<p>The analyzer produces this diagnostic when the body of a function has the
<code class="language-plaintext highlighter-rouge">sync*</code> modifier even though the return type of the function isn’t either
<code class="language-plaintext highlighter-rouge">Iterable</code> or a supertype of <code class="language-plaintext highlighter-rouge">Iterable</code>.</p>

<h4 id="example-138">Example</h4>

<p>The following code produces this diagnostic because the body of the
function <code class="language-plaintext highlighter-rouge">f</code> has the ‘sync*’ modifier even though the return type <code class="language-plaintext highlighter-rouge">int</code>
isn’t a supertype of <code class="language-plaintext highlighter-rouge">Iterable</code>:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">int</span> f() sync* {}</code></pre>

<h4 id="common-fixes-151">Common fixes</h4>

<p>If the function should return an iterable, then change the return type to
be either <code class="language-plaintext highlighter-rouge">Iterable</code> or a supertype of <code class="language-plaintext highlighter-rouge">Iterable</code>:</p>

<pre class="prettyprint lang-dart"><code>Iterable&lt;int&gt; f() sync* {}</code></pre>

<p>If the function should return a single value, then remove the <code class="language-plaintext highlighter-rouge">sync*</code>
modifier:</p>

<pre class="prettyprint lang-dart"><code>int f() =&gt; 0;</code></pre>

<h3 id="implements_non_class">
<a class="anchor" href="#implements_non_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>implements_non_class</h3>

<p><em>Classes and mixins can only implement other classes and mixins.</em></p>

<h4 id="description-152">Description</h4>

<p>The analyzer produces this diagnostic when a name used in the <code class="language-plaintext highlighter-rouge">implements</code>
clause of a class or mixin declaration is defined to be something other
than a class or mixin.</p>

<h4 id="example-139">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> is a variable
rather than a class or mixin:</p>

<pre class="prettyprint lang-dart"><code>var x;
class C implements <span class="highlight">x</span> {}</code></pre>

<h4 id="common-fixes-152">Common fixes</h4>

<p>If the name is the name of an existing class or mixin that’s already being
imported, then add a prefix to the import so that the local definition of
the name doesn’t shadow the imported name.</p>

<p>If the name is the name of an existing class or mixin that isn’t being
imported, then add an import, with a prefix, for the library in which it’s
declared.</p>

<p>Otherwise, either replace the name in the <code class="language-plaintext highlighter-rouge">implements</code> clause with the name
of an existing class or mixin, or remove the name from the <code class="language-plaintext highlighter-rouge">implements</code>
clause.</p>

<h3 id="implements_repeated">
<a class="anchor" href="#implements_repeated" aria-hidden="true"><span class="octicon octicon-link"></span></a>implements_repeated</h3>

<p><em>‘{0}’ can only be implemented once.</em></p>

<h4 id="description-153">Description</h4>

<p>The analyzer produces this diagnostic when a single class is specified more
than once in an <code class="language-plaintext highlighter-rouge">implements</code> clause.</p>

<h4 id="example-140">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">A</code> is in the list
twice:</p>

<pre class="prettyprint lang-dart"><code>class A {}
class B implements A, <span class="highlight">A</span> {}</code></pre>

<h4 id="common-fixes-153">Common fixes</h4>

<p>Remove all except one occurrence of the class name:</p>

<pre class="prettyprint lang-dart"><code>class A {}
class B implements A {}</code></pre>

<h3 id="implements_super_class">
<a class="anchor" href="#implements_super_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>implements_super_class</h3>

<p><em>‘{0}’ can’t be used in both the ‘extends’ and ‘implements’ clauses.</em></p>

<p><em>‘{0}’ can’t be used in both the ‘extends’ and ‘with’ clauses.</em></p>

<h4 id="description-154">Description</h4>

<p>The analyzer produces this diagnostic when a class is listed in the
<code class="language-plaintext highlighter-rouge">extends</code> clause of a class declaration and also in either the
<code class="language-plaintext highlighter-rouge">implements</code> or <code class="language-plaintext highlighter-rouge">with</code> clause of the same declaration.</p>

<h4 id="example-141">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">A</code> is used
in both the <code class="language-plaintext highlighter-rouge">extends</code> and <code class="language-plaintext highlighter-rouge">implements</code> clauses for the class <code class="language-plaintext highlighter-rouge">B</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class B extends A implements <span class="highlight">A</span> {}</code></pre>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">A</code> is used
in both the <code class="language-plaintext highlighter-rouge">extends</code> and <code class="language-plaintext highlighter-rouge">with</code> clauses for the class <code class="language-plaintext highlighter-rouge">B</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class B extends A with <span class="highlight">A</span> {}</code></pre>

<h4 id="common-fixes-154">Common fixes</h4>

<p>If you want to inherit the implementation from the class, then remove the
class from the <code class="language-plaintext highlighter-rouge">implements</code> clause:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class B extends A {}</code></pre>

<p>If you don’t want to inherit the implementation from the class, then remove
the <code class="language-plaintext highlighter-rouge">extends</code> clause:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class B implements A {}</code></pre>

<h3 id="implicit_super_initializer_missing_arguments">
<a class="anchor" href="#implicit_super_initializer_missing_arguments" aria-hidden="true"><span class="octicon octicon-link"></span></a>implicit_super_initializer_missing_arguments</h3>

<p><em>The implicitly invoked unnamed constructor from ‘{0}’ has required parameters.</em></p>

<h4 id="description-155">Description</h4>

<p>The analyzer produces this diagnostic when a constructor implicitly
invokes the unnamed constructor from the superclass, the unnamed
constructor of the superclass has a required parameter, and there’s no
super parameter corresponding to the required parameter.</p>

<h4 id="examples-13">Examples</h4>

<p>The following code produces this diagnostic because the unnamed
constructor in the class <code class="language-plaintext highlighter-rouge">B</code> implicitly invokes the unnamed constructor in
the class <code class="language-plaintext highlighter-rouge">A</code>, but the constructor in <code class="language-plaintext highlighter-rouge">A</code> has a required positional
parameter named <code class="language-plaintext highlighter-rouge">x</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class B extends A {
  <span class="highlight">B</span>();
}</code></pre>

<p>The following code produces this diagnostic because the unnamed
constructor in the class <code class="language-plaintext highlighter-rouge">B</code> implicitly invokes the unnamed constructor in
the class <code class="language-plaintext highlighter-rouge">A</code>, but the constructor in <code class="language-plaintext highlighter-rouge">A</code> has a required named parameter
named <code class="language-plaintext highlighter-rouge">x</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A({required int x});
}

class B extends A {
  <span class="highlight">B</span>();
}</code></pre>

<h4 id="common-fixes-155">Common fixes</h4>

<p>If you can add a parameter to the constructor in the subclass, then add a
super parameter corresponding to the required parameter in the superclass’
constructor. The new parameter can either be required:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A({required int x});
}

class B extends A {
  B({required super.x});
}</code></pre>

<p>or it can be optional:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A({required int x});
}

class B extends A {
  B({super.x = 0});
}</code></pre>

<p>If you can’t add a parameter to the constructor in the subclass, then add
an explicit super constructor invocation with the required argument:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class B extends A {
  B() : super(0);
}</code></pre>

<h3 id="implicit_this_reference_in_initializer">
<a class="anchor" href="#implicit_this_reference_in_initializer" aria-hidden="true"><span class="octicon octicon-link"></span></a>implicit_this_reference_in_initializer</h3>

<p><em>The instance member ‘{0}’ can’t be accessed in an initializer.</em></p>

<h4 id="description-156">Description</h4>

<p>The analyzer produces this diagnostic when it finds a reference to an
instance member in a constructor’s initializer list.</p>

<h4 id="example-142">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">defaultX</code> is an
instance member:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  C() : x = <span class="highlight">defaultX</span>;

  int get defaultX =&gt; 0;
}</code></pre>

<h4 id="common-fixes-156">Common fixes</h4>

<p>If the member can be made static, then do so:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  C() : x = defaultX;

  static int get defaultX =&gt; 0;
}</code></pre>

<p>If not, then replace the reference in the initializer with a different
expression that doesn’t use an instance member:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  C() : x = 0;

  int get defaultX =&gt; 0;
}</code></pre>

<h3 id="import_deferred_library_with_load_function">
<a class="anchor" href="#import_deferred_library_with_load_function" aria-hidden="true"><span class="octicon octicon-link"></span></a>import_deferred_library_with_load_function</h3>

<p><em>The imported library defines a top-level function named ‘loadLibrary’ that is
hidden by deferring this library.</em></p>

<h4 id="description-157">Description</h4>

<p>The analyzer produces this diagnostic when a library that declares a
function named <code class="language-plaintext highlighter-rouge">loadLibrary</code> is imported using a deferred import. A
deferred import introduces an implicit function named <code class="language-plaintext highlighter-rouge">loadLibrary</code>. This
function is used to load the contents of the deferred library, and the
implicit function hides the explicit declaration in the deferred library.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-143">Example</h4>

<p>Given a file (<code class="language-plaintext highlighter-rouge">a.dart</code>) that defines a function named <code class="language-plaintext highlighter-rouge">loadLibrary</code>:</p>

<pre class="prettyprint lang-dart"><code>void loadLibrary(Library library) {}

class Library {}</code></pre>

<p>The following code produces this diagnostic because the implicit
declaration of <code class="language-plaintext highlighter-rouge">a.loadLibrary</code> is hiding the explicit declaration of
<code class="language-plaintext highlighter-rouge">loadLibrary</code> in <code class="language-plaintext highlighter-rouge">a.dart</code>:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">import 'a.dart' deferred as a;</span>

void f() {
  a.Library();
}</code></pre>

<h4 id="common-fixes-157">Common fixes</h4>

<p>If the imported library isn’t required to be deferred, then remove the
keyword <code class="language-plaintext highlighter-rouge">deferred</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' as a;

void f() {
  a.Library();
}</code></pre>

<p>If the imported library is required to be deferred and you need to
reference the imported function, then rename the function in the imported
library:</p>

<pre class="prettyprint lang-dart"><code>void populateLibrary(Library library) {}

class Library {}</code></pre>

<p>If the imported library is required to be deferred and you don’t need to
reference the imported function, then add a <code class="language-plaintext highlighter-rouge">hide</code> clause:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' deferred as a hide loadLibrary;

void f() {
  a.Library();
}</code></pre>

<p>If type arguments shouldn’t be required for the class, then mark the class
with the <code class="language-plaintext highlighter-rouge">[optionalTypeArgs][meta-optionalTypeArgs]</code> annotation (from
<code class="language-plaintext highlighter-rouge">package:meta</code>):</p>

<h3 id="import_internal_library">
<a class="anchor" href="#import_internal_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>import_internal_library</h3>

<p><em>The library ‘{0}’ is internal and can’t be imported.</em></p>

<h4 id="description-158">Description</h4>

<p>The analyzer produces this diagnostic when it finds an import whose <code class="language-plaintext highlighter-rouge">dart:</code>
URI references an internal library.</p>

<h4 id="example-144">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">_interceptors</code> is an
internal library:</p>

<pre class="prettyprint lang-dart"><code>import <span class="highlight">'dart:_interceptors'</span>;</code></pre>

<h4 id="common-fixes-158">Common fixes</h4>

<p>Remove the import directive.</p>

<h3 id="import_of_legacy_library_into_null_safe">
<a class="anchor" href="#import_of_legacy_library_into_null_safe" aria-hidden="true"><span class="octicon octicon-link"></span></a>import_of_legacy_library_into_null_safe</h3>

<p><em>The library ‘{0}’ is legacy, and shouldn’t be imported into a null safe
library.</em></p>

<h4 id="description-159">Description</h4>

<p>The analyzer produces this diagnostic when a library that is null safe
imports a library that isn’t null safe.</p>

<h4 id="example-145">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">a.dart</code> that contains the following:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.9

class A {}</code></pre>

<p>The following code produces this diagnostic because a library that null
safe is importing a library that isn’t null safe:</p>

<pre class="prettyprint lang-dart"><code>import <span class="highlight">'a.dart'</span>;

A? f() =&gt; null;</code></pre>

<h4 id="common-fixes-159">Common fixes</h4>

<p>If you can migrate the imported library to be null safe, then migrate it
and update or remove the migrated library’s language version.</p>

<p>If you can’t migrate the imported library, then the importing library
needs to have a language version that is before 2.12, when null safety was
enabled by default.</p>

<h3 id="import_of_non_library">
<a class="anchor" href="#import_of_non_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>import_of_non_library</h3>

<p><em>The imported library ‘{0}’ can’t have a part-of directive.</em></p>

<h4 id="description-160">Description</h4>

<p>The analyzer produces this diagnostic when a <a href="#part-file">part file</a> is imported
into a library.</p>

<h4 id="example-146">Example</h4>

<p>Given a <a href="#part-file">part file</a> named <code class="language-plaintext highlighter-rouge">part.dart</code> containing the following:</p>

<pre class="prettyprint lang-dart"><code>part of lib;

class C{}</code></pre>

<p>The following code produces this diagnostic because imported files can’t
have a part-of directive:</p>

<pre class="prettyprint lang-dart"><code>library lib;

import <span class="highlight">'part.dart'</span>;

C c = C();</code></pre>

<h4 id="common-fixes-160">Common fixes</h4>

<p>Import the library that contains the <a href="#part-file">part file</a> rather than the
<a href="#part-file">part file</a> itself.</p>

<h3 id="inconsistent_inheritance">
<a class="anchor" href="#inconsistent_inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>inconsistent_inheritance</h3>

<p><em>Superinterfaces don’t have a valid override for ‘{0}’: {1}.</em></p>

<h4 id="description-161">Description</h4>

<p>The analyzer produces this diagnostic when a class inherits two or more
conflicting signatures for a member and doesn’t provide an implementation
that satisfies all the inherited signatures.</p>

<h4 id="example-147">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">C</code> is inheriting the
declaration of <code class="language-plaintext highlighter-rouge">m</code> from <code class="language-plaintext highlighter-rouge">A</code>, and that implementation isn’t consistent with
the signature of <code class="language-plaintext highlighter-rouge">m</code> that’s inherited from <code class="language-plaintext highlighter-rouge">B</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  void m({int a}) {}
}

class B {
  void m({int b}) {}
}

class <span class="highlight">C</span> extends A implements B {
}</code></pre>

<h4 id="common-fixes-161">Common fixes</h4>

<p>Add an implementation of the method that satisfies all the inherited
signatures:</p>

<pre class="prettyprint lang-dart"><code>class A {
  void m({int a}) {}
}

class B {
  void m({int b}) {}
}

class C extends A implements B {
  void m({int a, int b}) {}
}</code></pre>

<h3 id="inconsistent_language_version_override">
<a class="anchor" href="#inconsistent_language_version_override" aria-hidden="true"><span class="octicon octicon-link"></span></a>inconsistent_language_version_override</h3>

<p><em>Parts must have exactly the same language version override as the library.</em></p>

<h4 id="description-162">Description</h4>

<p>The analyzer produces this diagnostic when a <a href="#part-file">part file</a> has a language
version override comment that specifies a different language version than
the one being used for the library to which the part belongs.</p>

<h4 id="example-148">Example</h4>

<p>Given a <a href="#part-file">part file</a> named <code class="language-plaintext highlighter-rouge">part.dart</code> that contains the following:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.6
part of 'test.dart';</code></pre>

<p>The following code produces this diagnostic because the parts of a library
must have the same language version as the defining compilation unit:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.5
part <span class="highlight">'part.dart'</span>;</code></pre>

<h4 id="common-fixes-162">Common fixes</h4>

<p>Remove the language version override from the <a href="#part-file">part file</a>, so that it
implicitly uses the same version as the defining compilation unit:</p>

<pre class="prettyprint lang-dart"><code>part of 'test.dart';</code></pre>

<p>If necessary, either adjust the language version override in the defining
compilation unit to be appropriate for the code in the part, or migrate
the code in the <a href="#part-file">part file</a> to be consistent with the new language
version.</p>

<h3 id="initializer_for_non_existent_field">
<a class="anchor" href="#initializer_for_non_existent_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>initializer_for_non_existent_field</h3>

<p><em>‘{0}’ isn’t a field in the enclosing class.</em></p>

<h4 id="description-163">Description</h4>

<p>The analyzer produces this diagnostic when a constructor initializes a
field that isn’t declared in the class containing the constructor.
Constructors can’t initialize fields that aren’t declared and fields that
are inherited from superclasses.</p>

<h4 id="example-149">Example</h4>

<p>The following code produces this diagnostic because the initializer is
initializing <code class="language-plaintext highlighter-rouge">x</code>, but <code class="language-plaintext highlighter-rouge">x</code> isn’t a field in the class:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int y;

  C() : <span class="highlight">x = 0</span>;
}</code></pre>

<h4 id="common-fixes-163">Common fixes</h4>

<p>If a different field should be initialized, then change the name to the
name of the field:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int y;

  C() : y = 0;
}</code></pre>

<p>If the field must be declared, then add a declaration:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;
  int y;

  C() : x = 0;
}</code></pre>

<h3 id="initializer_for_static_field">
<a class="anchor" href="#initializer_for_static_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>initializer_for_static_field</h3>

<p><em>‘{0}’ is a static field in the enclosing class. Fields initialized in a
constructor can’t be static.</em></p>

<h4 id="description-164">Description</h4>

<p>The analyzer produces this diagnostic when a static field is initialized
in a constructor using either an initializing formal parameter or an
assignment in the initializer list.</p>

<h4 id="example-150">Example</h4>

<p>The following code produces this diagnostic because the static field <code class="language-plaintext highlighter-rouge">a</code>
is being initialized by the initializing formal parameter <code class="language-plaintext highlighter-rouge">this.a</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static int? a;
  C(<span class="highlight">this.a</span>);
}</code></pre>

<h4 id="common-fixes-164">Common fixes</h4>

<p>If the field should be an instance field, then remove the keyword <code class="language-plaintext highlighter-rouge">static</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int? a;
  C(this.a);
}</code></pre>

<p>If you intended to initialize an instance field and typed the wrong name,
then correct the name of the field being initialized:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static int? a;
  int? b;
  C(this.b);
}</code></pre>

<p>If you really want to initialize the static field, then move the
initialization into the constructor body:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static int? a;
  C(int? c) {
    a = c;
  }
}</code></pre>

<h3 id="initializing_formal_for_non_existent_field">
<a class="anchor" href="#initializing_formal_for_non_existent_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>initializing_formal_for_non_existent_field</h3>

<p><em>‘{0}’ isn’t a field in the enclosing class.</em></p>

<h4 id="description-165">Description</h4>

<p>The analyzer produces this diagnostic when an initializing formal
parameter is found in a constructor in a class that doesn’t declare the
field being initialized. Constructors can’t initialize fields that aren’t
declared and fields that are inherited from superclasses.</p>

<h4 id="example-151">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">x</code> isn’t
defined:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int y;

  C(<span class="highlight">this.x</span>);
}</code></pre>

<h4 id="common-fixes-165">Common fixes</h4>

<p>If the field name was wrong, then change it to the name of an existing
field:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int y;

  C(this.y);
}</code></pre>

<p>If the field name is correct but hasn’t yet been defined, then declare the
field:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;
  int y;

  C(this.x);
}</code></pre>

<p>If the parameter is needed but shouldn’t initialize a field, then convert
it to a normal parameter and use it:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int y;

  C(int x) : y = x * 2;
}</code></pre>

<p>If the parameter isn’t needed, then remove it:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int y;

  C();
}</code></pre>

<h3 id="instance_access_to_static_member">
<a class="anchor" href="#instance_access_to_static_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>instance_access_to_static_member</h3>

<p><em>The static {1} ‘{0}’ can’t be accessed through an instance.</em></p>

<h4 id="description-166">Description</h4>

<p>The analyzer produces this diagnostic when an access operator is used to
access a static member through an instance of the class.</p>

<h4 id="example-152">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">zero</code> is a static
field, but it’s being accessed as if it were an instance field:</p>

<pre class="prettyprint lang-dart"><code>void f(C c) {
  c.<span class="highlight">zero</span>;
}

class C {
  static int zero = 0;
}</code></pre>

<h4 id="common-fixes-166">Common fixes</h4>

<p>Use the class to access the static member:</p>

<pre class="prettyprint lang-dart"><code>void f(C c) {
  C.zero;
}

class C {
  static int zero = 0;
}</code></pre>

<h3 id="instance_member_access_from_factory">
<a class="anchor" href="#instance_member_access_from_factory" aria-hidden="true"><span class="octicon octicon-link"></span></a>instance_member_access_from_factory</h3>

<p><em>Instance members can’t be accessed from a factory constructor.</em></p>

<h4 id="description-167">Description</h4>

<p>The analyzer produces this diagnostic when a factory constructor contains
an unqualified reference to an instance member. In a generative
constructor, the instance of the class is created and initialized before
the body of the constructor is executed, so the instance can be bound to
<code class="language-plaintext highlighter-rouge">this</code> and accessed just like it would be in an instance method. But, in a
factory constructor, the instance isn’t created before executing the body,
so <code class="language-plaintext highlighter-rouge">this</code> can’t be used to reference it.</p>

<h4 id="example-153">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> isn’t in scope in
the factory constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;
  factory C() {
    return C._(<span class="highlight">x</span>);
  }
  C._(this.x);
}</code></pre>

<h4 id="common-fixes-167">Common fixes</h4>

<p>Rewrite the code so that it doesn’t reference the instance member:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;
  factory C() {
    return C._(0);
  }
  C._(this.x);
}</code></pre>

<h3 id="instance_member_access_from_static">
<a class="anchor" href="#instance_member_access_from_static" aria-hidden="true"><span class="octicon octicon-link"></span></a>instance_member_access_from_static</h3>

<p><em>Instance members can’t be accessed from a static method.</em></p>

<h4 id="description-168">Description</h4>

<p>The analyzer produces this diagnostic when a static method contains an
unqualified reference to an instance member.</p>

<h4 id="example-154">Example</h4>

<p>The following code produces this diagnostic because the instance field <code class="language-plaintext highlighter-rouge">x</code>
is being referenced in a static method:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  static int m() {
    return <span class="highlight">x</span>;
  }
}</code></pre>

<h4 id="common-fixes-168">Common fixes</h4>

<p>If the method must reference the instance member, then it can’t be static,
so remove the keyword:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  int m() {
    return x;
  }
}</code></pre>

<p>If the method can’t be made an instance method, then add a parameter so
that an instance of the class can be passed in:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  static int m(C c) {
    return c.x;
  }
}</code></pre>

<h3 id="instantiate_abstract_class">
<a class="anchor" href="#instantiate_abstract_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>instantiate_abstract_class</h3>

<p><em>Abstract classes can’t be instantiated.</em></p>

<h4 id="description-169">Description</h4>

<p>The analyzer produces this diagnostic when it finds a constructor
invocation and the constructor is declared in an abstract class. Even
though you can’t create an instance of an abstract class, abstract classes
can declare constructors that can be invoked by subclasses.</p>

<h4 id="example-155">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">C</code> is an abstract
class:</p>

<pre class="prettyprint lang-dart"><code>abstract class C {}

var c = new <span class="highlight">C</span>();</code></pre>

<h4 id="common-fixes-169">Common fixes</h4>

<p>If there’s a concrete subclass of the abstract class that can be used, then
create an instance of the concrete subclass.</p>

<h3 id="instantiate_enum">
<a class="anchor" href="#instantiate_enum" aria-hidden="true"><span class="octicon octicon-link"></span></a>instantiate_enum</h3>

<p><em>Enums can’t be instantiated.</em></p>

<h4 id="description-170">Description</h4>

<p>The analyzer produces this diagnostic when an enum is instantiated. It’s
invalid to create an instance of an enum by invoking a constructor; only
the instances named in the declaration of the enum can exist.</p>

<h4 id="example-156">Example</h4>

<p>The following code produces this diagnostic because the enum <code class="language-plaintext highlighter-rouge">E</code> is being
instantiated:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.16
enum E {a}

var e = <span class="highlight">E</span>();</code></pre>

<h4 id="common-fixes-170">Common fixes</h4>

<p>If you intend to use an instance of the enum, then reference one of the
constants defined in the enum:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.16
enum E {a}

var e = E.a;</code></pre>

<p>If you intend to use an instance of a class, then use the name of that class in place of the name of the enum.</p>

<h3 id="instantiate_type_alias_expands_to_type_parameter">
<a class="anchor" href="#instantiate_type_alias_expands_to_type_parameter" aria-hidden="true"><span class="octicon octicon-link"></span></a>instantiate_type_alias_expands_to_type_parameter</h3>

<p><em>Type aliases that expand to a type parameter can’t be instantiated.</em></p>

<h4 id="description-171">Description</h4>

<p>The analyzer produces this diagnostic when a constructor invocation is
found where the type being instantiated is a type alias for one of the type
parameters of the type alias. This isn’t allowed because the value of the
type parameter is a type rather than a class.</p>

<h4 id="example-157">Example</h4>

<p>The following code produces this diagnostic because it creates an instance
of <code class="language-plaintext highlighter-rouge">A</code>, even though <code class="language-plaintext highlighter-rouge">A</code> is a type alias that is defined to be equivalent to
a type parameter:</p>

<pre class="prettyprint lang-dart"><code>typedef A&lt;T&gt; = T;

void f() {
  const <span class="highlight">A</span>&lt;int&gt;();
}</code></pre>

<h4 id="common-fixes-171">Common fixes</h4>

<p>Use either a class name or a type alias defined to be a class, rather than
a type alias defined to be a type parameter:</p>

<pre class="prettyprint lang-dart"><code>typedef A&lt;T&gt; = C&lt;T&gt;;

void f() {
  const A&lt;int&gt;();
}

class C&lt;T&gt; {
  const C();
}</code></pre>

<h3 id="integer_literal_imprecise_as_double">
<a class="anchor" href="#integer_literal_imprecise_as_double" aria-hidden="true"><span class="octicon octicon-link"></span></a>integer_literal_imprecise_as_double</h3>

<p><em>The integer literal is being used as a double, but can’t be represented as a
64-bit double without overflow or loss of precision: ‘{0}’.</em></p>

<h4 id="description-172">Description</h4>

<p>The analyzer produces this diagnostic when an integer literal is being
implicitly converted to a double, but can’t be represented as a 64-bit
double without overflow or loss of precision. Integer literals are
implicitly converted to a double if the context requires the type <code class="language-plaintext highlighter-rouge">double</code>.</p>

<h4 id="example-158">Example</h4>

<p>The following code produces this diagnostic because the integer value
<code class="language-plaintext highlighter-rouge">9223372036854775807</code> can’t be represented exactly as a double:</p>

<pre class="prettyprint lang-dart"><code>double x = <span class="highlight">9223372036854775807</span>;</code></pre>

<h4 id="common-fixes-172">Common fixes</h4>

<p>If you need to use the exact value, then use the class <code class="language-plaintext highlighter-rouge">BigInt</code> to
represent the value:</p>

<pre class="prettyprint lang-dart"><code>var x = BigInt.parse('9223372036854775807');</code></pre>

<p>If you need to use a double, then change the value to one that can be
represented exactly:</p>

<pre class="prettyprint lang-dart"><code>double x = 9223372036854775808;</code></pre>

<h3 id="integer_literal_out_of_range">
<a class="anchor" href="#integer_literal_out_of_range" aria-hidden="true"><span class="octicon octicon-link"></span></a>integer_literal_out_of_range</h3>

<p><em>The integer literal {0} can’t be represented in 64 bits.</em></p>

<h4 id="description-173">Description</h4>

<p>The analyzer produces this diagnostic when an integer literal has a value
that is too large (positive) or too small (negative) to be represented in a
64-bit word.</p>

<h4 id="example-159">Example</h4>

<p>The following code produces this diagnostic because the value can’t be
represented in 64 bits:</p>

<pre class="prettyprint lang-dart"><code>var x = <span class="highlight">9223372036854775810</span>;</code></pre>

<h4 id="common-fixes-173">Common fixes</h4>

<p>If you need to represent the current value, then wrap it in an instance of
the class <code class="language-plaintext highlighter-rouge">BigInt</code>:</p>

<pre class="prettyprint lang-dart"><code>var x = BigInt.parse('9223372036854775810');</code></pre>

<h3 id="invalid_annotation">
<a class="anchor" href="#invalid_annotation" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_annotation</h3>

<p><em>Annotation must be either a const variable reference or const constructor
invocation.</em></p>

<h4 id="description-174">Description</h4>

<p>The analyzer produces this diagnostic when an annotation is found that is
using something that is neither a variable marked as <code class="language-plaintext highlighter-rouge">const</code> or the
invocation of a <code class="language-plaintext highlighter-rouge">const</code> constructor.</p>

<p>Getters can’t be used as annotations.</p>

<h4 id="examples-14">Examples</h4>

<p>The following code produces this diagnostic because the variable <code class="language-plaintext highlighter-rouge">v</code> isn’t
a <code class="language-plaintext highlighter-rouge">const</code> variable:</p>

<pre class="prettyprint lang-dart"><code>var v = 0;

<span class="highlight">@v</span>
void f() {
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> isn’t a variable:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">@f</span>
void f() {
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> isn’t a
constructor:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">@f()</span>
void f() {
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">g</code> is a getter:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">@g</span>
int get g =&gt; 0;</code></pre>

<h4 id="common-fixes-174">Common fixes</h4>

<p>If the annotation is referencing a variable that isn’t a <code class="language-plaintext highlighter-rouge">const</code>
constructor, add the keyword <code class="language-plaintext highlighter-rouge">const</code> to the variable’s declaration:</p>

<pre class="prettyprint lang-dart"><code>const v = 0;

@v
void f() {
}</code></pre>

<p>If the annotation isn’t referencing a variable, then remove it:</p>

<pre class="prettyprint lang-dart"><code>int v = 0;

void f() {
}</code></pre>

<h3 id="invalid_annotation_constant_value_from_deferred_library">
<a class="anchor" href="#invalid_annotation_constant_value_from_deferred_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_annotation_constant_value_from_deferred_library</h3>

<p><em>Constant values from a deferred library can’t be used in annotations.</em></p>

<h4 id="description-175">Description</h4>

<p>The analyzer produces this diagnostic when a constant defined in a library
that is imported as a deferred library is referenced in the argument list
of an annotation. Annotations are evaluated at compile time, and values
from deferred libraries aren’t available at compile time.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-160">Example</h4>

<p>The following code produces this diagnostic because the constant <code class="language-plaintext highlighter-rouge">pi</code> is
being referenced in the argument list of an annotation, even though the
library that defines it is being imported as a deferred library:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' deferred as math;

class C {
  const C(double d);
}

@C(<span class="highlight">math.pi</span>)
void f () {}</code></pre>

<h4 id="common-fixes-175">Common fixes</h4>

<p>If you need to reference the imported constant, then remove the <code class="language-plaintext highlighter-rouge">deferred</code>
keyword:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' as math;

class C {
  const C(double d);
}

@C(math.pi)
void f () {}</code></pre>

<p>If the import is required to be deferred and there’s another constant that
is appropriate, then use that constant in place of the constant from the
deferred library.</p>

<h3 id="invalid_annotation_from_deferred_library">
<a class="anchor" href="#invalid_annotation_from_deferred_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_annotation_from_deferred_library</h3>

<p><em>Constant values from a deferred library can’t be used as annotations.</em></p>

<h4 id="description-176">Description</h4>

<p>The analyzer produces this diagnostic when a constant from a library that
is imported using a deferred import is used as an annotation. Annotations
are evaluated at compile time, and constants from deferred libraries aren’t
available at compile time.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-161">Example</h4>

<p>The following code produces this diagnostic because the constant <code class="language-plaintext highlighter-rouge">pi</code> is
being used as an annotation when the library <code class="language-plaintext highlighter-rouge">dart:math</code> is imported as
<code class="language-plaintext highlighter-rouge">deferred</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' deferred as math;

@<span class="highlight">math.pi</span>
void f() {}</code></pre>

<h4 id="common-fixes-176">Common fixes</h4>

<p>If you need to reference the constant as an annotation, then remove the
keyword <code class="language-plaintext highlighter-rouge">deferred</code> from the import:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' as math;

@math.pi
void f() {}</code></pre>

<p>If you can use a different constant as an annotation, then replace the
annotation with a different constant:</p>

<pre class="prettyprint lang-dart"><code>@deprecated
void f() {}</code></pre>

<h3 id="invalid_annotation_target">
<a class="anchor" href="#invalid_annotation_target" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_annotation_target</h3>

<p><em>The annotation ‘{0}’ can only be used on {1}.</em></p>

<h4 id="description-177">Description</h4>

<p>The analyzer produces this diagnostic when an annotation is applied to a
kind of declaration that it doesn’t support.</p>

<h4 id="example-162">Example</h4>

<p>The following code produces this diagnostic because the <code class="language-plaintext highlighter-rouge">optionalTypeArgs</code>
annotation isn’t defined to be valid for top-level variables:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@<span class="highlight">optionalTypeArgs</span>
int x = 0;</code></pre>

<h4 id="common-fixes-177">Common fixes</h4>

<p>Remove the annotation from the declaration.</p>

<h3 id="invalid_assignment">
<a class="anchor" href="#invalid_assignment" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_assignment</h3>

<p><em>A value of type ‘{0}’ can’t be assigned to a variable of type ‘{1}’.</em></p>

<h4 id="description-178">Description</h4>

<p>The analyzer produces this diagnostic when the static type of an expression
that is assigned to a variable isn’t assignable to the type of the
variable.</p>

<h4 id="example-163">Example</h4>

<p>The following code produces this diagnostic because the type of the
initializer (<code class="language-plaintext highlighter-rouge">int</code>) isn’t assignable to the type of the variable
(<code class="language-plaintext highlighter-rouge">String</code>):</p>

<pre class="prettyprint lang-dart"><code>int i = 0;
String s = <span class="highlight">i</span>;</code></pre>

<h4 id="common-fixes-178">Common fixes</h4>

<p>If the value being assigned is always assignable at runtime, even though
the static types don’t reflect that, then add an explicit cast.</p>

<p>Otherwise, change the value being assigned so that it has the expected
type. In the previous example, this might look like:</p>

<pre class="prettyprint lang-dart"><code>int i = 0;
String s = i.toString();</code></pre>

<p>If you can’t change the value, then change the type of the variable to be
compatible with the type of the value being assigned:</p>

<pre class="prettyprint lang-dart"><code>int i = 0;
int s = i;</code></pre>

<h3 id="invalid_dependency">
<a class="anchor" href="#invalid_dependency" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_dependency</h3>

<p><em>Publishable packages can’t have ‘{0}’ dependencies.</em></p>

<h4 id="description-179">Description</h4>

<p>The analyzer produces this diagnostic when a package under either
<code class="language-plaintext highlighter-rouge">dependencies</code> or <code class="language-plaintext highlighter-rouge">dev_dependencies</code> isn’t a pub, <code class="language-plaintext highlighter-rouge">git</code>, or <code class="language-plaintext highlighter-rouge">path</code> based
dependency.</p>

<p>See <a href="https://dart.dev/tools/pub/dependencies">Package dependencies</a> for
more information about the kind of dependencies that are supported.</p>

<h4 id="example-164">Example</h4>

<p>The following code produces this diagnostic because the dependency on the
package <code class="language-plaintext highlighter-rouge">transmogrify</code> isn’t a pub, <code class="language-plaintext highlighter-rouge">git</code>, or <code class="language-plaintext highlighter-rouge">path</code> based dependency:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">transmogrify</span><span class="pi">:</span>
    <span class="na">hosted</span><span class="pi">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">transmogrify</span>
      <span class="na">url</span><span class="pi">:</span> <span class="s">http://your-package-server.com</span>
    <span class="na">version</span><span class="pi">:</span> <span class="s">^1.4.0</span>
</code></pre></div></div>

<h4 id="common-fixes-179">Common fixes</h4>

<p>If you want to publish your package to <code class="language-plaintext highlighter-rouge">pub.dev</code>, then change the
dependencies to ones that are supported by <code class="language-plaintext highlighter-rouge">pub</code>.</p>

<p>If you don’t want to publish your package to <code class="language-plaintext highlighter-rouge">pub.dev</code>, then add a
<code class="language-plaintext highlighter-rouge">publish_to: none</code> entry to mark the package as one that isn’t intended to
be published:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">publish_to</span><span class="pi">:</span> <span class="s">none</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">transmogrify</span><span class="pi">:</span>
    <span class="na">hosted</span><span class="pi">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">transmogrify</span>
      <span class="na">url</span><span class="pi">:</span> <span class="s">http://your-package-server.com</span>
    <span class="na">version</span><span class="pi">:</span> <span class="s">^1.4.0</span>
</code></pre></div></div>

<h3 id="invalid_exception_value">
<a class="anchor" href="#invalid_exception_value" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_exception_value</h3>

<p><em>The method ‘Pointer.fromFunction’ can’t have an exceptional return value (the
second argument) when the return type of the function is either ‘void’, ‘Handle’ or ‘Pointer’.</em></p>

<h4 id="description-180">Description</h4>

<p>The analyzer produces this diagnostic when an invocation of the method
<code class="language-plaintext highlighter-rouge">Pointer.fromFunction</code> has a second argument (the exceptional return
value) and the type to be returned from the invocation is either <code class="language-plaintext highlighter-rouge">void</code>,
<code class="language-plaintext highlighter-rouge">Handle</code> or <code class="language-plaintext highlighter-rouge">Pointer</code>.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-165">Example</h4>

<p>The following code produces this diagnostic because a second argument is
provided when the return type of <code class="language-plaintext highlighter-rouge">f</code> is <code class="language-plaintext highlighter-rouge">void</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

typedef T = Void Function(Int8);

void f(int i) {}

void g() {
  Pointer.fromFunction&lt;T&gt;(f, <span class="highlight">42</span>);
}</code></pre>

<h4 id="common-fixes-180">Common fixes</h4>

<p>Remove the exception value:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

typedef T = Void Function(Int8);

void f(int i) {}

void g() {
  Pointer.fromFunction&lt;T&gt;(f);
}</code></pre>

<h3 id="invalid_export_of_internal_element">
<a class="anchor" href="#invalid_export_of_internal_element" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_export_of_internal_element</h3>

<p><em>The member ‘{0}’ can’t be exported as a part of a package’s public API.</em></p>

<h4 id="description-181">Description</h4>

<p>The analyzer produces this diagnostic when a <a href="#public-library">public library</a> exports a
declaration that is marked with the <code class="language-plaintext highlighter-rouge">[internal][meta-internal]</code>
annotation.</p>

<h4 id="example-166">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">a.dart</code> in the <code class="language-plaintext highlighter-rouge">src</code> directory that contains:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@internal class One {}</code></pre>

<p>The following code, when found in a <a href="#public-library">public library</a> produces this
diagnostic because the <code class="language-plaintext highlighter-rouge">export</code> directive is exporting a name that is only
intended to be used internally:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">export 'src/a.dart';</span></code></pre>

<h4 id="common-fixes-181">Common fixes</h4>

<p>If the export is needed, then add a <code class="language-plaintext highlighter-rouge">hide</code> clause to hide the internal
names:</p>

<pre class="prettyprint lang-dart"><code>export 'src/a.dart' hide One;</code></pre>

<p>If the export isn’t needed, then remove it.</p>

<h3 id="invalid_export_of_internal_element_indirectly">
<a class="anchor" href="#invalid_export_of_internal_element_indirectly" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_export_of_internal_element_indirectly</h3>

<p><em>The member ‘{0}’ can’t be exported as a part of a package’s public API, but is
indirectly exported as part of the signature of ‘{1}’.</em></p>

<h4 id="description-182">Description</h4>

<p>The analyzer produces this diagnostic when a <a href="#public-library">public library</a> exports a
top-level function  with a return type or at least one parameter type that
is marked with the <code class="language-plaintext highlighter-rouge">[internal][meta-internal]</code> annotation.</p>

<h4 id="example-167">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">a.dart</code> in the <code class="language-plaintext highlighter-rouge">src</code> directory that contains the
following:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@internal
typedef IntFunction = int Function();

int f(IntFunction g) =&gt; g();</code></pre>

<p>The following code produces this diagnostic because the function <code class="language-plaintext highlighter-rouge">f</code> has a
parameter of type <code class="language-plaintext highlighter-rouge">IntFunction</code>, and <code class="language-plaintext highlighter-rouge">IntFunction</code> is only intended to be
used internally:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">export 'src/a.dart' show f;</span></code></pre>

<h4 id="common-fixes-182">Common fixes</h4>

<p>If the function must be public, then make all the types in the function’s
signature public types.</p>

<p>If the function doesn’t need to be exported, then stop exporting it,
either by removing it from the <code class="language-plaintext highlighter-rouge">show</code> clause, adding it to the <code class="language-plaintext highlighter-rouge">hide</code>
clause, or by removing the export.</p>

<h3 id="invalid_extension_argument_count">
<a class="anchor" href="#invalid_extension_argument_count" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_extension_argument_count</h3>

<p><em>Extension overrides must have exactly one argument: the value of ‘this’ in the
extension method.</em></p>

<h4 id="description-183">Description</h4>

<p>The analyzer produces this diagnostic when an extension override doesn’t
have exactly one argument. The argument is the expression used to compute
the value of <code class="language-plaintext highlighter-rouge">this</code> within the extension method, so there must be one
argument.</p>

<h4 id="examples-15">Examples</h4>

<p>The following code produces this diagnostic because there are no arguments:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String join(String other) =&gt; '$this $other';
}

void f() {
  E<span class="highlight">()</span>.join('b');
}</code></pre>

<p>And, the following code produces this diagnostic because there’s more than
one argument:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String join(String other) =&gt; '$this $other';
}

void f() {
  E<span class="highlight">('a', 'b')</span>.join('c');
}</code></pre>

<h4 id="common-fixes-183">Common fixes</h4>

<p>Provide one argument for the extension override:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String join(String other) =&gt; '$this $other';
}

void f() {
  E('a').join('b');
}</code></pre>

<h3 id="invalid_factory_method_decl">
<a class="anchor" href="#invalid_factory_method_decl" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_factory_method_decl</h3>

<p><em>Factory method ‘{0}’ must have a return type.</em></p>

<h4 id="description-184">Description</h4>

<p>The analyzer produces this diagnostic when a method that is annotated with
the <code class="language-plaintext highlighter-rouge">[factory][meta-factory]</code> annotation has a return type of <code class="language-plaintext highlighter-rouge">void</code>.</p>

<h4 id="example-168">Example</h4>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">createC</code>
is annotated with the <code class="language-plaintext highlighter-rouge">[factory][meta-factory]</code> annotation but doesn’t
return any value:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class Factory {
  @factory
  void <span class="highlight">createC</span>() {}
}

class C {}</code></pre>

<h4 id="common-fixes-184">Common fixes</h4>

<p>Change the return type to something other than <code class="language-plaintext highlighter-rouge">void</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class Factory {
  @factory
  C createC() =&gt; C();
}

class C {}</code></pre>

<h3 id="invalid_factory_method_impl">
<a class="anchor" href="#invalid_factory_method_impl" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_factory_method_impl</h3>

<p><em>Factory method ‘{0}’ doesn’t return a newly allocated object.</em></p>

<h4 id="description-185">Description</h4>

<p>The analyzer produces this diagnostic when a method that is annotated with
the <code class="language-plaintext highlighter-rouge">[factory][meta-factory]</code> annotation doesn’t return a newly allocated
object.</p>

<h4 id="example-169">Example</h4>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">createC</code>
returns the value of a field rather than a newly created instance of <code class="language-plaintext highlighter-rouge">C</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class Factory {
  C c = C();

  @factory
  C <span class="highlight">createC</span>() =&gt; c;
}

class C {}</code></pre>

<h4 id="common-fixes-185">Common fixes</h4>

<p>Change the method to return a newly created instance of the return type:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class Factory {
  @factory
  C createC() =&gt; C();
}

class C {}</code></pre>

<h3 id="invalid_factory_name_not_a_class">
<a class="anchor" href="#invalid_factory_name_not_a_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_factory_name_not_a_class</h3>

<p><em>The name of a factory constructor must be the same as the name of the
immediately enclosing class.</em></p>

<h4 id="description-186">Description</h4>

<p>The analyzer produces this diagnostic when the name of a factory
constructor isn’t the same as the name of the surrounding class.</p>

<h4 id="example-170">Example</h4>

<p>The following code produces this diagnostic because the name of the factory
constructor (<code class="language-plaintext highlighter-rouge">A</code>) isn’t the same as the surrounding class (<code class="language-plaintext highlighter-rouge">C</code>):</p>

<pre class="prettyprint lang-dart"><code>class A {}

class C {
  factory <span class="highlight">A</span>() =&gt; throw 0;
}</code></pre>

<h4 id="common-fixes-186">Common fixes</h4>

<p>If the factory returns an instance of the surrounding class, then rename
the factory:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class C {
  factory C() =&gt; throw 0;
}</code></pre>

<p>If the factory returns an instance of a different class, then move the
factory to that class:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A() =&gt; throw 0;
}

class C {}</code></pre>

<p>If the factory returns an instance of a different class, but you can’t
modify that class or don’t want to move the factory, then convert it to be
a static method:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class C {
  static A a() =&gt; throw 0;
}</code></pre>

<h3 id="invalid_field_type_in_struct">
<a class="anchor" href="#invalid_field_type_in_struct" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_field_type_in_struct</h3>

<p><em>Fields in struct classes can’t have the type ‘{0}’. They can only be declared
as ‘int’, ‘double’, ‘Array’, ‘Pointer’, or subtype of ‘Struct’ or ‘Union’.</em></p>

<h4 id="description-187">Description</h4>

<p>The analyzer produces this diagnostic when a field in a subclass of
<code class="language-plaintext highlighter-rouge">Struct</code> has a type other than <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">Array</code>, <code class="language-plaintext highlighter-rouge">Pointer</code>, or
subtype of <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code>.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-171">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">str</code> has
the type <code class="language-plaintext highlighter-rouge">String</code>, which isn’t one of the allowed types for fields in a
subclass of <code class="language-plaintext highlighter-rouge">Struct</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  external <span class="highlight">String</span> s;

  @Int32()
  external int i;
}</code></pre>

<h4 id="common-fixes-187">Common fixes</h4>

<p>Use one of the allowed types for the field:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';
import 'package:ffi/ffi.dart';

class C extends Struct {
  external Pointer&lt;Utf8&gt; s;

  @Int32()
  external int i;
}</code></pre>

<h3 id="invalid_implementation_override">
<a class="anchor" href="#invalid_implementation_override" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_implementation_override</h3>

<p><em>‘{1}.{0}’ (‘{2}’) isn’t a valid concrete implementation of ‘{3}.{0}’ (‘{4}’).</em></p>

<h4 id="description-188">Description</h4>

<p>The analyzer produces this diagnostic when all of the following are true:</p>

<ul>
  <li>A class defines an abstract member.</li>
  <li>There is a concrete implementation of that member in a superclass.</li>
  <li>The concrete implementation isn’t a valid implementation of the abstract
method.</li>
</ul>

<p>The concrete implementation can be invalid because of incompatibilities in
either the return type, the types of parameters, or the type variables.</p>

<h4 id="example-172">Example</h4>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">A.add</code> has
a parameter of type <code class="language-plaintext highlighter-rouge">int</code>, and the overriding method <code class="language-plaintext highlighter-rouge">B.add</code> has a
corresponding parameter of type <code class="language-plaintext highlighter-rouge">num</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  int add(int a) =&gt; a;
}
class <span class="highlight">B</span> extends A {
  int add(num a);
}</code></pre>

<p>This is a problem because in an invocation of <code class="language-plaintext highlighter-rouge">B.add</code> like the following:</p>

<pre class="prettyprint lang-dart"><code>void f(B b) {
  b.add(3.4);
}</code></pre>

<p><code class="language-plaintext highlighter-rouge">B.add</code> is expecting to be able to take, for example, a <code class="language-plaintext highlighter-rouge">double</code>, but when
the method <code class="language-plaintext highlighter-rouge">A.add</code> is executed (because it’s the only concrete
implementation of <code class="language-plaintext highlighter-rouge">add</code>), a runtime exception will be thrown because a
<code class="language-plaintext highlighter-rouge">double</code> can’t be assigned to a parameter of type <code class="language-plaintext highlighter-rouge">int</code>.</p>

<h4 id="common-fixes-188">Common fixes</h4>

<p>If the method in the subclass can conform to the implementation in the
superclass, then change the declaration in the subclass (or remove it if
it’s the same):</p>

<pre class="prettyprint lang-dart"><code>class A {
  int add(int a) =&gt; a;
}
class B	extends A {
  int add(int a);
}</code></pre>

<p>If the method in the superclass can be generalized to be a valid
implementation of the method in the subclass, then change the superclass
method:</p>

<pre class="prettyprint lang-dart"><code>class A {
  int add(num a) =&gt; a.floor();
}
class B	extends A {
  int add(num a);
}</code></pre>

<p>If neither the method in the superclass nor the method in the subclass can
be changed, then provide a concrete implementation of the method in the
subclass:</p>

<pre class="prettyprint lang-dart"><code>class A {
  int add(int a) =&gt; a;
}
class B	extends A {
  int add(num a) =&gt; a.floor();
}</code></pre>

<h3 id="invalid_inline_function_type">
<a class="anchor" href="#invalid_inline_function_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_inline_function_type</h3>

<p><em>Inline function types can’t be used for parameters in a generic function type.</em></p>

<h4 id="description-189">Description</h4>

<p>The analyzer produces this diagnostic when a generic function type has a
function-valued parameter that is written using the older inline function
type syntax.</p>

<h4 id="example-173">Example</h4>

<p>The following code produces this diagnostic because the parameter <code class="language-plaintext highlighter-rouge">f</code>, in
the generic function type used to define <code class="language-plaintext highlighter-rouge">F</code>, uses the inline function
type syntax:</p>

<pre class="prettyprint lang-dart"><code>typedef F = int Function(int f<span class="highlight">(</span>String s));</code></pre>

<h4 id="common-fixes-189">Common fixes</h4>

<p>Use the generic function syntax for the parameter’s type:</p>

<pre class="prettyprint lang-dart"><code>typedef F = int Function(int Function(String));</code></pre>

<h3 id="invalid_internal_annotation">
<a class="anchor" href="#invalid_internal_annotation" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_internal_annotation</h3>

<p><em>Only public elements in a package’s private API can be annotated as being
internal.</em></p>

<h4 id="description-190">Description</h4>

<p>The analyzer produces this diagnostic when a declaration is annotated with
the <code class="language-plaintext highlighter-rouge">[internal][meta-internal]</code> annotation and that declaration is either
in a <a href="#public-library">public library</a> or has a private name.</p>

<h4 id="example-174">Example</h4>

<p>The following code, when in a <a href="#public-library">public library</a>, produces this diagnostic
because the <code class="language-plaintext highlighter-rouge">[internal][meta-internal]</code> annotation can’t be applied to
declarations in a <a href="#public-library">public library</a>:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

<span class="highlight">@internal</span>
class C {}</code></pre>

<p>The following code, whether in a public or internal library, produces this
diagnostic because the <code class="language-plaintext highlighter-rouge">[internal][meta-internal]</code> annotation can’t be
applied to declarations with private names:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

<span class="highlight">@internal</span>
class _C {}

void f(_C c) {}</code></pre>

<h4 id="common-fixes-190">Common fixes</h4>

<p>If the declaration has a private name, then remove the annotation:</p>

<pre class="prettyprint lang-dart"><code>class _C {}

void f(_C c) {}</code></pre>

<p>If the declaration has a public name and is intended to be internal to the
package, then move the annotated declaration into an internal library (in
other words, a library inside the <code class="language-plaintext highlighter-rouge">src</code> directory).</p>

<p>Otherwise, remove the use of the annotation:</p>

<pre class="prettyprint lang-dart"><code>class C {}</code></pre>

<h3 id="invalid_language_version_override">
<a class="anchor" href="#invalid_language_version_override" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_language_version_override</h3>

<p><em>The Dart language version override comment can’t be followed by any
non-whitespace characters.</em></p>

<p><em>The Dart language version override comment must be specified with a version
number, like ‘2.0’, after the ‘=’ character.</em></p>

<p><em>The Dart language version override comment must be specified with an ‘=’
character.</em></p>

<p><em>The Dart language version override comment must be specified with exactly two
slashes.</em></p>

<p><em>The Dart language version override comment must be specified with the word
‘dart’ in all lower case.</em></p>

<p><em>The Dart language version override number can’t be prefixed with a letter.</em></p>

<p><em>The Dart language version override number must begin with ‘@dart’.</em></p>

<p><em>The language version override can’t specify a version greater than the latest
known language version: {0}.{1}.</em></p>

<p><em>The language version override must be specified before any declaration or
directive.</em></p>

<h4 id="description-191">Description</h4>

<p>The analyzer produces this diagnostic when a comment that appears to be an
attempt to specify a language version override doesn’t conform to the
requirements for such a comment. For more information, see
<a href="https://dart.dev/guides/language/evolution#per-library-language-version-selection">Per-library language version selection</a>.</p>

<h4 id="example-175">Example</h4>

<p>The following code produces this diagnostic because the word <code class="language-plaintext highlighter-rouge">dart</code> must
be lowercase in such a comment and because there’s no equal sign between
the word <code class="language-plaintext highlighter-rouge">dart</code> and the version number:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">// @Dart 2.9</span></code></pre>

<h4 id="common-fixes-191">Common fixes</h4>

<p>If the comment is intended to be a language version override, then change
the comment to follow the correct format:</p>

<pre class="prettyprint lang-dart"><code>// @dart = 2.9</code></pre>

<h3 id="invalid_literal_annotation">
<a class="anchor" href="#invalid_literal_annotation" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_literal_annotation</h3>

<p><em>Only const constructors can have the <code class="language-plaintext highlighter-rouge">@literal</code> annotation.</em></p>

<h4 id="description-192">Description</h4>

<p>The analyzer produces this diagnostic when the <code class="language-plaintext highlighter-rouge">[literal][[meta-literal]]</code>
annotation is applied to anything other than a const constructor.</p>

<h4 id="examples-16">Examples</h4>

<p>The following code produces this diagnostic because the constructor isn’t
a <code class="language-plaintext highlighter-rouge">const</code> constructor:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class C {
  <span class="highlight">@literal</span>
  C();
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> isn’t a
constructor:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

<span class="highlight">@literal</span>
var x;</code></pre>

<h4 id="common-fixes-192">Common fixes</h4>

<p>If the annotation is on a constructor and the constructor should always be
invoked with <code class="language-plaintext highlighter-rouge">const</code>, when possible, then mark the constructor with the
<code class="language-plaintext highlighter-rouge">const</code> keyword:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class C {
  @literal
  const C();
}</code></pre>

<p>If the constructor can’t be marked as <code class="language-plaintext highlighter-rouge">const</code>, then remove the annotation.</p>

<p>If the annotation is on anything other than a constructor, then remove the
annotation:</p>

<pre class="prettyprint lang-dart"><code>var x;</code></pre>

<h3 id="invalid_modifier_on_constructor">
<a class="anchor" href="#invalid_modifier_on_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_modifier_on_constructor</h3>

<p><em>The modifier ‘{0}’ can’t be applied to the body of a constructor.</em></p>

<h4 id="description-193">Description</h4>

<p>The analyzer produces this diagnostic when the body of a constructor is
prefixed by one of the following modifiers: <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">async*</code>, or <code class="language-plaintext highlighter-rouge">sync*</code>.
Constructor bodies must be synchronous.</p>

<h4 id="example-176">Example</h4>

<p>The following code produces this diagnostic because the body of the
constructor for <code class="language-plaintext highlighter-rouge">C</code> is marked as being <code class="language-plaintext highlighter-rouge">async</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C() <span class="highlight">async</span> {}
}</code></pre>

<h4 id="common-fixes-193">Common fixes</h4>

<p>If the constructor can be synchronous, then remove the modifier:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C();
}</code></pre>

<p>If the constructor can’t be synchronous, then use a static method to create
the instance instead:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C();
  static Future&lt;C&gt; c() async {
    return C();
  }
}</code></pre>

<h3 id="invalid_modifier_on_setter">
<a class="anchor" href="#invalid_modifier_on_setter" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_modifier_on_setter</h3>

<p><em>Setters can’t use ‘async’, ‘async*’, or ‘sync*‘.</em></p>

<h4 id="description-194">Description</h4>

<p>The analyzer produces this diagnostic when the body of a setter is prefixed
by one of the following modifiers: <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">async*</code>, or <code class="language-plaintext highlighter-rouge">sync*</code>. Setter
bodies must be synchronous.</p>

<h4 id="example-177">Example</h4>

<p>The following code produces this diagnostic because the body of the setter
<code class="language-plaintext highlighter-rouge">x</code> is marked as being <code class="language-plaintext highlighter-rouge">async</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  set x(int i) <span class="highlight">async</span> {}
}</code></pre>

<h4 id="common-fixes-194">Common fixes</h4>

<p>If the setter can be synchronous, then remove the modifier:</p>

<pre class="prettyprint lang-dart"><code>class C {
  set x(int i) {}
}</code></pre>

<p>If the setter can’t be synchronous, then use a method to set the value
instead:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void x(int i) async {}
}</code></pre>

<h3 id="invalid_non_virtual_annotation">
<a class="anchor" href="#invalid_non_virtual_annotation" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_non_virtual_annotation</h3>

<p><em>The annotation ‘@nonVirtual’ can only be applied to a concrete instance
member.</em></p>

<h4 id="description-195">Description</h4>

<p>The analyzer produces this diagnostic when the <code class="language-plaintext highlighter-rouge">nonVirtual</code> annotation is
found on a declaration other than a member of a class, mixin, or enum, or
if the member isn’t a concrete instance member.</p>

<h4 id="examples-17">Examples</h4>

<p>The following code produces this diagnostic because the annotation is on a
class declaration rather than a member inside the class:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

<span class="highlight">@nonVirtual</span>
class C {}</code></pre>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">m</code> is an
abstract method:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

abstract class C {
  <span class="highlight">@nonVirtual</span>
  void m();
}</code></pre>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">m</code> is a
static method:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

abstract class C {
  <span class="highlight">@nonVirtual</span>
  static void m() {}
}</code></pre>

<h4 id="common-fixes-195">Common fixes</h4>

<p>If the declaration isn’t a member of a class, mixin, or enum, then remove
the annotation:</p>

<pre class="prettyprint lang-dart"><code>class C {}</code></pre>

<p>If the member is intended to be a concrete instance member, then make it
so:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

abstract class C {
  @nonVirtual
  void m() {}
}</code></pre>

<p>If the member is not intended to be a concrete instance member, then
remove the annotation:</p>

<pre class="prettyprint lang-dart"><code>abstract class C {
  static void m() {}
}</code></pre>

<h3 id="invalid_null_aware_operator">
<a class="anchor" href="#invalid_null_aware_operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_null_aware_operator</h3>

<p><em>The receiver can’t be null because of short-circuiting, so the null-aware
operator ‘{0}’ can’t be used.</em></p>

<p><em>The receiver can’t be null, so the null-aware operator ‘{0}’ is unnecessary.</em></p>

<h4 id="description-196">Description</h4>

<p>The analyzer produces this diagnostic when a null-aware operator (<code class="language-plaintext highlighter-rouge">?.</code>,
<code class="language-plaintext highlighter-rouge">?..</code>, <code class="language-plaintext highlighter-rouge">?[</code>, <code class="language-plaintext highlighter-rouge">?..[</code>, or <code class="language-plaintext highlighter-rouge">...?</code>) is used on a receiver that’s known to be
non-nullable.</p>

<h4 id="examples-18">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">s</code> can’t be <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>int? getLength(String s) {
  return s<span class="highlight">?.</span>length;
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">a</code> can’t be <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>var a = [];
var b = [<span class="highlight">...?</span>a];</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">s?.length</code> can’t
return <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(String? s) {
  s?.length<span class="highlight">?.</span>isEven;
}</code></pre>

<p>The reason <code class="language-plaintext highlighter-rouge">s?.length</code> can’t return <code class="language-plaintext highlighter-rouge">null</code> is because the null-aware
operator following <code class="language-plaintext highlighter-rouge">s</code> short-circuits the evaluation of both <code class="language-plaintext highlighter-rouge">length</code> and
<code class="language-plaintext highlighter-rouge">isEven</code> if <code class="language-plaintext highlighter-rouge">s</code> is <code class="language-plaintext highlighter-rouge">null</code>. In other words, if <code class="language-plaintext highlighter-rouge">s</code> is <code class="language-plaintext highlighter-rouge">null</code>, then neither
<code class="language-plaintext highlighter-rouge">length</code> nor <code class="language-plaintext highlighter-rouge">isEven</code> will be invoked, and if <code class="language-plaintext highlighter-rouge">s</code> is non-<code class="language-plaintext highlighter-rouge">null</code>, then
<code class="language-plaintext highlighter-rouge">length</code> can’t return a <code class="language-plaintext highlighter-rouge">null</code> value. Either way, <code class="language-plaintext highlighter-rouge">isEven</code> can’t be invoked
on a <code class="language-plaintext highlighter-rouge">null</code> value, so the null-aware operator isn’t necessary. See
<a href="/null-safety/understanding-null-safety#smarter-null-aware-methods">Understanding null safety</a>
for more details.</p>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">s</code> can’t be <code class="language-plaintext highlighter-rouge">null</code>.</p>

<pre class="prettyprint lang-dart"><code>void f(Object? o) {
  var s = o as String;
  s<span class="highlight">?.</span>length;
}</code></pre>

<p>The reason <code class="language-plaintext highlighter-rouge">s</code> can’t be null, despite the fact that <code class="language-plaintext highlighter-rouge">o</code> can be <code class="language-plaintext highlighter-rouge">null</code>, is
because of the cast to <code class="language-plaintext highlighter-rouge">String</code>, which is a non-nullable type. If <code class="language-plaintext highlighter-rouge">o</code> ever
has the value <code class="language-plaintext highlighter-rouge">null</code>, the cast will fail and the invocation of <code class="language-plaintext highlighter-rouge">length</code>
will not happen.</p>

<h4 id="common-fixes-196">Common fixes</h4>

<p>Replace the null-aware operator with a non-null-aware equivalent; for
example, change <code class="language-plaintext highlighter-rouge">?.</code> to  <code class="language-plaintext highlighter-rouge">.</code>:</p>

<pre class="prettyprint lang-dart"><code>int getLength(String s) {
  return s.length;
}</code></pre>

<p>(Note that the return type was also changed to be non-nullable, which might
not be appropriate in some cases.)</p>

<h3 id="invalid_override">
<a class="anchor" href="#invalid_override" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_override</h3>

<p><em>‘{1}.{0}’ (‘{2}’) isn’t a valid override of ‘{3}.{0}’ (‘{4}’).</em></p>

<h4 id="description-197">Description</h4>

<p>The analyzer produces this diagnostic when a member of a class is found
that overrides a member from a supertype and the override isn’t valid. An
override is valid if all of these are true:</p>
<ul>
  <li>It allows all of the arguments allowed by the overridden member.</li>
  <li>It doesn’t require any arguments that aren’t required by the overridden
member.</li>
  <li>The type of every parameter of the overridden member is assignable to the
corresponding parameter of the override.</li>
  <li>The return type of the override is assignable to the return type of the
overridden member.</li>
</ul>

<h4 id="example-178">Example</h4>

<p>The following code produces this diagnostic because the type of the
parameter <code class="language-plaintext highlighter-rouge">s</code> (<code class="language-plaintext highlighter-rouge">String</code>) isn’t assignable to the type of the parameter <code class="language-plaintext highlighter-rouge">i</code>
(<code class="language-plaintext highlighter-rouge">int</code>):</p>

<pre class="prettyprint lang-dart"><code>class A {
  void m(int i) {}
}

class B extends A {
  void <span class="highlight">m</span>(String s) {}
}</code></pre>

<h4 id="common-fixes-197">Common fixes</h4>

<p>If the invalid method is intended to override the method from the
superclass, then change it to conform:</p>

<pre class="prettyprint lang-dart"><code>class A {
  void m(int i) {}
}

class B extends A {
  void m(int i) {}
}</code></pre>

<p>If it isn’t intended to override the method from the superclass, then
rename it:</p>

<pre class="prettyprint lang-dart"><code>class A {
  void m(int i) {}
}

class B extends A {
  void m2(String s) {}
}</code></pre>

<h3 id="invalid_override_of_non_virtual_member">
<a class="anchor" href="#invalid_override_of_non_virtual_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_override_of_non_virtual_member</h3>

<p><em>The member ‘{0}’ is declared non-virtual in ‘{1}’ and can’t be overridden in
subclasses.</em></p>

<h4 id="description-198">Description</h4>

<p>The analyzer produces this diagnostic when a member of a class, mixin, or
enum overrides a member that has the <code class="language-plaintext highlighter-rouge">@nonVirtual</code> annotation on it.</p>

<h4 id="example-179">Example</h4>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">B</code>
overrides the method <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">A</code>, and the method <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">A</code> is annotated
with the <code class="language-plaintext highlighter-rouge">@nonVirtual</code> annotation:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class A {
  @nonVirtual
  void m() {}
}

class B extends A {
  @override
  void <span class="highlight">m</span>() {}
}</code></pre>

<h4 id="common-fixes-198">Common fixes</h4>

<p>If the annotation on the method in the superclass is correct (the method
in the superclass is not intended to be overridden), then remove or rename
the overriding method:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class A {
  @nonVirtual
  void m() {}
}

class B extends A {}</code></pre>

<p>If the method in the superclass is intended to be overridden, then remove
the <code class="language-plaintext highlighter-rouge">@nonVirtual</code> annotation:</p>

<pre class="prettyprint lang-dart"><code>class A {
  void m() {}
}

class B extends A {
  @override
  void m() {}
}</code></pre>

<h3 id="invalid_reference_to_generative_enum_constructor">
<a class="anchor" href="#invalid_reference_to_generative_enum_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_reference_to_generative_enum_constructor</h3>

<p><em>Generative enum constructors can only be used as targets of redirection.</em></p>

<h4 id="description-199">Description</h4>

<p>The analyzer produces this diagnostic when a generative constructor
defined on an enum is used anywhere other than to create one of the enum
constants or as the target of a redirection from another constructor in
the same enum.</p>

<h4 id="example-180">Example</h4>

<p>The following code produces this diagnostic because the constructor for
<code class="language-plaintext highlighter-rouge">E</code> is being used to create an instance in the function <code class="language-plaintext highlighter-rouge">f</code>:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  a(0);

  const E(int x);
}

E f() =&gt; const <span class="highlight">E</span>(2);</code></pre>

<h4 id="common-fixes-199">Common fixes</h4>

<p>If there’s an enum constant with the same value, or if you add such a
constant, then reference the constant directly:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  a(0), b(2);

  const E(int x);
}

E f() =&gt; E.b;</code></pre>

<p>If you need to use a constructor invocation, then use a factory
constructor:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  a(0);

  const E(int x);

  factory E.c(int x) =&gt; a;
}

E f() =&gt; E.c(2);</code></pre>

<h3 id="invalid_reference_to_this">
<a class="anchor" href="#invalid_reference_to_this" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_reference_to_this</h3>

<p><em>Invalid reference to ‘this’ expression.</em></p>

<h4 id="description-200">Description</h4>

<p>The analyzer produces this diagnostic when <code class="language-plaintext highlighter-rouge">this</code> is used outside of an
instance method or a generative constructor. The reserved word <code class="language-plaintext highlighter-rouge">this</code> is
only defined in the context of an instance method or a generative
constructor.</p>

<h4 id="example-181">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">v</code> is a top-level
variable:</p>

<pre class="prettyprint lang-dart"><code>C f() =&gt; <span class="highlight">this</span>;

class C {}</code></pre>

<h4 id="common-fixes-200">Common fixes</h4>

<p>Use a variable of the appropriate type in place of <code class="language-plaintext highlighter-rouge">this</code>, declaring it if
necessary:</p>

<pre class="prettyprint lang-dart"><code>C f(C c) =&gt; c;

class C {}</code></pre>

<h3 id="invalid_return_type_for_catch_error">
<a class="anchor" href="#invalid_return_type_for_catch_error" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_return_type_for_catch_error</h3>

<p><em>A value of type ‘{0}’ can’t be returned by the ‘onError’ handler because it
must be assignable to ‘{1}’.</em></p>

<p><em>The return type ‘{0}’ isn’t assignable to ‘{1}’, as required by
‘Future.catchError’.</em></p>

<h4 id="description-201">Description</h4>

<p>The analyzer produces this diagnostic when an invocation of
<code class="language-plaintext highlighter-rouge">Future.catchError</code> has an argument whose return type isn’t compatible with
the type returned by the instance of <code class="language-plaintext highlighter-rouge">Future</code>. At runtime, the method
<code class="language-plaintext highlighter-rouge">catchError</code> attempts to return the value from the callback as the result
of the future, which results in another exception being thrown.</p>

<h4 id="examples-19">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">future</code> is declared to
return an <code class="language-plaintext highlighter-rouge">int</code> while <code class="language-plaintext highlighter-rouge">callback</code> is declared to return a <code class="language-plaintext highlighter-rouge">String</code>, and
<code class="language-plaintext highlighter-rouge">String</code> isn’t a subtype of <code class="language-plaintext highlighter-rouge">int</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(Future&lt;int&gt; future, String Function(dynamic, StackTrace) callback) {
  future.catchError(<span class="highlight">callback</span>);
}</code></pre>

<p>The following code produces this diagnostic because the closure being
passed to <code class="language-plaintext highlighter-rouge">catchError</code> returns an <code class="language-plaintext highlighter-rouge">int</code> while <code class="language-plaintext highlighter-rouge">future</code> is declared to
return a <code class="language-plaintext highlighter-rouge">String</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(Future&lt;String&gt; future) {
  future.catchError((error, stackTrace) =&gt; <span class="highlight">3</span>);
}</code></pre>

<h4 id="common-fixes-201">Common fixes</h4>

<p>If the instance of <code class="language-plaintext highlighter-rouge">Future</code> is declared correctly, then change the callback
to match:</p>

<pre class="prettyprint lang-dart"><code>void f(Future&lt;int&gt; future, int Function(dynamic, StackTrace) callback) {
  future.catchError(callback);
}</code></pre>

<p>If the declaration of the instance of <code class="language-plaintext highlighter-rouge">Future</code> is wrong, then change it to
match the callback:</p>

<pre class="prettyprint lang-dart"><code>void f(Future&lt;String&gt; future, String Function(dynamic, StackTrace) callback) {
  future.catchError(callback);
}</code></pre>

<h3 id="invalid_sealed_annotation">
<a class="anchor" href="#invalid_sealed_annotation" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_sealed_annotation</h3>

<p><em>The annotation ‘@sealed’ can only be applied to classes.</em></p>

<h4 id="description-202">Description</h4>

<p>The analyzer produces this diagnostic when a declaration other than a
class declaration has the <code class="language-plaintext highlighter-rouge">@sealed</code> annotation on it.</p>

<h4 id="example-182">Example</h4>

<p>The following code produces this diagnostic because the <code class="language-plaintext highlighter-rouge">@sealed</code>
annotation is on a method declaration:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class A {
  <span class="highlight">@sealed</span>
  void m() {}
}</code></pre>

<h4 id="common-fixes-202">Common fixes</h4>

<p>Remove the annotation:</p>

<pre class="prettyprint lang-dart"><code>class A {
  void m() {}
}</code></pre>

<h3 id="invalid_super_formal_parameter_location">
<a class="anchor" href="#invalid_super_formal_parameter_location" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_super_formal_parameter_location</h3>

<p><em>Super parameters can only be used in non-redirecting generative constructors.</em></p>

<h4 id="description-203">Description</h4>

<p>The analyzer produces this diagnostic when a super parameter is used
anywhere other than a non-redirecting generative constructor.</p>

<h4 id="examples-20">Examples</h4>

<p>The following code produces this diagnostic because the super parameter
<code class="language-plaintext highlighter-rouge">x</code> is in a redirecting generative constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class B extends A {
  B.b(<span class="highlight">super</span>.x) : this._();
  B._() : super(0);
}</code></pre>

<p>The following code produces this diagnostic because the super parameter
<code class="language-plaintext highlighter-rouge">x</code> isn’t in a generative constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class C extends A {
  factory C.c(<span class="highlight">super</span>.x) =&gt; C._();
  C._() : super(0);
}</code></pre>

<p>The following code produces this diagnostic because the super parameter
<code class="language-plaintext highlighter-rouge">x</code> is in a method:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class D extends A {
  D() : super(0);

  void m(<span class="highlight">super</span>.x) {}
}</code></pre>

<h4 id="common-fixes-203">Common fixes</h4>

<p>If the function containing the super parameter can be changed to be a
non-redirecting generative constructor, then do so:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class B extends A {
  B.b(super.x);
}</code></pre>

<p>If the function containing the super parameter can’t be changed to be a
non-redirecting generative constructor, then remove the <code class="language-plaintext highlighter-rouge">super</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class D extends A {
  D() : super(0);

  void m(int x) {}
}</code></pre>

<h3 id="invalid_type_argument_in_const_literal">
<a class="anchor" href="#invalid_type_argument_in_const_literal" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_type_argument_in_const_literal</h3>

<p><em>Constant list literals can’t include a type parameter as a type argument, such
as ‘{0}’.</em></p>

<p><em>Constant map literals can’t include a type parameter as a type argument, such
as ‘{0}’.</em></p>

<p><em>Constant set literals can’t include a type parameter as a type argument, such
as ‘{0}’.</em></p>

<h4 id="description-204">Description</h4>

<p>The analyzer produces this diagnostic when a type parameter is used as a
type argument in a list, map, or set literal that is prefixed by <code class="language-plaintext highlighter-rouge">const</code>.
This isn’t allowed because the value of the type parameter (the actual type
that will be used at runtime) can’t be known at compile time.</p>

<h4 id="examples-21">Examples</h4>

<p>The following code produces this diagnostic because the type parameter <code class="language-plaintext highlighter-rouge">T</code>
is being used as a type argument when creating a constant list:</p>

<pre class="prettyprint lang-dart"><code>List&lt;T&gt; newList&lt;T&gt;() =&gt; const &lt;<span class="highlight">T</span>&gt;[];</code></pre>

<p>The following code produces this diagnostic because the type parameter <code class="language-plaintext highlighter-rouge">T</code>
is being used as a type argument when creating a constant map:</p>

<pre class="prettyprint lang-dart"><code>Map&lt;String, T&gt; newSet&lt;T&gt;() =&gt; const &lt;String, <span class="highlight">T</span>&gt;{};</code></pre>

<p>The following code produces this diagnostic because the type parameter <code class="language-plaintext highlighter-rouge">T</code>
is being used as a type argument when creating a constant set:</p>

<pre class="prettyprint lang-dart"><code>Set&lt;T&gt; newSet&lt;T&gt;() =&gt; const &lt;<span class="highlight">T</span>&gt;{};</code></pre>

<h4 id="common-fixes-204">Common fixes</h4>

<p>If the type that will be used for the type parameter can be known at
compile time, then remove the type parameter:</p>

<pre class="prettyprint lang-dart"><code>List&lt;int&gt; newList() =&gt; const &lt;int&gt;[];</code></pre>

<p>If the type that will be used for the type parameter can’t be known until
runtime, then remove the keyword <code class="language-plaintext highlighter-rouge">const</code>:</p>

<pre class="prettyprint lang-dart"><code>List&lt;T&gt; newList&lt;T&gt;() =&gt; &lt;T&gt;[];</code></pre>

<h3 id="invalid_uri">
<a class="anchor" href="#invalid_uri" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_uri</h3>

<p><em>Invalid URI syntax: ‘{0}’.</em></p>

<h4 id="description-205">Description</h4>

<p>The analyzer produces this diagnostic when a URI in a directive doesn’t
conform to the syntax of a valid URI.</p>

<h4 id="example-183">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">'#'</code> isn’t a valid
URI:</p>

<pre class="prettyprint lang-dart"><code>import <span class="highlight">'#'</span>;</code></pre>

<h4 id="common-fixes-205">Common fixes</h4>

<p>Replace the invalid URI with a valid URI.</p>

<h3 id="invalid_use_of_covariant_in_extension">
<a class="anchor" href="#invalid_use_of_covariant_in_extension" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_use_of_covariant_in_extension</h3>

<p><em>Can’t have modifier ‘{0}’ in an extension.</em></p>

<h4 id="description-206">Description</h4>

<p>The analyzer produces this diagnostic when a member declared inside an
extension uses the keyword <code class="language-plaintext highlighter-rouge">covariant</code> in the declaration of a parameter.
Extensions aren’t classes and don’t have subclasses, so the keyword serves
no purpose.</p>

<h4 id="example-184">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">i</code> is marked as being
covariant:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  void a(<span class="highlight">covariant</span> int i) {}
}</code></pre>

<h4 id="common-fixes-206">Common fixes</h4>

<p>Remove the <code class="language-plaintext highlighter-rouge">covariant</code> keyword:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  void a(int i) {}
}</code></pre>

<h3 id="invalid_use_of_internal_member">
<a class="anchor" href="#invalid_use_of_internal_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_use_of_internal_member</h3>

<p><em>The member ‘{0}’ can only be used within its package.</em></p>

<h4 id="description-207">Description</h4>

<p>The analyzer produces this diagnostic when a reference to a declaration
that is annotated with the <code class="language-plaintext highlighter-rouge">[internal][meta-internal]</code> annotation is found
outside the package containing the declaration.</p>

<h4 id="example-185">Example</h4>

<p>Given a package <code class="language-plaintext highlighter-rouge">p</code> that defines a library containing a declaration marked
with the <code class="language-plaintext highlighter-rouge">[internal][meta-internal]</code> annotation:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@internal
class C {}</code></pre>

<p>The following code produces this diagnostic because it’s referencing the
class <code class="language-plaintext highlighter-rouge">C</code>, which isn’t intended to be used outside the package <code class="language-plaintext highlighter-rouge">p</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'package:p/src/p.dart';

void f(<span class="highlight">C</span> c) {}</code></pre>

<h4 id="common-fixes-207">Common fixes</h4>

<p>Remove the reference to the internal declaration.</p>

<h3 id="invalid_use_of_null_value">
<a class="anchor" href="#invalid_use_of_null_value" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_use_of_null_value</h3>

<p><em>An expression whose value is always ‘null’ can’t be dereferenced.</em></p>

<h4 id="description-208">Description</h4>

<p>The analyzer produces this diagnostic when an expression whose value will
always be <code class="language-plaintext highlighter-rouge">null</code> is dereferenced.</p>

<h4 id="example-186">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> will always be
<code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>int f(Null x) {
  return <span class="highlight">x</span>.length;
}</code></pre>

<h4 id="common-fixes-208">Common fixes</h4>

<p>If the value is allowed to be something other than <code class="language-plaintext highlighter-rouge">null</code>, then change the
type of the expression:</p>

<pre class="prettyprint lang-dart"><code>int f(String? x) {
  return x!.length;
}</code></pre>

<h3 id="invalid_use_of_visible_for_overriding_member">
<a class="anchor" href="#invalid_use_of_visible_for_overriding_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_use_of_visible_for_overriding_member</h3>

<p><em>The member ‘{0}’ can only be used for overriding.</em></p>

<h4 id="description-209">Description</h4>

<p>The analyzer produces this diagnostic when an instance member that is
annotated with <code class="language-plaintext highlighter-rouge">[visibleForOverriding][meta-visibleForOverriding]</code> is
referenced outside the library in which it’s declared for any reason other
than to override it.</p>

<h4 id="example-187">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">a.dart</code> containing the following declaration:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class A {
  @visibleForOverriding
  void a() {}
}</code></pre>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">m</code> is being
invoked even though the only reason it’s public is to allow it to be
overridden:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart';

class B extends A {
  void b() {
    <span class="highlight">a</span>();
  }
}</code></pre>

<h4 id="common-fixes-209">Common fixes</h4>

<p>Remove the invalid use of the member.</p>

<h3 id="invalid_use_of_visible_for_testing_member">
<a class="anchor" href="#invalid_use_of_visible_for_testing_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_use_of_visible_for_testing_member</h3>

<p><em>The member ‘{0}’ can only be used within ‘{1}’ or a test.</em></p>

<h4 id="description-210">Description</h4>

<p>The analyzer produces this diagnostic when a member annotated with
<code class="language-plaintext highlighter-rouge">@visibleForTesting</code> is referenced anywhere other than the library in
which it is declared or in a library in the <code class="language-plaintext highlighter-rouge">test</code> directory.</p>

<h4 id="example-188">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">c.dart</code> that contains the following:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class C {
  @visibleForTesting
  void m() {}
}</code></pre>

<p>The following code, when not inside the <code class="language-plaintext highlighter-rouge">test</code> directory, produces this
diagnostic because the method <code class="language-plaintext highlighter-rouge">m</code> is marked as being visible only for
tests:</p>

<pre class="prettyprint lang-dart"><code>import 'c.dart';

void f(C c) {
  c.<span class="highlight">m</span>();
}</code></pre>

<h4 id="common-fixes-210">Common fixes</h4>

<p>If the annotated member should not be referenced outside of tests, then
remove the reference:</p>

<pre class="prettyprint lang-dart"><code>import 'c.dart';

void f(C c) {}</code></pre>

<p>If it’s OK to reference the annotated member outside of tests, then remove
the annotation:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void m() {}
}</code></pre>

<h3 id="invalid_visibility_annotation">
<a class="anchor" href="#invalid_visibility_annotation" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_visibility_annotation</h3>

<p><em>The member ‘{0}’ is annotated with ‘{1}’, but this annotation is only
meaningful on declarations of public members.</em></p>

<h4 id="description-211">Description</h4>

<p>The analyzer produces this diagnostic when either the <code class="language-plaintext highlighter-rouge">visibleForTemplate</code>
or <code class="language-plaintext highlighter-rouge">[visibleForTesting][meta-visibleForTesting]</code> annotation is applied to
a non-public declaration.</p>

<h4 id="example-189">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

<span class="highlight">@visibleForTesting</span>
void _someFunction() {}

void f() =&gt; _someFunction();</code></pre>

<h4 id="common-fixes-211">Common fixes</h4>

<p>If the declaration doesn’t need to be used by test code, then remove the
annotation:</p>

<pre class="prettyprint lang-dart"><code>void _someFunction() {}

void f() =&gt; _someFunction();</code></pre>

<p>If it does, then make it public:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@visibleForTesting
void someFunction() {}

void f() =&gt; someFunction();</code></pre>

<h3 id="invalid_visible_for_overriding_annotation">
<a class="anchor" href="#invalid_visible_for_overriding_annotation" aria-hidden="true"><span class="octicon octicon-link"></span></a>invalid_visible_for_overriding_annotation</h3>

<p><em>The annotation ‘visibleForOverriding’ can only be applied to a public instance
member that can be overridden.</em></p>

<h4 id="description-212">Description</h4>

<p>The analyzer produces this diagnostic when anything other than a public
instance member of a class is annotated with
<code class="language-plaintext highlighter-rouge">[visibleForOverriding][meta-visibleForOverriding]</code>. Because only public
instance members can be overridden outside the defining library, there’s
no value to annotating any other declarations.</p>

<h4 id="example-190">Example</h4>

<p>The following code produces this diagnostic because the annotation is on a
class, and classes can’t be overridden:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

<span class="highlight">@visibleForOverriding</span>
class C {}</code></pre>

<h4 id="common-fixes-212">Common fixes</h4>

<p>Remove the annotation:</p>

<pre class="prettyprint lang-dart"><code>class C {}</code></pre>

<h3 id="invocation_of_extension_without_call">
<a class="anchor" href="#invocation_of_extension_without_call" aria-hidden="true"><span class="octicon octicon-link"></span></a>invocation_of_extension_without_call</h3>

<p><em>The extension ‘{0}’ doesn’t define a ‘call’ method so the override can’t be
used in an invocation.</em></p>

<h4 id="description-213">Description</h4>

<p>The analyzer produces this diagnostic when an extension override is used to
invoke a function but the extension doesn’t declare a <code class="language-plaintext highlighter-rouge">call</code> method.</p>

<h4 id="example-191">Example</h4>

<p>The following code produces this diagnostic because the extension <code class="language-plaintext highlighter-rouge">E</code>
doesn’t define a <code class="language-plaintext highlighter-rouge">call</code> method:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {}

void f() {
  <span class="highlight">E('')</span>();
}</code></pre>

<h4 id="common-fixes-213">Common fixes</h4>

<p>If the extension is intended to define a <code class="language-plaintext highlighter-rouge">call</code> method, then declare it:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  int call() =&gt; 0;
}

void f() {
  E('')();
}</code></pre>

<p>If the extended type defines a <code class="language-plaintext highlighter-rouge">call</code> method, then remove the extension
override.</p>

<p>If the <code class="language-plaintext highlighter-rouge">call</code> method isn’t defined, then rewrite the code so that it
doesn’t invoke the <code class="language-plaintext highlighter-rouge">call</code> method.</p>

<h3 id="invocation_of_non_function">
<a class="anchor" href="#invocation_of_non_function" aria-hidden="true"><span class="octicon octicon-link"></span></a>invocation_of_non_function</h3>

<p><em>‘{0}’ isn’t a function.</em></p>

<h4 id="description-214">Description</h4>

<p>The analyzer produces this diagnostic when it finds a function invocation,
but the name of the function being invoked is defined to be something other
than a function.</p>

<h4 id="example-192">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">Binary</code> is the name of
a function type, not a function:</p>

<pre class="prettyprint lang-dart"><code>typedef Binary = int Function(int, int);

int f() {
  return <span class="highlight">Binary</span>(1, 2);
}</code></pre>

<h4 id="common-fixes-214">Common fixes</h4>

<p>Replace the name with the name of a function.</p>

<h3 id="invocation_of_non_function_expression">
<a class="anchor" href="#invocation_of_non_function_expression" aria-hidden="true"><span class="octicon octicon-link"></span></a>invocation_of_non_function_expression</h3>

<p><em>The expression doesn’t evaluate to a function, so it can’t be invoked.</em></p>

<h4 id="description-215">Description</h4>

<p>The analyzer produces this diagnostic when a function invocation is found,
but the name being referenced isn’t the name of a function, or when the
expression computing the function doesn’t compute a function.</p>

<h4 id="examples-22">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> isn’t a function:</p>

<pre class="prettyprint lang-dart"><code>int x = 0;

int f() =&gt; x;

var y = <span class="highlight">x</span>();</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f()</code> doesn’t return a
function:</p>

<pre class="prettyprint lang-dart"><code>int x = 0;

int f() =&gt; x;

var y = <span class="highlight">f()</span>();</code></pre>

<h4 id="common-fixes-215">Common fixes</h4>

<p>If you need to invoke a function, then replace the code before the argument
list with the name of a function or with an expression that computes a
function:</p>

<pre class="prettyprint lang-dart"><code>int x = 0;

int f() =&gt; x;

var y = f();</code></pre>

<h3 id="label_in_outer_scope">
<a class="anchor" href="#label_in_outer_scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>label_in_outer_scope</h3>

<p><em>Can’t reference label ‘{0}’ declared in an outer method.</em></p>

<h4 id="description-216">Description</h4>

<p>The analyzer produces this diagnostic when a <code class="language-plaintext highlighter-rouge">break</code> or <code class="language-plaintext highlighter-rouge">continue</code>
statement references a label that is declared in a method or function
containing the function in which the <code class="language-plaintext highlighter-rouge">break</code> or <code class="language-plaintext highlighter-rouge">continue</code> statement
appears. The <code class="language-plaintext highlighter-rouge">break</code> and <code class="language-plaintext highlighter-rouge">continue</code> statements can’t be used to transfer
control outside the function that contains them.</p>

<h4 id="example-193">Example</h4>

<p>The following code produces this diagnostic because the label <code class="language-plaintext highlighter-rouge">loop</code> is
declared outside the local function <code class="language-plaintext highlighter-rouge">g</code>:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  loop:
  while (true) {
    void g() {
      break <span class="highlight">loop</span>;
    }

    g();
  }
}</code></pre>

<h4 id="common-fixes-216">Common fixes</h4>

<p>Try rewriting the code so that it isn’t necessary to transfer control
outside the local function, possibly by inlining the local function:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  loop:
  while (true) {
    break loop;
  }
}</code></pre>

<p>If that isn’t possible, then try rewriting the local function so that a
value returned by the function can be used to determine whether control is
transferred:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  loop:
  while (true) {
    bool g() {
      return true;
    }

    if (g()) {
      break loop;
    }
  }
}</code></pre>

<h3 id="label_undefined">
<a class="anchor" href="#label_undefined" aria-hidden="true"><span class="octicon octicon-link"></span></a>label_undefined</h3>

<p><em>Can’t reference an undefined label ‘{0}’.</em></p>

<h4 id="description-217">Description</h4>

<p>The analyzer produces this diagnostic when it finds a reference to a label
that isn’t defined in the scope of the <code class="language-plaintext highlighter-rouge">break</code> or <code class="language-plaintext highlighter-rouge">continue</code> statement that
is referencing it.</p>

<h4 id="example-194">Example</h4>

<p>The following code produces this diagnostic because the label <code class="language-plaintext highlighter-rouge">loop</code> isn’t
defined anywhere:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  for (int i = 0; i &lt; 10; i++) {
    for (int j = 0; j &lt; 10; j++) {
      break <span class="highlight">loop</span>;
    }
  }
}</code></pre>

<h4 id="common-fixes-217">Common fixes</h4>

<p>If the label should be on the innermost enclosing <code class="language-plaintext highlighter-rouge">do</code>, <code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">switch</code>, or
<code class="language-plaintext highlighter-rouge">while</code> statement, then remove the label:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  for (int i = 0; i &lt; 10; i++) {
    for (int j = 0; j &lt; 10; j++) {
      break;
    }
  }
}</code></pre>

<p>If the label should be on some other statement, then add the label:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  loop: for (int i = 0; i &lt; 10; i++) {
    for (int j = 0; j &lt; 10; j++) {
      break loop;
    }
  }
}</code></pre>

<h3 id="late_final_field_with_const_constructor">
<a class="anchor" href="#late_final_field_with_const_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>late_final_field_with_const_constructor</h3>

<p><em>Can’t have a late final field in a class with a generative const constructor.</em></p>

<h4 id="description-218">Description</h4>

<p>The analyzer produces this diagnostic when a class that has at least one
<code class="language-plaintext highlighter-rouge">const</code> constructor also has a field marked both <code class="language-plaintext highlighter-rouge">late</code> and <code class="language-plaintext highlighter-rouge">final</code>.</p>

<h4 id="example-195">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">A</code> has a
<code class="language-plaintext highlighter-rouge">const</code> constructor and the <code class="language-plaintext highlighter-rouge">final</code> field <code class="language-plaintext highlighter-rouge">f</code> is marked as <code class="language-plaintext highlighter-rouge">late</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  <span class="highlight">late</span> final int f;

  const A();
}</code></pre>

<h4 id="common-fixes-218">Common fixes</h4>

<p>If the field doesn’t need to be marked <code class="language-plaintext highlighter-rouge">late</code>, then remove the <code class="language-plaintext highlighter-rouge">late</code>
modifier from the field:</p>

<pre class="prettyprint lang-dart"><code>class A {
  final int f = 0;

  const A();
}</code></pre>

<p>If the field must be marked <code class="language-plaintext highlighter-rouge">late</code>, then remove the <code class="language-plaintext highlighter-rouge">const</code> modifier from
the constructors:</p>

<pre class="prettyprint lang-dart"><code>class A {
  late final int f;

  A();
}</code></pre>

<h3 id="late_final_local_already_assigned">
<a class="anchor" href="#late_final_local_already_assigned" aria-hidden="true"><span class="octicon octicon-link"></span></a>late_final_local_already_assigned</h3>

<p><em>The late final local variable is already assigned.</em></p>

<h4 id="description-219">Description</h4>

<p>The analyzer produces this diagnostic when the analyzer can prove that a
local variable marked as both <code class="language-plaintext highlighter-rouge">late</code> and <code class="language-plaintext highlighter-rouge">final</code> was already assigned a
value at the point where another assignment occurs.</p>

<p>Because <code class="language-plaintext highlighter-rouge">final</code> variables can only be assigned once, subsequent assignments
are guaranteed to fail, so they’re flagged.</p>

<h4 id="example-196">Example</h4>

<p>The following code produces this diagnostic because the <code class="language-plaintext highlighter-rouge">final</code> variable
<code class="language-plaintext highlighter-rouge">v</code> is assigned a value in two places:</p>

<pre class="prettyprint lang-dart"><code>int f() {
  late final int v;
  v = 0;
  <span class="highlight">v</span> += 1;
  return v;
}</code></pre>

<h4 id="common-fixes-219">Common fixes</h4>

<p>If you need to be able to reassign the variable, then remove the <code class="language-plaintext highlighter-rouge">final</code>
keyword:</p>

<pre class="prettyprint lang-dart"><code>int f() {
  late int v;
  v = 0;
  v += 1;
  return v;
}</code></pre>

<p>If you don’t need to reassign the variable, then remove all except the
first of the assignments:</p>

<pre class="prettyprint lang-dart"><code>int f() {
  late final int v;
  v = 0;
  return v;
}</code></pre>

<h3 id="leaf_call_must_not_return_handle">
<a class="anchor" href="#leaf_call_must_not_return_handle" aria-hidden="true"><span class="octicon octicon-link"></span></a>leaf_call_must_not_return_handle</h3>

<p><em>FFI leaf call can’t return a ‘Handle’.</em></p>

<h4 id="description-220">Description</h4>

<p>The analyzer produces this diagnostic when the value of the <code class="language-plaintext highlighter-rouge">isLeaf</code>
argument in an invocation of either <code class="language-plaintext highlighter-rouge">Pointer.asFunction</code> or
<code class="language-plaintext highlighter-rouge">DynamicLibrary.lookupFunction</code> is <code class="language-plaintext highlighter-rouge">true</code> and the function that would be
returned would have a return type of <code class="language-plaintext highlighter-rouge">Handle</code>.</p>

<p>The analyzer also produces this diagnostic when the value of the <code class="language-plaintext highlighter-rouge">isLeaf</code>
argument in an <code class="language-plaintext highlighter-rouge">FfiNative</code> annotation is <code class="language-plaintext highlighter-rouge">true</code> and the type argument on
the annotation is a function type whose return type is <code class="language-plaintext highlighter-rouge">Handle</code>.</p>

<p>In all of these cases, leaf calls are only supported for the types <code class="language-plaintext highlighter-rouge">bool</code>,
<code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">double</code>, and, as a return type <code class="language-plaintext highlighter-rouge">void</code>.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-197">Example</h4>

<p>The following code produces this diagnostic because the function <code class="language-plaintext highlighter-rouge">p</code>
returns a <code class="language-plaintext highlighter-rouge">Handle</code>, but the <code class="language-plaintext highlighter-rouge">isLeaf</code> argument is <code class="language-plaintext highlighter-rouge">true</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

void f(Pointer&lt;NativeFunction&lt;Handle Function()&gt;&gt; p) {
  <span class="highlight">p.asFunction&lt;Object Function()&gt;(isLeaf: true)</span>;
}</code></pre>

<h4 id="common-fixes-220">Common fixes</h4>

<p>If the function returns a handle, then remove the <code class="language-plaintext highlighter-rouge">isLeaf</code> argument:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

void f(Pointer&lt;NativeFunction&lt;Handle Function()&gt;&gt; p) {
  p.asFunction&lt;Object Function()&gt;();
}</code></pre>

<p>If the function returns one of the supported types, then correct the type
information:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

void f(Pointer&lt;NativeFunction&lt;Int32 Function()&gt;&gt; p) {
  p.asFunction&lt;int Function()&gt;(isLeaf: true);
}</code></pre>

<h3 id="leaf_call_must_not_take_handle">
<a class="anchor" href="#leaf_call_must_not_take_handle" aria-hidden="true"><span class="octicon octicon-link"></span></a>leaf_call_must_not_take_handle</h3>

<p><em>FFI leaf call can’t take arguments of type ‘Handle’.</em></p>

<h4 id="description-221">Description</h4>

<p>The analyzer produces this diagnostic when the value of the <code class="language-plaintext highlighter-rouge">isLeaf</code>
argument in an invocation of either <code class="language-plaintext highlighter-rouge">Pointer.asFunction</code> or
<code class="language-plaintext highlighter-rouge">DynamicLibrary.lookupFunction</code> is <code class="language-plaintext highlighter-rouge">true</code> and the function that would be
returned would have a parameter of type <code class="language-plaintext highlighter-rouge">Handle</code>.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-198">Example</h4>

<p>The following code produces this diagnostic because the function <code class="language-plaintext highlighter-rouge">p</code> has a
parameter of type <code class="language-plaintext highlighter-rouge">Handle</code>, but the <code class="language-plaintext highlighter-rouge">isLeaf</code> argument is <code class="language-plaintext highlighter-rouge">true</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

void f(Pointer&lt;NativeFunction&lt;Void Function(Handle)&gt;&gt; p) {
  <span class="highlight">p.asFunction&lt;void Function(Object)&gt;(isLeaf: true)</span>;
}</code></pre>

<h4 id="common-fixes-221">Common fixes</h4>

<p>If the function has at least one parameter of type <code class="language-plaintext highlighter-rouge">Handle</code>, then remove
the <code class="language-plaintext highlighter-rouge">isLeaf</code> argument:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

void f(Pointer&lt;NativeFunction&lt;Void Function(Handle)&gt;&gt; p) {
  p.asFunction&lt;void Function(Object)&gt;();
}</code></pre>

<p>If none of the function’s parameters are <code class="language-plaintext highlighter-rouge">Handle</code>s, then correct the type
information:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

void f(Pointer&lt;NativeFunction&lt;Void Function(Int8)&gt;&gt; p) {
  p.asFunction&lt;void Function(int)&gt;(isLeaf: true);
}</code></pre>

<h3 id="list_element_type_not_assignable">
<a class="anchor" href="#list_element_type_not_assignable" aria-hidden="true"><span class="octicon octicon-link"></span></a>list_element_type_not_assignable</h3>

<p><em>The element type ‘{0}’ can’t be assigned to the list type ‘{1}’.</em></p>

<h4 id="description-222">Description</h4>

<p>The analyzer produces this diagnostic when the type of an element in a list
literal isn’t assignable to the element type of the list.</p>

<h4 id="example-199">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">2.5</code> is a double, and
the list can hold only integers:</p>

<pre class="prettyprint lang-dart"><code>List&lt;int&gt; x = [1, <span class="highlight">2.5</span>, 3];</code></pre>

<h4 id="common-fixes-222">Common fixes</h4>

<p>If you intended to add a different object to the list, then replace the
element with an expression that computes the intended object:</p>

<pre class="prettyprint lang-dart"><code>List&lt;int&gt; x = [1, 2, 3];</code></pre>

<p>If the object shouldn’t be in the list, then remove the element:</p>

<pre class="prettyprint lang-dart"><code>List&lt;int&gt; x = [1, 3];</code></pre>

<p>If the object being computed is correct, then widen the element type of the
list to allow all of the different types of objects it needs to contain:</p>

<pre class="prettyprint lang-dart"><code>List&lt;num&gt; x = [1, 2.5, 3];</code></pre>

<h3 id="main_first_positional_parameter_type">
<a class="anchor" href="#main_first_positional_parameter_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>main_first_positional_parameter_type</h3>

<p>_The type of the first positional parameter of the ‘main’ function must be a
supertype of ‘List<string>'._</string></p>

<h4 id="description-223">Description</h4>

<p>The analyzer produces this diagnostic when the first positional parameter
of a function named <code class="language-plaintext highlighter-rouge">main</code> isn’t a supertype of <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>.</p>

<h4 id="example-200">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">List&lt;int&gt;</code> isn’t a
supertype of <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>:</p>

<pre class="prettyprint lang-dart"><code>void main(<span class="highlight">List&lt;int&gt;</span> args) {}</code></pre>

<h4 id="common-fixes-223">Common fixes</h4>

<p>If the function is an entry point, then change the type of the first
positional parameter to be a supertype of <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>:</p>

<pre class="prettyprint lang-dart"><code>void main(List&lt;String&gt; args) {}</code></pre>

<p>If the function isn’t an entry point, then change the name of the function:</p>

<pre class="prettyprint lang-dart"><code>void f(List&lt;int&gt; args) {}</code></pre>

<h3 id="main_has_required_named_parameters">
<a class="anchor" href="#main_has_required_named_parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>main_has_required_named_parameters</h3>

<p><em>The function ‘main’ can’t have any required named parameters.</em></p>

<h4 id="description-224">Description</h4>

<p>The analyzer produces this diagnostic when a function named <code class="language-plaintext highlighter-rouge">main</code> has one
or more required named parameters.</p>

<h4 id="example-201">Example</h4>

<p>The following code produces this diagnostic because the function named
<code class="language-plaintext highlighter-rouge">main</code> has a required named parameter (<code class="language-plaintext highlighter-rouge">x</code>):</p>

<pre class="prettyprint lang-dart"><code>void <span class="highlight">main</span>({required int x}) {}</code></pre>

<h4 id="common-fixes-224">Common fixes</h4>

<p>If the function is an entry point, then remove the <code class="language-plaintext highlighter-rouge">required</code> keyword:</p>

<pre class="prettyprint lang-dart"><code>void main({int? x}) {}</code></pre>

<p>If the function isn’t an entry point, then change the name of the function:</p>

<pre class="prettyprint lang-dart"><code>void f({required int x}) {}</code></pre>

<h3 id="main_has_too_many_required_positional_parameters">
<a class="anchor" href="#main_has_too_many_required_positional_parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>main_has_too_many_required_positional_parameters</h3>

<p><em>The function ‘main’ can’t have more than two required positional parameters.</em></p>

<h4 id="description-225">Description</h4>

<p>The analyzer produces this diagnostic when a function named <code class="language-plaintext highlighter-rouge">main</code> has more
than two required positional parameters.</p>

<h4 id="example-202">Example</h4>

<p>The following code produces this diagnostic because the function <code class="language-plaintext highlighter-rouge">main</code> has
three required positional parameters:</p>

<pre class="prettyprint lang-dart"><code>void <span class="highlight">main</span>(List&lt;String&gt; args, int x, int y) {}</code></pre>

<h4 id="common-fixes-225">Common fixes</h4>

<p>If the function is an entry point and the extra parameters aren’t used,
then remove them:</p>

<pre class="prettyprint lang-dart"><code>void main(List&lt;String&gt; args, int x) {}</code></pre>

<p>If the function is an entry point, but the extra parameters used are for
when the function isn’t being used as an entry point, then make the extra
parameters optional:</p>

<pre class="prettyprint lang-dart"><code>void main(List&lt;String&gt; args, int x, [int y = 0]) {}</code></pre>

<p>If the function isn’t an entry point, then change the name of the function:</p>

<pre class="prettyprint lang-dart"><code>void f(List&lt;String&gt; args, int x, int y) {}</code></pre>

<h3 id="main_is_not_function">
<a class="anchor" href="#main_is_not_function" aria-hidden="true"><span class="octicon octicon-link"></span></a>main_is_not_function</h3>

<p><em>The declaration named ‘main’ must be a function.</em></p>

<h4 id="description-226">Description</h4>

<p>The analyzer produces this diagnostic when a library contains a declaration
of the name <code class="language-plaintext highlighter-rouge">main</code> that isn’t the declaration of a top-level function.</p>

<h4 id="example-203">Example</h4>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">main</code> is
being used to declare a top-level variable:</p>

<pre class="prettyprint lang-dart"><code>var <span class="highlight">main</span> = 3;</code></pre>

<h4 id="common-fixes-226">Common fixes</h4>

<p>Use a different name for the declaration:</p>

<pre class="prettyprint lang-dart"><code>var mainIndex = 3;</code></pre>

<h3 id="map_entry_not_in_map">
<a class="anchor" href="#map_entry_not_in_map" aria-hidden="true"><span class="octicon octicon-link"></span></a>map_entry_not_in_map</h3>

<p><em>Map entries can only be used in a map literal.</em></p>

<h4 id="description-227">Description</h4>

<p>The analyzer produces this diagnostic when a map entry (a key/value pair)
is found in a set literal.</p>

<h4 id="example-204">Example</h4>

<p>The following code produces this diagnostic because the literal has a map
entry even though it’s a set literal:</p>

<pre class="prettyprint lang-dart"><code>const collection = &lt;String&gt;{<span class="highlight">'a' : 'b'</span>};</code></pre>

<h4 id="common-fixes-227">Common fixes</h4>

<p>If you intended for the collection to be a map, then change the code so
that it is a map. In the previous example, you could do this by adding
another type argument:</p>

<pre class="prettyprint lang-dart"><code>const collection = &lt;String, String&gt;{'a' : 'b'};</code></pre>

<p>In other cases, you might need to change the explicit type from <code class="language-plaintext highlighter-rouge">Set</code> to
<code class="language-plaintext highlighter-rouge">Map</code>.</p>

<p>If you intended for the collection to be a set, then remove the map entry,
possibly by replacing the colon with a comma if both values should be
included in the set:</p>

<pre class="prettyprint lang-dart"><code>const collection = &lt;String&gt;{'a', 'b'};</code></pre>

<h3 id="map_key_type_not_assignable">
<a class="anchor" href="#map_key_type_not_assignable" aria-hidden="true"><span class="octicon octicon-link"></span></a>map_key_type_not_assignable</h3>

<p><em>The element type ‘{0}’ can’t be assigned to the map key type ‘{1}’.</em></p>

<h4 id="description-228">Description</h4>

<p>The analyzer produces this diagnostic when a key of a key-value pair in a
map literal has a type that isn’t assignable to the key type of the map.</p>

<h4 id="example-205">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">2</code> is an <code class="language-plaintext highlighter-rouge">int</code>, but
the keys of the map are required to be <code class="language-plaintext highlighter-rouge">String</code>s:</p>

<pre class="prettyprint lang-dart"><code>var m = &lt;String, String&gt;{<span class="highlight">2</span> : 'a'};</code></pre>

<h4 id="common-fixes-228">Common fixes</h4>

<p>If the type of the map is correct, then change the key to have the correct
type:</p>

<pre class="prettyprint lang-dart"><code>var m = &lt;String, String&gt;{'2' : 'a'};</code></pre>

<p>If the type of the key is correct, then change the key type of the map:</p>

<pre class="prettyprint lang-dart"><code>var m = &lt;int, String&gt;{2 : 'a'};</code></pre>

<h3 id="map_value_type_not_assignable">
<a class="anchor" href="#map_value_type_not_assignable" aria-hidden="true"><span class="octicon octicon-link"></span></a>map_value_type_not_assignable</h3>

<p><em>The element type ‘{0}’ can’t be assigned to the map value type ‘{1}’.</em></p>

<h4 id="description-229">Description</h4>

<p>The analyzer produces this diagnostic when a value of a key-value pair in a
map literal has a type that isn’t assignable to the value type of the
map.</p>

<h4 id="example-206">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">2</code> is an <code class="language-plaintext highlighter-rouge">int</code>, but/
the values of the map are required to be <code class="language-plaintext highlighter-rouge">String</code>s:</p>

<pre class="prettyprint lang-dart"><code>var m = &lt;String, String&gt;{'a' : <span class="highlight">2</span>};</code></pre>

<h4 id="common-fixes-229">Common fixes</h4>

<p>If the type of the map is correct, then change the value to have the
correct type:</p>

<pre class="prettyprint lang-dart"><code>var m = &lt;String, String&gt;{'a' : '2'};</code></pre>

<p>If the type of the value is correct, then change the value type of the map:</p>

<pre class="prettyprint lang-dart"><code>var m = &lt;String, int&gt;{'a' : 2};</code></pre>

<h3 id="mismatched_annotation_on_struct_field">
<a class="anchor" href="#mismatched_annotation_on_struct_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>mismatched_annotation_on_struct_field</h3>

<p><em>The annotation doesn’t match the declared type of the field.</em></p>

<h4 id="description-230">Description</h4>

<p>The analyzer produces this diagnostic when the annotation on a field in a
subclass of <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code> doesn’t match the Dart type of the field.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-207">Example</h4>

<p>The following code produces this diagnostic because the annotation
<code class="language-plaintext highlighter-rouge">Double</code> doesn’t match the Dart type <code class="language-plaintext highlighter-rouge">int</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  <span class="highlight">@Double()</span>
  external int x;
}</code></pre>

<h4 id="common-fixes-230">Common fixes</h4>

<p>If the type of the field is correct, then change the annotation to match:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Int32()
  external int x;
}</code></pre>

<p>If the annotation is correct, then change the type of the field to match:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Double()
  external double x;
}</code></pre>

<h3 id="missing_annotation_on_struct_field">
<a class="anchor" href="#missing_annotation_on_struct_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_annotation_on_struct_field</h3>

<p><em>Fields of type ‘{0}’ in a subclass of ‘{1}’ must have an annotation indicating
the native type.</em></p>

<h4 id="description-231">Description</h4>

<p>The analyzer produces this diagnostic when a field in a subclass of
<code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code> whose type requires an annotation doesn’t have one.
The Dart types <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">double</code>, and <code class="language-plaintext highlighter-rouge">Array</code> are used to represent multiple
C types, and the annotation specifies which of the compatible C types the
field represents.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-208">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">x</code> doesn’t
have an annotation indicating the underlying width of the integer value:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  external <span class="highlight">int</span> x;
}</code></pre>

<h4 id="common-fixes-231">Common fixes</h4>

<p>Add an appropriate annotation to the field:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Int64()
  external int x;
}</code></pre>

<h3 id="missing_dart_library">
<a class="anchor" href="#missing_dart_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_dart_library</h3>

<p><em>Required library ‘{0}’ is missing.</em></p>

<h4 id="description-232">Description</h4>

<p>The analyzer produces this diagnostic when either the Dart or Flutter SDK
isn’t installed correctly, and, as a result, one of the <code class="language-plaintext highlighter-rouge">dart:</code> libraries
can’t be found.</p>

<h4 id="common-fixes-232">Common fixes</h4>

<p>Reinstall the Dart or Flutter SDK.</p>

<h3 id="missing_default_value_for_parameter">
<a class="anchor" href="#missing_default_value_for_parameter" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_default_value_for_parameter</h3>

<p><em>The parameter ‘{0}’ can’t have a value of ‘null’ because of its type, but the
implicit default value is ‘null’.</em></p>

<p><em>With null safety, use the ‘required’ keyword, not the ‘@required’ annotation.</em></p>

<h4 id="description-233">Description</h4>

<p>The analyzer produces this diagnostic when an optional parameter, whether
positional or named, has a <a href="#potentially-non-nullable">potentially non-nullable</a> type and doesn’t
specify a default value. Optional parameters that have no explicit default
value have an implicit default value of <code class="language-plaintext highlighter-rouge">null</code>. If the type of the
parameter doesn’t allow the parameter to have a value of <code class="language-plaintext highlighter-rouge">null</code>, then the
implicit default value isn’t valid.</p>

<h4 id="examples-23">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> can’t be <code class="language-plaintext highlighter-rouge">null</code>,
and no non-<code class="language-plaintext highlighter-rouge">null</code> default value is specified:</p>

<pre class="prettyprint lang-dart"><code>void f([int <span class="highlight">x</span>]) {}</code></pre>

<p>As does this:</p>

<pre class="prettyprint lang-dart"><code>void g({int <span class="highlight">x</span>}) {}</code></pre>

<h4 id="common-fixes-233">Common fixes</h4>

<p>If you want to use <code class="language-plaintext highlighter-rouge">null</code> to indicate that no value was provided, then you
need to make the type nullable:</p>

<pre class="prettyprint lang-dart"><code>void f([int? x]) {}
void g({int? x}) {}</code></pre>

<p>If the parameter can’t be null, then either provide a default value:</p>

<pre class="prettyprint lang-dart"><code>void f([int x = 1]) {}
void g({int x = 2}) {}</code></pre>

<p>or make the parameter a required parameter:</p>

<pre class="prettyprint lang-dart"><code>void f(int x) {}
void g({required int x}) {}</code></pre>

<h3 id="missing_enum_constant_in_switch">
<a class="anchor" href="#missing_enum_constant_in_switch" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_enum_constant_in_switch</h3>

<p><em>Missing case clause for ‘{0}’.</em></p>

<h4 id="description-234">Description</h4>

<p>The analyzer produces this diagnostic when a <code class="language-plaintext highlighter-rouge">switch</code> statement for an enum
doesn’t include an option for one of the values in the enum.</p>

<p>Note that <code class="language-plaintext highlighter-rouge">null</code> is always a possible value for an enum and therefore also
must be handled.</p>

<h4 id="example-209">Example</h4>

<p>The following code produces this diagnostic because the enum constant <code class="language-plaintext highlighter-rouge">e2</code>
isn’t handled:</p>

<pre class="prettyprint lang-dart"><code>enum E { e1, e2 }

void f(E e) {
  <span class="highlight">switch (e)</span> {
    case E.e1:
      break;
  }
}</code></pre>

<h4 id="common-fixes-234">Common fixes</h4>

<p>If there’s special handling for the missing values, then add a <code class="language-plaintext highlighter-rouge">case</code>
clause for each of the missing values:</p>

<pre class="prettyprint lang-dart"><code>enum E { e1, e2 }

void f(E e) {
  switch (e) {
    case E.e1:
      break;
    case E.e2:
      break;
  }
}</code></pre>

<p>If the missing values should be handled the same way, then add a <code class="language-plaintext highlighter-rouge">default</code>
clause:</p>

<pre class="prettyprint lang-dart"><code>enum E { e1, e2 }

void f(E e) {
  switch (e) {
    case E.e1:
      break;
    default:
      break;
  }
}</code></pre>

<h3 id="missing_exception_value">
<a class="anchor" href="#missing_exception_value" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_exception_value</h3>

<p><em>The method ‘Pointer.fromFunction’ must have an exceptional return value (the
second argument) when the return type of the function is neither ‘void’, ‘Handle’, nor ‘Pointer’.</em></p>

<h4 id="description-235">Description</h4>

<p>The analyzer produces this diagnostic when an invocation of the method
<code class="language-plaintext highlighter-rouge">Pointer.fromFunction</code> doesn’t have a second argument (the exceptional
return value) when the type to be returned from the invocation is neither
<code class="language-plaintext highlighter-rouge">void</code>, <code class="language-plaintext highlighter-rouge">Handle</code>, nor <code class="language-plaintext highlighter-rouge">Pointer</code>.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-210">Example</h4>

<p>The following code produces this diagnostic because the type returned by
<code class="language-plaintext highlighter-rouge">f</code> is expected to be an 8-bit integer but the call to <code class="language-plaintext highlighter-rouge">fromFunction</code>
doesn’t include an exceptional return argument:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

int f(int i) =&gt; i * 2;

void g() {
  Pointer.<span class="highlight">fromFunction</span>&lt;Int8 Function(Int8)&gt;(f);
}</code></pre>

<h4 id="common-fixes-235">Common fixes</h4>

<p>Add an exceptional return type:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

int f(int i) =&gt; i * 2;

void g() {
  Pointer.fromFunction&lt;Int8 Function(Int8)&gt;(f, 0);
}</code></pre>

<h3 id="missing_field_type_in_struct">
<a class="anchor" href="#missing_field_type_in_struct" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_field_type_in_struct</h3>

<p><em>Fields in struct classes must have an explicitly declared type of ‘int’,
‘double’ or ‘Pointer’.</em></p>

<h4 id="description-236">Description</h4>

<p>The analyzer produces this diagnostic when a field in a subclass of
<code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code> doesn’t have a type annotation. Every field must have
an explicit type, and the type must either be <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">Pointer</code>,
or a subclass of either <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code>.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-211">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">str</code>
doesn’t have a type annotation:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  external var <span class="highlight">str</span>;

  @Int32()
  external int i;
}</code></pre>

<h4 id="common-fixes-236">Common fixes</h4>

<p>Explicitly specify the type of the field:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';
import 'package:ffi/ffi.dart';

class C extends Struct {
  external Pointer&lt;Utf8&gt; str;

  @Int32()
  external int i;
}</code></pre>

<h3 id="missing_name">
<a class="anchor" href="#missing_name" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_name</h3>

<p><em>The ‘name’ field is required but missing.</em></p>

<h4 id="description-237">Description</h4>

<p>The analyzer produces this diagnostic when there’s no top-level <code class="language-plaintext highlighter-rouge">name</code> key.
The <code class="language-plaintext highlighter-rouge">name</code> key provides the name of the package, which is required.</p>

<h4 id="example-212">Example</h4>

<p>The following code produces this diagnostic because the package doesn’t
have a name:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">meta</span><span class="pi">:</span> <span class="s">^1.0.2</span>
</code></pre></div></div>

<h4 id="common-fixes-237">Common fixes</h4>

<p>Add the top-level key <code class="language-plaintext highlighter-rouge">name</code> with a value that’s the name of the package:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">meta</span><span class="pi">:</span> <span class="s">^1.0.2</span>
</code></pre></div></div>

<h3 id="missing_required_argument">
<a class="anchor" href="#missing_required_argument" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_required_argument</h3>

<p><em>The named parameter ‘{0}’ is required, but there’s no corresponding argument.</em></p>

<h4 id="description-238">Description</h4>

<p>The analyzer produces this diagnostic when an invocation of a function is
missing a required named parameter.</p>

<h4 id="example-213">Example</h4>

<p>The following code produces this diagnostic because the invocation of <code class="language-plaintext highlighter-rouge">f</code>
doesn’t include a value for the required named parameter <code class="language-plaintext highlighter-rouge">end</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(int start, {required int end}) {}
void g() {
  <span class="highlight">f</span>(3);
}</code></pre>

<h4 id="common-fixes-238">Common fixes</h4>

<p>Add a named argument corresponding to the missing required parameter:</p>

<pre class="prettyprint lang-dart"><code>void f(int start, {required int end}) {}
void g() {
  f(3, end: 5);
}</code></pre>

<h3 id="missing_required_param">
<a class="anchor" href="#missing_required_param" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_required_param</h3>

<p><em>The parameter ‘{0}’ is required.</em></p>

<p><em>The parameter ‘{0}’ is required. {1}.</em></p>

<h4 id="description-239">Description</h4>

<p>The analyzer produces this diagnostic when a method or function with a
named parameter that is annotated as being required is invoked without
providing a value for the parameter.</p>

<h4 id="example-214">Example</h4>

<p>The following code produces this diagnostic because the named parameter <code class="language-plaintext highlighter-rouge">x</code>
is required:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

void f({@required int x}) {}

void g() {
  <span class="highlight">f</span>();
}</code></pre>

<h4 id="common-fixes-239">Common fixes</h4>

<p>Provide the required value:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

void f({@required int x}) {}

void g() {
  f(x: 2);
}</code></pre>

<h3 id="missing_return">
<a class="anchor" href="#missing_return" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_return</h3>

<p><em>This function has a return type of ‘{0}’, but doesn’t end with a return
statement.</em></p>

<h4 id="description-240">Description</h4>

<p>Any function or method that doesn’t end with either an explicit return or a
throw implicitly returns <code class="language-plaintext highlighter-rouge">null</code>. This is rarely the desired behavior. The
analyzer produces this diagnostic when it finds an implicit return.</p>

<h4 id="example-215">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> doesn’t end with a
return:</p>

<pre class="prettyprint lang-dart"><code>int <span class="highlight">f</span>(int x) {
  if (x &lt; 0) {
    return 0;
  }
}</code></pre>

<h4 id="common-fixes-240">Common fixes</h4>

<p>Add a <code class="language-plaintext highlighter-rouge">return</code> statement that makes the return value explicit, even if
<code class="language-plaintext highlighter-rouge">null</code> is the appropriate value.</p>

<h3 id="missing_size_annotation_carray">
<a class="anchor" href="#missing_size_annotation_carray" aria-hidden="true"><span class="octicon octicon-link"></span></a>missing_size_annotation_carray</h3>

<p><em>Fields of type ‘Array’ must have exactly one ‘Array’ annotation.</em></p>

<h4 id="description-241">Description</h4>

<p>The analyzer produces this diagnostic when a field in a subclass of either
<code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code> has a type of <code class="language-plaintext highlighter-rouge">Array</code> but doesn’t have a single
<code class="language-plaintext highlighter-rouge">Array</code> annotation indicating the dimensions of the array.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-216">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">a0</code> doesn’t
have an <code class="language-plaintext highlighter-rouge">Array</code> annotation:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  external <span class="highlight">Array&lt;Uint8&gt;</span> a0;
}</code></pre>

<h4 id="common-fixes-241">Common fixes</h4>

<p>Ensure that there’s exactly one <code class="language-plaintext highlighter-rouge">Array</code> annotation on the field:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Array(8)
  external Array&lt;Uint8&gt; a0;
}</code></pre>

<h3 id="mixin_application_concrete_super_invoked_member_type">
<a class="anchor" href="#mixin_application_concrete_super_invoked_member_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin_application_concrete_super_invoked_member_type</h3>

<p><em>The super-invoked member ‘{0}’ has the type ‘{1}’, and the concrete member in
the class has the type ‘{2}’.</em></p>

<h4 id="description-242">Description</h4>

<p>The analyzer produces this diagnostic when a mixin that invokes a method
using <code class="language-plaintext highlighter-rouge">super</code> is used in a class where the concrete implementation of that
method has a different signature than the signature defined for that method
by the mixin’s <code class="language-plaintext highlighter-rouge">on</code> type. The reason this is an error is because the
invocation in the mixin might invoke the method in a way that’s
incompatible with the method that will actually be executed.</p>

<h4 id="example-217">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code> uses the
mixin <code class="language-plaintext highlighter-rouge">M</code>, the mixin <code class="language-plaintext highlighter-rouge">M</code> invokes <code class="language-plaintext highlighter-rouge">foo</code> using <code class="language-plaintext highlighter-rouge">super</code>, and the abstract
version of <code class="language-plaintext highlighter-rouge">foo</code> declared in <code class="language-plaintext highlighter-rouge">I</code> (the mixin’s <code class="language-plaintext highlighter-rouge">on</code> type) doesn’t have the
same signature as the concrete version of <code class="language-plaintext highlighter-rouge">foo</code> declared in <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>class I {
  void foo([int? p]) {}
}

class A {
  void foo(int p) {}
}

abstract class B extends A implements I {
  @override
  void foo([int? p]);
}

mixin M on I {
  void bar() {
    super.foo(42);
  }
}

abstract class C extends B with <span class="highlight">M</span> {}</code></pre>

<h4 id="common-fixes-242">Common fixes</h4>

<p>If the class doesn’t need to use the mixin, then remove it from the <code class="language-plaintext highlighter-rouge">with</code>
clause:</p>

<pre class="prettyprint lang-dart"><code>class I {
  void foo([int? p]) {}
}

class A {
  void foo(int? p) {}
}

abstract class B extends A implements I {
  @override
  void foo([int? p]);
}

mixin M on I {
  void bar() {
    super.foo(42);
  }
}

abstract class C extends B {}</code></pre>

<p>If the class needs to use the mixin, then ensure that there’s a concrete
implementation of the method that conforms to the signature expected by the
mixin:</p>

<pre class="prettyprint lang-dart"><code>class I {
  void foo([int? p]) {}
}

class A {
  void foo(int? p) {}
}

abstract class B extends A implements I {
  @override
  void foo([int? p]) {
    super.foo(p);
  }
}

mixin M on I {
  void bar() {
    super.foo(42);
  }
}

abstract class C extends B with M {}</code></pre>

<h3 id="mixin_application_not_implemented_interface">
<a class="anchor" href="#mixin_application_not_implemented_interface" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin_application_not_implemented_interface</h3>

<p><em>‘{0}’ can’t be mixed onto ‘{1}’ because ‘{1}’ doesn’t implement ‘{2}’.</em></p>

<h4 id="description-243">Description</h4>

<p>The analyzer produces this diagnostic when a mixin that has a superclass
constraint is used in a <a href="#mixin-application">mixin application</a> with a superclass that
doesn’t implement the required constraint.</p>

<h4 id="example-218">Example</h4>

<p>The following code produces this diagnostic because the mixin <code class="language-plaintext highlighter-rouge">M</code> requires
that the class to which it’s applied be a subclass of <code class="language-plaintext highlighter-rouge">A</code>, but <code class="language-plaintext highlighter-rouge">Object</code>
isn’t a subclass of <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {}

mixin M on A {}

class X = Object with <span class="highlight">M</span>;</code></pre>

<h4 id="common-fixes-243">Common fixes</h4>

<p>If you need to use the mixin, then change the superclass to be either the
same as or a subclass of the superclass constraint:</p>

<pre class="prettyprint lang-dart"><code>class A {}

mixin M on A {}

class X = A with M;</code></pre>

<h3 id="mixin_application_no_concrete_super_invoked_member">
<a class="anchor" href="#mixin_application_no_concrete_super_invoked_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin_application_no_concrete_super_invoked_member</h3>

<p><em>The class doesn’t have a concrete implementation of the super-invoked member
‘{0}’.</em></p>

<h4 id="description-244">Description</h4>

<p>The analyzer produces this diagnostic when a <a href="#mixin-application">mixin application</a> contains
an invocation of a member from its superclass, and there’s no concrete
member of that name in the mixin application’s superclass.</p>

<h4 id="example-219">Example</h4>

<p>The following code produces this diagnostic because the mixin <code class="language-plaintext highlighter-rouge">M</code> contains
the invocation <code class="language-plaintext highlighter-rouge">super.m()</code>, and the class <code class="language-plaintext highlighter-rouge">A</code>, which is the superclass of
the <a href="#mixin-application">mixin application</a> <code class="language-plaintext highlighter-rouge">A+M</code>, doesn’t define a concrete implementation
of <code class="language-plaintext highlighter-rouge">m</code>:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  void m();
}

mixin M on A {
  void bar() {
    super.m();
  }
}

abstract class B extends A with <span class="highlight">M</span> {}</code></pre>

<h4 id="common-fixes-244">Common fixes</h4>

<p>If you intended to apply the mixin <code class="language-plaintext highlighter-rouge">M</code> to a different class, one that has a
concrete implementation of <code class="language-plaintext highlighter-rouge">m</code>, then change the superclass of <code class="language-plaintext highlighter-rouge">B</code> to that
class:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  void m();
}

mixin M on A {
  void bar() {
    super.m();
  }
}

class C implements A {
  void m() {}
}

abstract class B extends C with M {}</code></pre>

<p>If you need to make <code class="language-plaintext highlighter-rouge">B</code> a subclass of <code class="language-plaintext highlighter-rouge">A</code>, then add a concrete
implementation of <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  void m() {}
}

mixin M on A {
  void bar() {
    super.m();
  }
}

abstract class B extends A with M {}</code></pre>

<h3 id="mixin_class_declares_constructor">
<a class="anchor" href="#mixin_class_declares_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin_class_declares_constructor</h3>

<p><em>The class ‘{0}’ can’t be used as a mixin because it declares a constructor.</em></p>

<h4 id="description-245">Description</h4>

<p>The analyzer produces this diagnostic when a class is used as a mixin and
the mixed-in class defines a constructor.</p>

<h4 id="example-220">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">A</code>, which
defines a constructor, is being used as a mixin:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A();
}

class B with <span class="highlight">A</span> {}</code></pre>

<h4 id="common-fixes-245">Common fixes</h4>

<p>If it’s possible to convert the class to a mixin, then do so:</p>

<pre class="prettyprint lang-dart"><code>mixin A {
}

class B with A {}</code></pre>

<p>If the class can’t be a mixin and it’s possible to remove the constructor,
then do so:</p>

<pre class="prettyprint lang-dart"><code>class A {
}

class B with A {}</code></pre>

<p>If the class can’t be a mixin and you can’t remove the constructor, then
try extending or implementing the class rather than mixing it in:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A();
}

class B extends A {}</code></pre>

<h3 id="mixin_inherits_from_not_object">
<a class="anchor" href="#mixin_inherits_from_not_object" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin_inherits_from_not_object</h3>

<p><em>The class ‘{0}’ can’t be used as a mixin because it extends a class other than
‘Object’.</em></p>

<h4 id="description-246">Description</h4>

<p>The analyzer produces this diagnostic when a class that extends a class
other than <code class="language-plaintext highlighter-rouge">Object</code> is used as a mixin.</p>

<h4 id="example-221">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">B</code>, which
extends <code class="language-plaintext highlighter-rouge">A</code>, is being used as a mixin by <code class="language-plaintext highlighter-rouge">C</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class B extends A {}

class C with <span class="highlight">B</span> {}</code></pre>

<h4 id="common-fixes-246">Common fixes</h4>

<p>If the class being used as a mixin can be changed to extend <code class="language-plaintext highlighter-rouge">Object</code>, then
change it:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class B {}

class C with B {}</code></pre>

<p>If the class being used as a mixin can’t be changed and the class that’s
using it extends <code class="language-plaintext highlighter-rouge">Object</code>, then extend the class being used as a mixin:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class B extends A {}

class C extends B {}</code></pre>

<p>If the class doesn’t extend <code class="language-plaintext highlighter-rouge">Object</code> or if you want to be able to mix in
the behavior from <code class="language-plaintext highlighter-rouge">B</code> in other places, then create a real mixin:</p>

<pre class="prettyprint lang-dart"><code>class A {}

mixin M on A {}

class B extends A with M {}

class C extends A with M {}</code></pre>

<h3 id="mixin_instantiate">
<a class="anchor" href="#mixin_instantiate" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin_instantiate</h3>

<p><em>Mixins can’t be instantiated.</em></p>

<h4 id="description-247">Description</h4>

<p>The analyzer produces this diagnostic when a mixin is instantiated.</p>

<h4 id="example-222">Example</h4>

<p>The following code produces this diagnostic because the mixin <code class="language-plaintext highlighter-rouge">M</code> is being
instantiated:</p>

<pre class="prettyprint lang-dart"><code>mixin M {}

var m = <span class="highlight">M</span>();</code></pre>

<h4 id="common-fixes-247">Common fixes</h4>

<p>If you intend to use an instance of a class, then use the name of that
class in place of the name of the mixin.</p>

<h3 id="mixin_of_non_class">
<a class="anchor" href="#mixin_of_non_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin_of_non_class</h3>

<p><em>Classes can only mix in mixins and classes.</em></p>

<h4 id="description-248">Description</h4>

<p>The analyzer produces this diagnostic when a name in a <code class="language-plaintext highlighter-rouge">with</code> clause is
defined to be something other than a mixin or a class.</p>

<h4 id="example-223">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">F</code> is defined to be a
function type:</p>

<pre class="prettyprint lang-dart"><code>typedef F = int Function(String);

class C with <span class="highlight">F</span> {}</code></pre>

<h4 id="common-fixes-248">Common fixes</h4>

<p>Remove the invalid name from the list, possibly replacing it with the name
of the intended mixin or class:</p>

<pre class="prettyprint lang-dart"><code>typedef F = int Function(String);

class C {}</code></pre>

<h3 id="mixin_on_sealed_class">
<a class="anchor" href="#mixin_on_sealed_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin_on_sealed_class</h3>

<p><em>The class ‘{0}’ shouldn’t be used as a mixin constraint because it is sealed,
and any class mixing in this mixin must have ‘{0}’ as a superclass.</em></p>

<h4 id="description-249">Description</h4>

<p>The analyzer produces this diagnostic when the superclass constraint of a
mixin is a class from a different package that was marked as
<code class="language-plaintext highlighter-rouge">[sealed][meta-sealed]</code>. Classes that are sealed can’t be extended,
implemented, mixed in, or used as a superclass constraint.</p>

<h4 id="example-224">Example</h4>

<p>If the package <code class="language-plaintext highlighter-rouge">p</code> defines a sealed class:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@sealed
class C {}</code></pre>

<p>Then, the following code, when in a package other than <code class="language-plaintext highlighter-rouge">p</code>, produces this
diagnostic:</p>

<pre class="prettyprint lang-dart"><code>import 'package:p/p.dart';

<span class="highlight">mixin M on C {}</span></code></pre>

<h4 id="common-fixes-249">Common fixes</h4>

<p>If the classes that use the mixin don’t need to be subclasses of the sealed
class, then consider adding a field and delegating to the wrapped instance
of the sealed class.</p>

<h3 id="mixin_super_class_constraint_deferred_class">
<a class="anchor" href="#mixin_super_class_constraint_deferred_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin_super_class_constraint_deferred_class</h3>

<p><em>Deferred classes can’t be used as superclass constraints.</em></p>

<h4 id="description-250">Description</h4>

<p>The analyzer produces this diagnostic when a superclass constraint of a
mixin is imported from a deferred library.</p>

<h4 id="example-225">Example</h4>

<p>The following code produces this diagnostic because the superclass
constraint of <code class="language-plaintext highlighter-rouge">math.Random</code> is imported from a deferred library:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:async' deferred as async;

mixin M&lt;T&gt; on <span class="highlight">async.Stream&lt;T&gt;</span> {}</code></pre>

<h4 id="common-fixes-250">Common fixes</h4>

<p>If the import doesn’t need to be deferred, then remove the <code class="language-plaintext highlighter-rouge">deferred</code>
keyword:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:async' as async;

mixin M&lt;T&gt; on async.Stream&lt;T&gt; {}</code></pre>

<p>If the import does need to be deferred, then remove the superclass
constraint:</p>

<pre class="prettyprint lang-dart"><code>mixin M&lt;T&gt; {}</code></pre>

<h3 id="mixin_super_class_constraint_non_interface">
<a class="anchor" href="#mixin_super_class_constraint_non_interface" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixin_super_class_constraint_non_interface</h3>

<p><em>Only classes and mixins can be used as superclass constraints.</em></p>

<h4 id="description-251">Description</h4>

<p>The analyzer produces this diagnostic when a type following the <code class="language-plaintext highlighter-rouge">on</code>
keyword in a mixin declaration is neither a class nor a mixin.</p>

<h4 id="example-226">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">F</code> is neither a class
nor a mixin:</p>

<pre class="prettyprint lang-dart"><code>typedef F = void Function();

mixin M on <span class="highlight">F</span> {}</code></pre>

<h4 id="common-fixes-251">Common fixes</h4>

<p>If the type was intended to be a class but was mistyped, then replace the
name.</p>

<p>Otherwise, remove the type from the <code class="language-plaintext highlighter-rouge">on</code> clause.</p>

<h3 id="multiple_redirecting_constructor_invocations">
<a class="anchor" href="#multiple_redirecting_constructor_invocations" aria-hidden="true"><span class="octicon octicon-link"></span></a>multiple_redirecting_constructor_invocations</h3>

<p><em>Constructors can have only one ‘this’ redirection, at most.</em></p>

<h4 id="description-252">Description</h4>

<p>The analyzer produces this diagnostic when a constructor redirects to more
than one other constructor in the same class (using <code class="language-plaintext highlighter-rouge">this</code>).</p>

<h4 id="example-227">Example</h4>

<p>The following code produces this diagnostic because the unnamed
constructor in <code class="language-plaintext highlighter-rouge">C</code> is redirecting to both <code class="language-plaintext highlighter-rouge">this.a</code> and <code class="language-plaintext highlighter-rouge">this.b</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C() : this.a(), <span class="highlight">this.b()</span>;
  C.a();
  C.b();
}</code></pre>

<h4 id="common-fixes-252">Common fixes</h4>

<p>Remove all but one of the redirections:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C() : this.a();
  C.a();
  C.b();
}</code></pre>

<h3 id="multiple_super_initializers">
<a class="anchor" href="#multiple_super_initializers" aria-hidden="true"><span class="octicon octicon-link"></span></a>multiple_super_initializers</h3>

<p><em>A constructor can have at most one ‘super’ initializer.</em></p>

<h4 id="description-253">Description</h4>

<p>The analyzer produces this diagnostic when the initializer list of a
constructor contains more than one invocation of a constructor from the
superclass. The initializer list is required to have exactly one such call,
which can either be explicit or implicit.</p>

<h4 id="example-228">Example</h4>

<p>The following code produces this diagnostic because the initializer list
for <code class="language-plaintext highlighter-rouge">B</code>’s constructor invokes both the constructor <code class="language-plaintext highlighter-rouge">one</code> and the
constructor <code class="language-plaintext highlighter-rouge">two</code> from the superclass <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  int? x;
  String? s;
  A.one(this.x);
  A.two(this.s);
}

class B extends A {
  B() : super.one(0), <span class="highlight">super.two('')</span>;
}</code></pre>

<h4 id="common-fixes-253">Common fixes</h4>

<p>If one of the super constructors will initialize the instance fully, then
remove the other:</p>

<pre class="prettyprint lang-dart"><code>class A {
  int? x;
  String? s;
  A.one(this.x);
  A.two(this.s);
}

class B extends A {
  B() : super.one(0);
}</code></pre>

<p>If the initialization achieved by one of the super constructors can be
performed in the body of the constructor, then remove its super invocation
and perform the initialization in the body:</p>

<pre class="prettyprint lang-dart"><code>class A {
  int? x;
  String? s;
  A.one(this.x);
  A.two(this.s);
}

class B extends A {
  B() : super.one(0) {
    s = '';
  }
}</code></pre>

<p>If the initialization can only be performed in a constructor in the
superclass, then either add a new constructor or modify one of the existing
constructors so there’s a constructor that allows all the required
initialization to occur in a single call:</p>

<pre class="prettyprint lang-dart"><code>class A {
  int? x;
  String? s;
  A.one(this.x);
  A.two(this.s);
  A.three(this.x, this.s);
}

class B extends A {
  B() : super.three(0, '');
}</code></pre>

<h3 id="must_be_a_native_function_type">
<a class="anchor" href="#must_be_a_native_function_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>must_be_a_native_function_type</h3>

<p><em>The type ‘{0}’ given to ‘{1}’ must be a valid ‘dart:ffi’ native function type.</em></p>

<h4 id="description-254">Description</h4>

<p>The analyzer produces this diagnostic when an invocation of either
<code class="language-plaintext highlighter-rouge">Pointer.fromFunction</code> or <code class="language-plaintext highlighter-rouge">DynamicLibrary.lookupFunction</code> has a type
argument(whether explicit or inferred) that isn’t a native function type.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-229">Example</h4>

<p>The following code produces this diagnostic because the type <code class="language-plaintext highlighter-rouge">T</code> can be
any subclass of <code class="language-plaintext highlighter-rouge">Function</code> but the type argument for <code class="language-plaintext highlighter-rouge">fromFunction</code> is
required to be a native function type:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

int f(int i) =&gt; i * 2;

class C&lt;T extends Function&gt; {
  void g() {
    Pointer.fromFunction&lt;<span class="highlight">T</span>&gt;(f, 0);
  }
}</code></pre>

<h4 id="common-fixes-254">Common fixes</h4>

<p>Use a native function type as the type argument to the invocation:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

int f(int i) =&gt; i * 2;

class C&lt;T extends Function&gt; {
  void g() {
    Pointer.fromFunction&lt;Int32 Function(Int32)&gt;(f, 0);
  }
}</code></pre>

<h3 id="must_be_a_subtype">
<a class="anchor" href="#must_be_a_subtype" aria-hidden="true"><span class="octicon octicon-link"></span></a>must_be_a_subtype</h3>

<p><em>The type ‘{0}’ must be a subtype of ‘{1}’ for ‘{2}’.</em></p>

<h4 id="description-255">Description</h4>

<p>The analyzer produces this diagnostic in two cases:</p>
<ul>
  <li>In an invocation of <code class="language-plaintext highlighter-rouge">Pointer.fromFunction</code> where the type argument
(whether explicit or inferred) isn’t a supertype of the type of the
function passed as the first argument to the method.</li>
  <li>In an invocation of <code class="language-plaintext highlighter-rouge">DynamicLibrary.lookupFunction</code> where the first type
argument isn’t a supertype of the second type argument.</li>
</ul>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-230">Example</h4>

<p>The following code produces this diagnostic because the type of the
function <code class="language-plaintext highlighter-rouge">f</code> (<code class="language-plaintext highlighter-rouge">String Function(int)</code>) isn’t a subtype of the type
argument <code class="language-plaintext highlighter-rouge">T</code> (<code class="language-plaintext highlighter-rouge">Int8 Function(Int8)</code>):</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

typedef T = Int8 Function(Int8);

double f(double i) =&gt; i;

void g() {
  Pointer.fromFunction&lt;T&gt;(<span class="highlight">f</span>, 5.0);
}</code></pre>

<h4 id="common-fixes-255">Common fixes</h4>

<p>If the function is correct, then change the type argument to match:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

typedef T = Float Function(Float);

double f(double i) =&gt; i;

void g() {
  Pointer.fromFunction&lt;T&gt;(f, 5.0);
}</code></pre>

<p>If the type argument is correct, then change the function to match:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

typedef T = Int8 Function(Int8);

int f(int i) =&gt; i;

void g() {
  Pointer.fromFunction&lt;T&gt;(f, 5);
}</code></pre>

<h3 id="must_be_immutable">
<a class="anchor" href="#must_be_immutable" aria-hidden="true"><span class="octicon octicon-link"></span></a>must_be_immutable</h3>

<p><em>This class (or a class that this class inherits from) is marked as
‘@immutable’, but one or more of its instance fields aren’t final: {0}</em></p>

<h4 id="description-256">Description</h4>

<p>The analyzer produces this diagnostic when an immutable class defines one
or more instance fields that aren’t final. A class is immutable if it’s
marked as being immutable using the annotation
<code class="language-plaintext highlighter-rouge">[immutable][meta-immutable]</code> or if it’s a subclass of an immutable class.</p>

<h4 id="example-231">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">x</code> isn’t
final:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@immutable
class <span class="highlight">C</span> {
  int x;

  C(this.x);
}</code></pre>

<h4 id="common-fixes-256">Common fixes</h4>

<p>If instances of the class should be immutable, then add the keyword <code class="language-plaintext highlighter-rouge">final</code>
to all non-final field declarations:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@immutable
class C {
  final int x;

  C(this.x);
}</code></pre>

<p>If the instances of the class should be mutable, then remove the
annotation, or choose a different superclass if the annotation is
inherited:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  C(this.x);
}</code></pre>

<h3 id="must_call_super">
<a class="anchor" href="#must_call_super" aria-hidden="true"><span class="octicon octicon-link"></span></a>must_call_super</h3>

<p><em>This method overrides a method annotated as ‘@mustCallSuper’ in ‘{0}’, but
doesn’t invoke the overridden method.</em></p>

<h4 id="description-257">Description</h4>

<p>The analyzer produces this diagnostic when a method that overrides a method
that is annotated as <code class="language-plaintext highlighter-rouge">[mustCallSuper][meta-mustCallSuper]</code> doesn’t invoke
the overridden method as required.</p>

<h4 id="example-232">Example</h4>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">B</code>
doesn’t invoke the overridden method <code class="language-plaintext highlighter-rouge">m</code> in <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class A {
  @mustCallSuper
  m() {}
}

class B extends A {
  @override
  <span class="highlight">m</span>() {}
}</code></pre>

<h4 id="common-fixes-257">Common fixes</h4>

<p>Add an invocation of the overridden method in the overriding method:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class A {
  @mustCallSuper
  m() {}
}

class B extends A {
  @override
  m() {
    super.m();
  }
}</code></pre>

<h3 id="name_not_string">
<a class="anchor" href="#name_not_string" aria-hidden="true"><span class="octicon octicon-link"></span></a>name_not_string</h3>

<p><em>The value of the ‘name’ field is required to be a string.</em></p>

<h4 id="description-258">Description</h4>

<p>The analyzer produces this diagnostic when the top-level <code class="language-plaintext highlighter-rouge">name</code> key has a
value that isn’t a string.</p>

<h4 id="example-233">Example</h4>

<p>The following code produces this diagnostic because the value following the
<code class="language-plaintext highlighter-rouge">name</code> key is a list:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">example</span>
</code></pre></div></div>

<h4 id="common-fixes-258">Common fixes</h4>

<p>Replace the value with a string:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
</code></pre></div></div>

<h3 id="new_with_undefined_constructor_default">
<a class="anchor" href="#new_with_undefined_constructor_default" aria-hidden="true"><span class="octicon octicon-link"></span></a>new_with_undefined_constructor_default</h3>

<p><em>The class ‘{0}’ doesn’t have an unnamed constructor.</em></p>

<h4 id="description-259">Description</h4>

<p>The analyzer produces this diagnostic when an unnamed constructor is
invoked on a class that defines named constructors but the class doesn’t
have an unnamed constructor.</p>

<h4 id="example-234">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">A</code> doesn’t define an
unnamed constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A.a();
}

A f() =&gt; <span class="highlight">A</span>();</code></pre>

<h4 id="common-fixes-259">Common fixes</h4>

<p>If one of the named constructors does what you need, then use it:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A.a();
}

A f() =&gt; A.a();</code></pre>

<p>If none of the named constructors does what you need, and you’re able to
add an unnamed constructor, then add the constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A();
  A.a();
}

A f() =&gt; A();</code></pre>

<h3 id="non_abstract_class_inherits_abstract_member">
<a class="anchor" href="#non_abstract_class_inherits_abstract_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_abstract_class_inherits_abstract_member</h3>

<p><em>Missing concrete implementation of ‘{0}’.</em></p>

<p><em>Missing concrete implementations of ‘{0}’ and ‘{1}’.</em></p>

<p><em>Missing concrete implementations of ‘{0}’, ‘{1}’, ‘{2}’, ‘{3}’, and {4} more.</em></p>

<p><em>Missing concrete implementations of ‘{0}’, ‘{1}’, ‘{2}’, and ‘{3}’.</em></p>

<p><em>Missing concrete implementations of ‘{0}’, ‘{1}’, and ‘{2}’.</em></p>

<h4 id="description-260">Description</h4>

<p>The analyzer produces this diagnostic when a concrete class inherits one or
more abstract members, and doesn’t provide or inherit an implementation for
at least one of those abstract members.</p>

<h4 id="example-235">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">B</code> doesn’t
have a concrete implementation of <code class="language-plaintext highlighter-rouge">m</code>:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  void m();
}

class <span class="highlight">B</span> extends A {}</code></pre>

<h4 id="common-fixes-260">Common fixes</h4>

<p>If the subclass can provide a concrete implementation for some or all of
the abstract inherited members, then add the concrete implementations:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  void m();
}

class B extends A {
  void m() {}
}</code></pre>

<p>If there is a mixin that provides an implementation of the inherited
methods, then apply the mixin to the subclass:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  void m();
}

class B extends A with M {}

mixin M {
  void m() {}
}</code></pre>

<p>If the subclass can’t provide a concrete implementation for all of the
abstract inherited members, then mark the subclass as being abstract:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  void m();
}

abstract class B extends A {}</code></pre>

<h3 id="non_bool_condition">
<a class="anchor" href="#non_bool_condition" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_bool_condition</h3>

<p><em>Conditions must have a static type of ‘bool’.</em></p>

<h4 id="description-261">Description</h4>

<p>The analyzer produces this diagnostic when a condition, such as an <code class="language-plaintext highlighter-rouge">if</code> or
<code class="language-plaintext highlighter-rouge">while</code> loop, doesn’t have the static type <code class="language-plaintext highlighter-rouge">bool</code>.</p>

<h4 id="example-236">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> has the static type
<code class="language-plaintext highlighter-rouge">int</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(int x) {
  if (<span class="highlight">x</span>) {
    // ...
  }
}</code></pre>

<h4 id="common-fixes-261">Common fixes</h4>

<p>Change the condition so that it produces a Boolean value:</p>

<pre class="prettyprint lang-dart"><code>void f(int x) {
  if (x == 0) {
    // ...
  }
}</code></pre>

<h3 id="non_bool_expression">
<a class="anchor" href="#non_bool_expression" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_bool_expression</h3>

<p><em>The expression in an assert must be of type ‘bool’.</em></p>

<h4 id="description-262">Description</h4>

<p>The analyzer produces this diagnostic when the first expression in an
assert has a type other than <code class="language-plaintext highlighter-rouge">bool</code>.</p>

<h4 id="example-237">Example</h4>

<p>The following code produces this diagnostic because the type of <code class="language-plaintext highlighter-rouge">p</code> is
<code class="language-plaintext highlighter-rouge">int</code>, but a <code class="language-plaintext highlighter-rouge">bool</code> is required:</p>

<pre class="prettyprint lang-dart"><code>void f(int p) {
  assert(<span class="highlight">p</span>);
}</code></pre>

<h4 id="common-fixes-262">Common fixes</h4>

<p>Change the expression so that it has the type <code class="language-plaintext highlighter-rouge">bool</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(int p) {
  assert(p &gt; 0);
}</code></pre>

<h3 id="non_bool_negation_expression">
<a class="anchor" href="#non_bool_negation_expression" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_bool_negation_expression</h3>

<p><em>A negation operand must have a static type of ‘bool’.</em></p>

<h4 id="description-263">Description</h4>

<p>The analyzer produces this diagnostic when the operand of the unary
negation operator (<code class="language-plaintext highlighter-rouge">!</code>) doesn’t have the type <code class="language-plaintext highlighter-rouge">bool</code>.</p>

<h4 id="example-238">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> is an <code class="language-plaintext highlighter-rouge">int</code> when it
must be a <code class="language-plaintext highlighter-rouge">bool</code>:</p>

<pre class="prettyprint lang-dart"><code>int x = 0;
bool y = !<span class="highlight">x</span>;</code></pre>

<h4 id="common-fixes-263">Common fixes</h4>

<p>Replace the operand with an expression that has the type <code class="language-plaintext highlighter-rouge">bool</code>:</p>

<pre class="prettyprint lang-dart"><code>int x = 0;
bool y = !(x &gt; 0);</code></pre>

<h3 id="non_bool_operand">
<a class="anchor" href="#non_bool_operand" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_bool_operand</h3>

<p><em>The operands of the operator ‘{0}’ must be assignable to ‘bool’.</em></p>

<h4 id="description-264">Description</h4>

<p>The analyzer produces this diagnostic when one of the operands of either
the <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> or <code class="language-plaintext highlighter-rouge">||</code> operator doesn’t have the type <code class="language-plaintext highlighter-rouge">bool</code>.</p>

<h4 id="example-239">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">a</code> isn’t a Boolean
value:</p>

<pre class="prettyprint lang-dart"><code>int a = 3;
bool b = <span class="highlight">a</span> || a &gt; 1;</code></pre>

<h4 id="common-fixes-264">Common fixes</h4>

<p>Change the operand to a Boolean value:</p>

<pre class="prettyprint lang-dart"><code>int a = 3;
bool b = a == 0 || a &gt; 1;</code></pre>

<h3 id="non_constant_annotation_constructor">
<a class="anchor" href="#non_constant_annotation_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_annotation_constructor</h3>

<p><em>Annotation creation can only call a const constructor.</em></p>

<h4 id="description-265">Description</h4>

<p>The analyzer produces this diagnostic when an annotation is the invocation
of an existing constructor even though the invoked constructor isn’t a
const constructor.</p>

<h4 id="example-240">Example</h4>

<p>The following code produces this diagnostic because the constructor for <code class="language-plaintext highlighter-rouge">C</code>
isn’t a const constructor:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">@C()</span>
void f() {
}

class C {
  C();
}</code></pre>

<h4 id="common-fixes-265">Common fixes</h4>

<p>If it’s valid for the class to have a const constructor, then create a
const constructor that can be used for the annotation:</p>

<pre class="prettyprint lang-dart"><code>@C()
void f() {
}

class C {
  const C();
}</code></pre>

<p>If it isn’t valid for the class to have a const constructor, then either
remove the annotation or use a different class for the annotation.</p>

<h3 id="non_constant_case_expression">
<a class="anchor" href="#non_constant_case_expression" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_case_expression</h3>

<p><em>Case expressions must be constant.</em></p>

<h4 id="description-266">Description</h4>

<p>The analyzer produces this diagnostic when the expression in a <code class="language-plaintext highlighter-rouge">case</code>
clause isn’t a constant expression.</p>

<h4 id="example-241">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">j</code> isn’t a constant:</p>

<pre class="prettyprint lang-dart"><code>void f(int i, int j) {
  switch (i) {
    case <span class="highlight">j</span>:
      // ...
      break;
  }
}</code></pre>

<h4 id="common-fixes-266">Common fixes</h4>

<p>Either make the expression a constant expression, or rewrite the <code class="language-plaintext highlighter-rouge">switch</code>
statement as a sequence of <code class="language-plaintext highlighter-rouge">if</code> statements:</p>

<pre class="prettyprint lang-dart"><code>void f(int i, int j) {
  if (i == j) {
    // ...
  }
}</code></pre>

<h3 id="non_constant_case_expression_from_deferred_library">
<a class="anchor" href="#non_constant_case_expression_from_deferred_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_case_expression_from_deferred_library</h3>

<p><em>Constant values from a deferred library can’t be used as a case expression.</em></p>

<h4 id="description-267">Description</h4>

<p>The analyzer produces this diagnostic when the expression in a case clause
references a constant from a library that is imported using a deferred
import. In order for switch statements to be compiled efficiently, the
constants referenced in case clauses need to be available at compile time,
and constants from deferred libraries aren’t available at compile time.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-242">Example</h4>

<p>Given a file (<code class="language-plaintext highlighter-rouge">a.dart</code>) that defines the constant <code class="language-plaintext highlighter-rouge">zero</code>:</p>

<pre class="prettyprint lang-dart"><code>const zero = 0;</code></pre>

<p>The following code produces this diagnostic because the library <code class="language-plaintext highlighter-rouge">a.dart</code> is
imported using a <code class="language-plaintext highlighter-rouge">deferred</code> import, and the constant <code class="language-plaintext highlighter-rouge">a.zero</code>, declared in
the imported library, is used in a case clause:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' deferred as a;

void f(int x) {
  switch (x) {
    case <span class="highlight">a.zero</span>:
      // ...
      break;
  }
}</code></pre>

<h4 id="common-fixes-267">Common fixes</h4>

<p>If you need to reference the constant from the imported library, then
remove the <code class="language-plaintext highlighter-rouge">deferred</code> keyword:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' as a;

void f(int x) {
  switch (x) {
    case a.zero:
      // ...
      break;
  }
}</code></pre>

<p>If you need to reference the constant from the imported library and also
need the imported library to be deferred, then rewrite the switch statement
as a sequence of <code class="language-plaintext highlighter-rouge">if</code> statements:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' deferred as a;

void f(int x) {
  if (x == a.zero) {
    // ...
  }
}</code></pre>

<p>If you don’t need to reference the constant, then replace the case
expression:</p>

<pre class="prettyprint lang-dart"><code>void f(int x) {
  switch (x) {
    case 0:
      // ...
      break;
  }
}</code></pre>

<h3 id="non_constant_default_value">
<a class="anchor" href="#non_constant_default_value" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_default_value</h3>

<p><em>The default value of an optional parameter must be constant.</em></p>

<h4 id="description-268">Description</h4>

<p>The analyzer produces this diagnostic when an optional parameter, either
named or positional, has a default value that isn’t a compile-time
constant.</p>

<h4 id="example-243">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>var defaultValue = 3;

void f([int value = <span class="highlight">defaultValue</span>]) {}</code></pre>

<h4 id="common-fixes-268">Common fixes</h4>

<p>If the default value can be converted to be a constant, then convert it:</p>

<pre class="prettyprint lang-dart"><code>const defaultValue = 3;

void f([int value = defaultValue]) {}</code></pre>

<p>If the default value needs to change over time, then apply the default
value inside the function:</p>

<pre class="prettyprint lang-dart"><code>var defaultValue = 3;

void f([int value]) {
  value ??= defaultValue;
}</code></pre>

<h3 id="non_constant_default_value_from_deferred_library">
<a class="anchor" href="#non_constant_default_value_from_deferred_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_default_value_from_deferred_library</h3>

<p><em>Constant values from a deferred library can’t be used as a default parameter
value.</em></p>

<h4 id="description-269">Description</h4>

<p>The analyzer produces this diagnostic when the default value of an optional
parameter uses a constant from a library imported using a deferred import.
Default values need to be available at compile time, and constants from
deferred libraries aren’t available at compile time.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-244">Example</h4>

<p>Given a file (<code class="language-plaintext highlighter-rouge">a.dart</code>) that defines the constant <code class="language-plaintext highlighter-rouge">zero</code>:</p>

<pre class="prettyprint lang-dart"><code>const zero = 0;</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">zero</code> is declared in a
library imported using a deferred import:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' deferred as a;

void f({int x = <span class="highlight">a.zero</span>}) {}</code></pre>

<h4 id="common-fixes-269">Common fixes</h4>

<p>If you need to reference the constant from the imported library, then
remove the <code class="language-plaintext highlighter-rouge">deferred</code> keyword:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' as a;

void f({int x = a.zero}) {}</code></pre>

<p>If you don’t need to reference the constant, then replace the default
value:</p>

<pre class="prettyprint lang-dart"><code>void f({int x = 0}) {}</code></pre>

<h3 id="non_constant_list_element">
<a class="anchor" href="#non_constant_list_element" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_list_element</h3>

<p><em>The values in a const list literal must be constants.</em></p>

<h4 id="description-270">Description</h4>

<p>The analyzer produces this diagnostic when an element in a constant list
literal isn’t a constant value. The list literal can be constant either
explicitly (because it’s prefixed by the <code class="language-plaintext highlighter-rouge">const</code> keyword) or implicitly
(because it appears in a <a href="#constant-context">constant context</a>).</p>

<h4 id="example-245">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> isn’t a constant,
even though it appears in an implicitly constant list literal:</p>

<pre class="prettyprint lang-dart"><code>var x = 2;
var y = const &lt;int&gt;[0, 1, <span class="highlight">x</span>];</code></pre>

<h4 id="common-fixes-270">Common fixes</h4>

<p>If the list needs to be a constant list, then convert the element to be a
constant. In the example above, you might add the <code class="language-plaintext highlighter-rouge">const</code> keyword to the
declaration of <code class="language-plaintext highlighter-rouge">x</code>:</p>

<pre class="prettyprint lang-dart"><code>const x = 2;
var y = const &lt;int&gt;[0, 1, x];</code></pre>

<p>If the expression can’t be made a constant, then the list can’t be a
constant either, so you must change the code so that the list isn’t a
constant. In the example above this means removing the <code class="language-plaintext highlighter-rouge">const</code> keyword
before the list literal:</p>

<pre class="prettyprint lang-dart"><code>var x = 2;
var y = &lt;int&gt;[0, 1, x];</code></pre>

<h3 id="non_constant_map_element">
<a class="anchor" href="#non_constant_map_element" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_map_element</h3>

<p><em>The elements in a const map literal must be constant.</em></p>

<h4 id="description-271">Description</h4>

<p>The analyzer produces this diagnostic when an <code class="language-plaintext highlighter-rouge">if</code> element or a spread
element in a constant map isn’t a constant element.</p>

<h4 id="examples-24">Examples</h4>

<p>The following code produces this diagnostic because it’s attempting to
spread a non-constant map:</p>

<pre class="prettyprint lang-dart"><code>var notConst = &lt;int, int&gt;{};
var map = const &lt;int, int&gt;{...<span class="highlight">notConst</span>};</code></pre>

<p>Similarly, the following code produces this diagnostic because the
condition in the <code class="language-plaintext highlighter-rouge">if</code> element isn’t a constant expression:</p>

<pre class="prettyprint lang-dart"><code>bool notConst = true;
var map = const &lt;int, int&gt;{if (<span class="highlight">notConst</span>) 1 : 2};</code></pre>

<h4 id="common-fixes-271">Common fixes</h4>

<p>If the map needs to be a constant map, then make the elements constants.
In the spread example, you might do that by making the collection being
spread a constant:</p>

<pre class="prettyprint lang-dart"><code>const notConst = &lt;int, int&gt;{};
var map = const &lt;int, int&gt;{...notConst};</code></pre>

<p>If the map doesn’t need to be a constant map, then remove the <code class="language-plaintext highlighter-rouge">const</code>
keyword:</p>

<pre class="prettyprint lang-dart"><code>bool notConst = true;
var map = &lt;int, int&gt;{if (notConst) 1 : 2};</code></pre>

<h3 id="non_constant_map_key">
<a class="anchor" href="#non_constant_map_key" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_map_key</h3>

<p><em>The keys in a const map literal must be constant.</em></p>

<h4 id="description-272">Description</h4>

<p>The analyzer produces this diagnostic when a key in a constant map literal
isn’t a constant value.</p>

<h4 id="example-246">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">a</code> isn’t a constant:</p>

<pre class="prettyprint lang-dart"><code>var a = 'a';
var m = const {<span class="highlight">a</span>: 0};</code></pre>

<h4 id="common-fixes-272">Common fixes</h4>

<p>If the map needs to be a constant map, then make the key a constant:</p>

<pre class="prettyprint lang-dart"><code>const a = 'a';
var m = const {a: 0};</code></pre>

<p>If the map doesn’t need to be a constant map, then remove the <code class="language-plaintext highlighter-rouge">const</code>
keyword:</p>

<pre class="prettyprint lang-dart"><code>var a = 'a';
var m = {a: 0};</code></pre>

<h3 id="non_constant_map_value">
<a class="anchor" href="#non_constant_map_value" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_map_value</h3>

<p><em>The values in a const map literal must be constant.</em></p>

<h4 id="description-273">Description</h4>

<p>The analyzer produces this diagnostic when a value in a constant map
literal isn’t a constant value.</p>

<h4 id="example-247">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">a</code> isn’t a constant:</p>

<pre class="prettyprint lang-dart"><code>var a = 'a';
var m = const {0: <span class="highlight">a</span>};</code></pre>

<h4 id="common-fixes-273">Common fixes</h4>

<p>If the map needs to be a constant map, then make the key a constant:</p>

<pre class="prettyprint lang-dart"><code>const a = 'a';
var m = const {0: a};</code></pre>

<p>If the map doesn’t need to be a constant map, then remove the <code class="language-plaintext highlighter-rouge">const</code>
keyword:</p>

<pre class="prettyprint lang-dart"><code>var a = 'a';
var m = {0: a};</code></pre>

<h3 id="non_constant_set_element">
<a class="anchor" href="#non_constant_set_element" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_set_element</h3>

<p><em>The values in a const set literal must be constants.</em></p>

<h4 id="description-274">Description</h4>

<p>The analyzer produces this diagnostic when a constant set literal contains
an element that isn’t a compile-time constant.</p>

<h4 id="example-248">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">i</code> isn’t a constant:</p>

<pre class="prettyprint lang-dart"><code>var i = 0;

var s = const {<span class="highlight">i</span>};</code></pre>

<h4 id="common-fixes-274">Common fixes</h4>

<p>If the element can be changed to be a constant, then change it:</p>

<pre class="prettyprint lang-dart"><code>const i = 0;

var s = const {i};</code></pre>

<p>If the element can’t be a constant, then remove the keyword <code class="language-plaintext highlighter-rouge">const</code>:</p>

<pre class="prettyprint lang-dart"><code>var i = 0;

var s = {i};</code></pre>

<h3 id="non_constant_type_argument">
<a class="anchor" href="#non_constant_type_argument" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_constant_type_argument</h3>

<p><em>The type arguments to ‘{0}’ must be known at compile time, so they can’t be
type parameters.</em></p>

<h4 id="description-275">Description</h4>

<p>The analyzer produces this diagnostic when the type arguments to a method
are required to be known at compile time, but a type parameter, whose
value can’t be known at compile time, is used as a type argument.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-249">Example</h4>

<p>The following code produces this diagnostic because the type argument to
<code class="language-plaintext highlighter-rouge">Pointer.asFunction</code> must be known at compile time, but the type parameter
<code class="language-plaintext highlighter-rouge">R</code>, which isn’t known at compile time, is being used as the type
argument:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

typedef T = int Function(int);

class C&lt;R extends T&gt; {
  void m(Pointer&lt;NativeFunction&lt;T&gt;&gt; p) {
    p.asFunction&lt;<span class="highlight">R</span>&gt;();
  }
}</code></pre>

<h4 id="common-fixes-275">Common fixes</h4>

<p>Remove any uses of type parameters:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C {
  void m(Pointer&lt;NativeFunction&lt;Int64 Function(Int64)&gt;&gt; p) {
    p.asFunction&lt;int Function(int)&gt;();
  }
}</code></pre>

<h3 id="non_const_call_to_literal_constructor">
<a class="anchor" href="#non_const_call_to_literal_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_const_call_to_literal_constructor</h3>

<p><em>This instance creation must be ‘const’, because the {0} constructor is marked
as ‘@literal’.</em></p>

<h4 id="description-276">Description</h4>

<p>The analyzer produces this diagnostic when a constructor that has the
<code class="language-plaintext highlighter-rouge">[literal][meta-literal]</code> annotation is invoked without using the <code class="language-plaintext highlighter-rouge">const</code>
keyword, but all of the arguments to the constructor are constants. The
annotation indicates that the constructor should be used to create a
constant value whenever possible.</p>

<h4 id="example-250">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class C {
  @literal
  const C();
}

C f() =&gt; <span class="highlight">C()</span>;</code></pre>

<h4 id="common-fixes-276">Common fixes</h4>

<p>Add the keyword <code class="language-plaintext highlighter-rouge">const</code> before the constructor invocation:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class C {
  @literal
  const C();
}

void f() =&gt; const C();</code></pre>

<h3 id="non_const_generative_enum_constructor">
<a class="anchor" href="#non_const_generative_enum_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_const_generative_enum_constructor</h3>

<p><em>Generative enum constructors must be ‘const’.</em></p>

<h4 id="description-277">Description</h4>

<p>The analyzer produces this diagnostic when an enum declaration contains a
generative constructor that isn’t marked as <code class="language-plaintext highlighter-rouge">const</code>.</p>

<h4 id="example-251">Example</h4>

<p>The following code produces this diagnostic because the constructor in <code class="language-plaintext highlighter-rouge">E</code>
isn’t marked as being <code class="language-plaintext highlighter-rouge">const</code>:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  e;

  <span class="highlight">E</span>();
}</code></pre>

<h4 id="common-fixes-277">Common fixes</h4>

<p>Add the <code class="language-plaintext highlighter-rouge">const</code> keyword before the constructor:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  e;

  const E();
}</code></pre>

<h3 id="non_final_field_in_enum">
<a class="anchor" href="#non_final_field_in_enum" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_final_field_in_enum</h3>

<p><em>Enums can only declare final fields.</em></p>

<h4 id="description-278">Description</h4>

<p>The analyzer produces this diagnostic when an instance field in an enum
isn’t marked as <code class="language-plaintext highlighter-rouge">final</code>.</p>

<h4 id="example-252">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">f</code> isn’t a
final field:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  c;

  int <span class="highlight">f</span> = 0;
}</code></pre>

<h4 id="common-fixes-278">Common fixes</h4>

<p>If the field must be defined for the enum, then mark the field as being
<code class="language-plaintext highlighter-rouge">final</code>:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  c;

  final int f = 0;
}</code></pre>

<p>If the field can be removed, then remove it:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  c
}</code></pre>

<h3 id="non_generative_constructor">
<a class="anchor" href="#non_generative_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_generative_constructor</h3>

<p><em>The generative constructor ‘{0}’ is expected, but a factory was found.</em></p>

<h4 id="description-279">Description</h4>

<p>The analyzer produces this diagnostic when the initializer list of a
constructor invokes a constructor from the superclass, and the invoked
constructor is a factory constructor. Only a generative constructor can be
invoked in the initializer list.</p>

<h4 id="example-253">Example</h4>

<p>The following code produces this diagnostic because the invocation of the
constructor <code class="language-plaintext highlighter-rouge">super.one()</code> is invoking a factory constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A.one() = B;
  A.two();
}

class B extends A {
  B() : <span class="highlight">super.one()</span>;
}</code></pre>

<h4 id="common-fixes-279">Common fixes</h4>

<p>Change the super invocation to invoke a generative constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A.one() = B;
  A.two();
}

class B extends A {
  B() : super.two();
}</code></pre>

<p>If the generative constructor is the unnamed constructor, and if there are
no arguments being passed to it, then you can remove the super invocation.</p>

<h3 id="non_generative_implicit_constructor">
<a class="anchor" href="#non_generative_implicit_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_generative_implicit_constructor</h3>

<p><em>The unnamed constructor of superclass ‘{0}’ (called by the default constructor
of ‘{1}’) must be a generative constructor, but factory found.</em></p>

<h4 id="description-280">Description</h4>

<p>The analyzer produces this diagnostic when a class has an implicit
generative constructor and the superclass has an explicit unnamed factory
constructor. The implicit constructor in the subclass implicitly invokes
the unnamed constructor in the superclass, but generative constructors can
only invoke another generative constructor, not a factory constructor.</p>

<h4 id="example-254">Example</h4>

<p>The following code produces this diagnostic because the implicit
constructor in <code class="language-plaintext highlighter-rouge">B</code> invokes the unnamed constructor in <code class="language-plaintext highlighter-rouge">A</code>, but the
constructor in <code class="language-plaintext highlighter-rouge">A</code> is a factory constructor, when a generative constructor
is required:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A() =&gt; throw 0;
  A.named();
}

class <span class="highlight">B</span> extends A {}</code></pre>

<h4 id="common-fixes-280">Common fixes</h4>

<p>If the unnamed constructor in the superclass can be a generative
constructor, then change it to be a generative constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A();
  A.named();
}

class B extends A { }</code></pre>

<p>If the unnamed constructor can’t be a generative constructor and there are
other generative constructors in the superclass, then explicitly invoke
one of them:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A() =&gt; throw 0;
  A.named();
}

class B extends A {
  B() : super.named();
}</code></pre>

<p>If there are no generative constructors that can be used and none can be
added, then implement the superclass rather than extending it:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A() =&gt; throw 0;
  A.named();
}

class B implements A {}</code></pre>

<h3 id="non_native_function_type_argument_to_pointer">
<a class="anchor" href="#non_native_function_type_argument_to_pointer" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_native_function_type_argument_to_pointer</h3>

<p><em>Can’t invoke ‘asFunction’ because the function signature ‘{0}’ for the pointer
isn’t a valid C function signature.</em></p>

<h4 id="description-281">Description</h4>

<p>The analyzer produces this diagnostic when the method <code class="language-plaintext highlighter-rouge">asFunction</code> is
invoked on a pointer to a native function, but the signature of the native
function isn’t a valid C function signature.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-255">Example</h4>

<p>The following code produces this diagnostic because function signature
associated with the pointer <code class="language-plaintext highlighter-rouge">p</code> (<code class="language-plaintext highlighter-rouge">FNative</code>) isn’t a valid C function
signature:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

typedef FNative = int Function(int);
typedef F = int Function(int);

class C {
  void f(Pointer&lt;NativeFunction&lt;FNative&gt;&gt; p) {
    p.asFunction&lt;<span class="highlight">F</span>&gt;();
  }
}</code></pre>

<h4 id="common-fixes-281">Common fixes</h4>

<p>Make the <code class="language-plaintext highlighter-rouge">NativeFunction</code> signature a valid C signature:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

typedef FNative = Int8 Function(Int8);
typedef F = int Function(int);

class C {
  void f(Pointer&lt;NativeFunction&lt;FNative&gt;&gt; p) {
    p.asFunction&lt;F&gt;();
  }
}</code></pre>

<h3 id="non_positive_array_dimension">
<a class="anchor" href="#non_positive_array_dimension" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_positive_array_dimension</h3>

<p><em>Array dimensions must be positive numbers.</em></p>

<h4 id="description-282">Description</h4>

<p>The analyzer produces this diagnostic when a dimension given in an <code class="language-plaintext highlighter-rouge">Array</code>
annotation is less than or equal to zero (<code class="language-plaintext highlighter-rouge">0</code>).</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-256">Example</h4>

<p>The following code produces this diagnostic because an array dimension of
<code class="language-plaintext highlighter-rouge">-1</code> was provided:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class MyStruct extends Struct {
  @Array(<span class="highlight">-8</span>)
  external Array&lt;Uint8&gt; a0;
}</code></pre>

<h4 id="common-fixes-282">Common fixes</h4>

<p>Change the dimension to be a positive integer:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class MyStruct extends Struct {
  @Array(8)
  external Array&lt;Uint8&gt; a0;
}</code></pre>

<h3 id="non_sized_type_argument">
<a class="anchor" href="#non_sized_type_argument" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_sized_type_argument</h3>

<p><em>The type ‘{1}’ isn’t a valid type argument for ‘{0}’. The type argument must be
a native integer, ‘Float’, ‘Double’, ‘Pointer’, or subtype of ‘Struct’, ‘Union’, or ‘AbiSpecificInteger’.</em></p>

<h4 id="description-283">Description</h4>

<p>The analyzer produces this diagnostic when the type argument for the class
<code class="language-plaintext highlighter-rouge">Array</code> isn’t one of the valid types: either a native integer, <code class="language-plaintext highlighter-rouge">Float</code>,
<code class="language-plaintext highlighter-rouge">Double</code>, <code class="language-plaintext highlighter-rouge">Pointer</code>, or subtype of <code class="language-plaintext highlighter-rouge">Struct</code>, <code class="language-plaintext highlighter-rouge">Union</code>, or
<code class="language-plaintext highlighter-rouge">AbiSpecificInteger</code>.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-257">Example</h4>

<p>The following code produces this diagnostic because the type argument to
<code class="language-plaintext highlighter-rouge">Array</code> is <code class="language-plaintext highlighter-rouge">Void</code>, and <code class="language-plaintext highlighter-rouge">Void</code> isn’t one of the valid types:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Array(8)
  external Array&lt;<span class="highlight">Void</span>&gt; a0;
}</code></pre>

<h4 id="common-fixes-283">Common fixes</h4>

<p>Change the type argument to one of the valid types:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Array(8)
  external Array&lt;Uint8&gt; a0;
}</code></pre>

<h3 id="non_sync_factory">
<a class="anchor" href="#non_sync_factory" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_sync_factory</h3>

<p><em>Factory bodies can’t use ‘async’, ‘async*’, or ‘sync*‘.</em></p>

<h4 id="description-284">Description</h4>

<p>The analyzer produces this diagnostic when the body of a factory
constructor is marked with <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">async*</code>, or <code class="language-plaintext highlighter-rouge">sync*</code>. All constructors,
including factory constructors, are required to return an instance of the
class in which they’re declared, not a <code class="language-plaintext highlighter-rouge">Future</code>, <code class="language-plaintext highlighter-rouge">Stream</code>, or <code class="language-plaintext highlighter-rouge">Iterator</code>.</p>

<h4 id="example-258">Example</h4>

<p>The following code produces this diagnostic because the body of the factory
constructor is marked with <code class="language-plaintext highlighter-rouge">async</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  factory C() <span class="highlight">async</span> {
    return C._();
  }
  C._();
}</code></pre>

<h4 id="common-fixes-284">Common fixes</h4>

<p>If the member must be declared as a factory constructor, then remove the
keyword appearing before the body:</p>

<pre class="prettyprint lang-dart"><code>class C {
  factory C() {
    return C._();
  }
  C._();
}</code></pre>

<p>If the member must return something other than an instance of the enclosing
class, then make the member a static method:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static Future&lt;C&gt; m() async {
    return C._();
  }
  C._();
}</code></pre>

<h3 id="non_type_as_type_argument">
<a class="anchor" href="#non_type_as_type_argument" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_type_as_type_argument</h3>

<p><em>The name ‘{0}’ isn’t a type so it can’t be used as a type argument.</em></p>

<h4 id="description-285">Description</h4>

<p>The analyzer produces this diagnostic when an identifier that isn’t a type
is used as a type argument.</p>

<h4 id="example-259">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> is a variable, not
a type:</p>

<pre class="prettyprint lang-dart"><code>var x = 0;
List&lt;<span class="highlight">x</span>&gt; xList = [];</code></pre>

<h4 id="common-fixes-285">Common fixes</h4>

<p>Change the type argument to be a type:</p>

<pre class="prettyprint lang-dart"><code>var x = 0;
List&lt;int&gt; xList = [];</code></pre>

<h3 id="non_type_in_catch_clause">
<a class="anchor" href="#non_type_in_catch_clause" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_type_in_catch_clause</h3>

<p><em>The name ‘{0}’ isn’t a type and can’t be used in an on-catch clause.</em></p>

<h4 id="description-286">Description</h4>

<p>The analyzer produces this diagnostic when the identifier following the
<code class="language-plaintext highlighter-rouge">on</code> in a <code class="language-plaintext highlighter-rouge">catch</code> clause is defined to be something other than a type.</p>

<h4 id="example-260">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is a function, not
a type:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
    // ...
  } on <span class="highlight">f</span> {
    // ...
  }
}</code></pre>

<h4 id="common-fixes-286">Common fixes</h4>

<p>Change the name to the type of object that should be caught:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
    // ...
  } on FormatException {
    // ...
  }
}</code></pre>

<h3 id="non_void_return_for_operator">
<a class="anchor" href="#non_void_return_for_operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_void_return_for_operator</h3>

<p><em>The return type of the operator []= must be ‘void’.</em></p>

<h4 id="description-287">Description</h4>

<p>The analyzer produces this diagnostic when a declaration of the operator
<code class="language-plaintext highlighter-rouge">[]=</code> has a return type other than <code class="language-plaintext highlighter-rouge">void</code>.</p>

<h4 id="example-261">Example</h4>

<p>The following code produces this diagnostic because the declaration of the
operator <code class="language-plaintext highlighter-rouge">[]=</code> has a return type of <code class="language-plaintext highlighter-rouge">int</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  <span class="highlight">int</span> operator []=(int index, int value) =&gt; 0;
}</code></pre>

<h4 id="common-fixes-287">Common fixes</h4>

<p>Change the return type to <code class="language-plaintext highlighter-rouge">void</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void operator []=(int index, int value) =&gt; 0;
}</code></pre>

<h3 id="non_void_return_for_setter">
<a class="anchor" href="#non_void_return_for_setter" aria-hidden="true"><span class="octicon octicon-link"></span></a>non_void_return_for_setter</h3>

<p><em>The return type of the setter must be ‘void’ or absent.</em></p>

<h4 id="description-288">Description</h4>

<p>The analyzer produces this diagnostic when a setter is defined with a
return type other than <code class="language-plaintext highlighter-rouge">void</code>.</p>

<h4 id="example-262">Example</h4>

<p>The following code produces this diagnostic because the setter <code class="language-plaintext highlighter-rouge">p</code> has a
return type of <code class="language-plaintext highlighter-rouge">int</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  <span class="highlight">int</span> set p(int i) =&gt; 0;
}</code></pre>

<h4 id="common-fixes-288">Common fixes</h4>

<p>Change the return type to <code class="language-plaintext highlighter-rouge">void</code> or omit the return type:</p>

<pre class="prettyprint lang-dart"><code>class C {
  set p(int i) =&gt; 0;
}</code></pre>

<h3 id="not_assigned_potentially_non_nullable_local_variable">
<a class="anchor" href="#not_assigned_potentially_non_nullable_local_variable" aria-hidden="true"><span class="octicon octicon-link"></span></a>not_assigned_potentially_non_nullable_local_variable</h3>

<p><em>The non-nullable local variable ‘{0}’ must be assigned before it can be used.</em></p>

<h4 id="description-289">Description</h4>

<p>The analyzer produces this diagnostic when a local variable is referenced
and has all these characteristics:</p>
<ul>
  <li>Has a type that’s <a href="#potentially-non-nullable">potentially non-nullable</a>.</li>
  <li>Doesn’t have an initializer.</li>
  <li>Isn’t marked as <code class="language-plaintext highlighter-rouge">late</code>.</li>
  <li>The analyzer can’t prove that the local variable will be assigned before
the reference based on the specification of <a href="#definite-assignment">definite assignment</a>.</li>
</ul>

<h4 id="examples-25">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> can’t have a value
of <code class="language-plaintext highlighter-rouge">null</code>, but is referenced before a value was assigned to it:</p>

<pre class="prettyprint lang-dart"><code>String f() {
  int x;
  return <span class="highlight">x</span>.toString();
}</code></pre>

<p>The following code produces this diagnostic because the assignment to <code class="language-plaintext highlighter-rouge">x</code>
might not be executed, so it might have a value of <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>int g(bool b) {
  int x;
  if (b) {
    x = 1;
  }
  return <span class="highlight">x</span> * 2;
}</code></pre>

<p>The following code produces this diagnostic because the analyzer can’t
prove, based on definite assignment analysis, that <code class="language-plaintext highlighter-rouge">x</code> won’t be referenced
without having a value assigned to it:</p>

<pre class="prettyprint lang-dart"><code>int h(bool b) {
  int x;
  if (b) {
    x = 1;
  }
  if (b) {
    return <span class="highlight">x</span> * 2;
  }
  return 0;
}</code></pre>

<h4 id="common-fixes-289">Common fixes</h4>

<p>If <code class="language-plaintext highlighter-rouge">null</code> is a valid value, then make the variable nullable:</p>

<pre class="prettyprint lang-dart"><code>String f() {
  int? x;
  return x!.toString();
}</code></pre>

<p>If <code class="language-plaintext highlighter-rouge">null</code> isn’t a valid value, and there’s a reasonable default value, then
add an initializer:</p>

<pre class="prettyprint lang-dart"><code>int g(bool b) {
  int x = 2;
  if (b) {
    x = 1;
  }
  return x * 2;
}</code></pre>

<p>Otherwise, ensure that a value was assigned on every possible code path
before the value is accessed:</p>

<pre class="prettyprint lang-dart"><code>int g(bool b) {
  int x;
  if (b) {
    x = 1;
  } else {
    x = 2;
  }
  return x * 2;
}</code></pre>

<p>You can also mark the variable as <code class="language-plaintext highlighter-rouge">late</code>, which removes the diagnostic, but
if the variable isn’t assigned a value before it’s accessed, then it
results in an exception being thrown at runtime. This approach should only
be used if you’re sure that the variable will always be assigned, even
though the analyzer can’t prove it based on definite assignment analysis.</p>

<pre class="prettyprint lang-dart"><code>int h(bool b) {
  late int x;
  if (b) {
    x = 1;
  }
  if (b) {
    return x * 2;
  }
  return 0;
}</code></pre>

<h3 id="not_a_type">
<a class="anchor" href="#not_a_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>not_a_type</h3>

<p><em>{0} isn’t a type.</em></p>

<h4 id="description-290">Description</h4>

<p>The analyzer produces this diagnostic when a name is used as a type but
declared to be something other than a type.</p>

<h4 id="example-263">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is a function:</p>

<pre class="prettyprint lang-dart"><code>f() {}
g(<span class="highlight">f</span> v) {}</code></pre>

<h4 id="common-fixes-290">Common fixes</h4>

<p>Replace the name with the name of a type.</p>

<h3 id="not_binary_operator">
<a class="anchor" href="#not_binary_operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>not_binary_operator</h3>

<p><em>‘{0}’ isn’t a binary operator.</em></p>

<h4 id="description-291">Description</h4>

<p>The analyzer produces this diagnostic when an operator that can only be
used as a unary operator is used as a binary operator.</p>

<h4 id="example-264">Example</h4>

<p>The following code produces this diagnostic because the operator <code class="language-plaintext highlighter-rouge">~</code> can
only be used as a unary operator:</p>

<pre class="prettyprint lang-dart"><code>var a = 5 <span class="highlight">~</span> 3;</code></pre>

<h4 id="common-fixes-291">Common fixes</h4>

<p>Replace the operator with the correct binary operator:</p>

<pre class="prettyprint lang-dart"><code>var a = 5 - 3;</code></pre>

<h3 id="not_enough_positional_arguments">
<a class="anchor" href="#not_enough_positional_arguments" aria-hidden="true"><span class="octicon octicon-link"></span></a>not_enough_positional_arguments</h3>

<p><em>{0} positional argument(s) expected, but {1} found.</em></p>

<h4 id="description-292">Description</h4>

<p>The analyzer produces this diagnostic when a method or function invocation
has fewer positional arguments than the number of required positional
parameters.</p>

<h4 id="example-265">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> declares two
required parameters, but only one argument is provided:</p>

<pre class="prettyprint lang-dart"><code>void f(int a, int b) {}
void g() {
  f<span class="highlight">(0)</span>;
}</code></pre>

<h4 id="common-fixes-292">Common fixes</h4>

<p>Add arguments corresponding to the remaining parameters:</p>

<pre class="prettyprint lang-dart"><code>void f(int a, int b) {}
void g() {
  f(0, 1);
}</code></pre>

<h3 id="not_initialized_non_nullable_instance_field">
<a class="anchor" href="#not_initialized_non_nullable_instance_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>not_initialized_non_nullable_instance_field</h3>

<p><em>Non-nullable instance field ‘{0}’ must be initialized.</em></p>

<h4 id="description-293">Description</h4>

<p>The analyzer produces this diagnostic when a field is declared and has all
these characteristics:</p>
<ul>
  <li>Has a type that’s <a href="#potentially-non-nullable">potentially non-nullable</a>
</li>
  <li>Doesn’t have an initializer</li>
  <li>Isn’t marked as <code class="language-plaintext highlighter-rouge">late</code>
</li>
</ul>

<h4 id="examples-26">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> is implicitly
initialized to <code class="language-plaintext highlighter-rouge">null</code> when it isn’t allowed to be <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int <span class="highlight">x</span>;
}</code></pre>

<p>Similarly, the following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> is
implicitly initialized to <code class="language-plaintext highlighter-rouge">null</code>, when it isn’t allowed to be <code class="language-plaintext highlighter-rouge">null</code>, by
one of the constructors, even though it’s initialized by other
constructors:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  C(this.x);

  <span class="highlight">C</span>.n();
}</code></pre>

<h4 id="common-fixes-293">Common fixes</h4>

<p>If there’s a reasonable default value for the field that’s the same for all
instances, then add an initializer expression:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x = 0;
}</code></pre>

<p>If the value of the field should be provided when an instance is created,
then add a constructor that sets the value of the field or update an
existing constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x;

  C(this.x);
}</code></pre>

<p>You can also mark the field as <code class="language-plaintext highlighter-rouge">late</code>, which removes the diagnostic, but if
the field isn’t assigned a value before it’s accessed, then it results in
an exception being thrown at runtime. This approach should only be used if
you’re sure that the field will always be assigned before it’s referenced.</p>

<pre class="prettyprint lang-dart"><code>class C {
  late int x;
}</code></pre>

<h3 id="not_initialized_non_nullable_variable">
<a class="anchor" href="#not_initialized_non_nullable_variable" aria-hidden="true"><span class="octicon octicon-link"></span></a>not_initialized_non_nullable_variable</h3>

<p><em>The non-nullable variable ‘{0}’ must be initialized.</em></p>

<h4 id="description-294">Description</h4>

<p>The analyzer produces this diagnostic when a static field or top-level
variable has a type that’s non-nullable and doesn’t have an initializer.
Fields and variables that don’t have an initializer are normally
initialized to <code class="language-plaintext highlighter-rouge">null</code>, but the type of the field or variable doesn’t allow
it to be set to <code class="language-plaintext highlighter-rouge">null</code>, so an explicit initializer must be provided.</p>

<h4 id="examples-27">Examples</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">f</code> can’t be
initialized to <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static int <span class="highlight">f</span>;
}</code></pre>

<p>Similarly, the following code produces this diagnostic because the
top-level variable <code class="language-plaintext highlighter-rouge">v</code> can’t be initialized to <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>int <span class="highlight">v</span>;</code></pre>

<h4 id="common-fixes-294">Common fixes</h4>

<p>If the field or variable can’t be initialized to <code class="language-plaintext highlighter-rouge">null</code>, then add an
initializer that sets it to a non-null value:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static int f = 0;
}</code></pre>

<p>If the field or variable should be initialized to <code class="language-plaintext highlighter-rouge">null</code>, then change the
type to be nullable:</p>

<pre class="prettyprint lang-dart"><code>int? v;</code></pre>

<p>If the field or variable can’t be initialized in the declaration but will
always be initialized before it’s referenced, then mark it as being <code class="language-plaintext highlighter-rouge">late</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static late int f;
}</code></pre>

<h3 id="not_iterable_spread">
<a class="anchor" href="#not_iterable_spread" aria-hidden="true"><span class="octicon octicon-link"></span></a>not_iterable_spread</h3>

<p><em>Spread elements in list or set literals must implement ‘Iterable’.</em></p>

<h4 id="description-295">Description</h4>

<p>The analyzer produces this diagnostic when the static type of the
expression of a spread element that appears in either a list literal or a
set literal doesn’t implement the type <code class="language-plaintext highlighter-rouge">Iterable</code>.</p>

<h4 id="example-266">Example</h4>

<p>The following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>var m = &lt;String, int&gt;{'a': 0, 'b': 1};
var s = &lt;String&gt;{...<span class="highlight">m</span>};</code></pre>

<h4 id="common-fixes-295">Common fixes</h4>

<p>The most common fix is to replace the expression with one that produces an
iterable object:</p>

<pre class="prettyprint lang-dart"><code>var m = &lt;String, int&gt;{'a': 0, 'b': 1};
var s = &lt;String&gt;{...m.keys};</code></pre>

<h3 id="not_map_spread">
<a class="anchor" href="#not_map_spread" aria-hidden="true"><span class="octicon octicon-link"></span></a>not_map_spread</h3>

<p><em>Spread elements in map literals must implement ‘Map’.</em></p>

<h4 id="description-296">Description</h4>

<p>The analyzer produces this diagnostic when the static type of the
expression of a spread element that appears in a map literal doesn’t
implement the type <code class="language-plaintext highlighter-rouge">Map</code>.</p>

<h4 id="example-267">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">l</code> isn’t a <code class="language-plaintext highlighter-rouge">Map</code>:</p>

<pre class="prettyprint lang-dart"><code>var l =  &lt;String&gt;['a', 'b'];
var m = &lt;int, String&gt;{...<span class="highlight">l</span>};</code></pre>

<h4 id="common-fixes-296">Common fixes</h4>

<p>The most common fix is to replace the expression with one that produces a
map:</p>

<pre class="prettyprint lang-dart"><code>var l =  &lt;String&gt;['a', 'b'];
var m = &lt;int, String&gt;{...l.asMap()};</code></pre>

<h3 id="no_annotation_constructor_arguments">
<a class="anchor" href="#no_annotation_constructor_arguments" aria-hidden="true"><span class="octicon octicon-link"></span></a>no_annotation_constructor_arguments</h3>

<p><em>Annotation creation must have arguments.</em></p>

<h4 id="description-297">Description</h4>

<p>The analyzer produces this diagnostic when an annotation consists of a
single identifier, but that identifier is the name of a class rather than a
variable. To create an instance of the class, the identifier must be
followed by an argument list.</p>

<h4 id="example-268">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">C</code> is a class, and a
class can’t be used as an annotation without invoking a <code class="language-plaintext highlighter-rouge">const</code> constructor
from the class:</p>

<pre class="prettyprint lang-dart"><code>class C {
  const C();
}

<span class="highlight">@C</span>
var x;</code></pre>

<h4 id="common-fixes-297">Common fixes</h4>

<p>Add the missing argument list:</p>

<pre class="prettyprint lang-dart"><code>class C {
  const C();
}

@C()
var x;</code></pre>

<h3 id="no_combined_super_signature">
<a class="anchor" href="#no_combined_super_signature" aria-hidden="true"><span class="octicon octicon-link"></span></a>no_combined_super_signature</h3>

<p><em>Can’t infer missing types in ‘{0}’ from overridden methods: {1}.</em></p>

<h4 id="description-298">Description</h4>

<p>The analyzer produces this diagnostic when there is a method declaration
for which one or more types needs to be inferred, and those types can’t be
inferred because none of the overridden methods has a function type that is
a supertype of all the other overridden methods, as specified by
<a href="#override-inference">override inference</a>.</p>

<h4 id="example-269">Example</h4>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">m</code> declared
in the class <code class="language-plaintext highlighter-rouge">C</code> is missing both the return type and the type of the
parameter <code class="language-plaintext highlighter-rouge">a</code>, and neither of the missing types can be inferred for it:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  A m(String a);
}

abstract class B {
  B m(int a);
}

abstract class C implements A, B {
  <span class="highlight">m</span>(a);
}</code></pre>

<p>In this example, override inference can’t be performed because the
overridden methods are incompatible in these ways:</p>
<ul>
  <li>Neither parameter type (<code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">int</code>) is a supertype of the other.</li>
  <li>Neither return type is a subtype of the other.</li>
</ul>

<h4 id="common-fixes-298">Common fixes</h4>

<p>If possible, add types to the method in the subclass that are consistent
with the types from all the overridden methods:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  A m(String a);
}

abstract class B {
  B m(int a);
}

abstract class C implements A, B {
  C m(Object a);
}</code></pre>

<h3 id="no_generative_constructors_in_superclass">
<a class="anchor" href="#no_generative_constructors_in_superclass" aria-hidden="true"><span class="octicon octicon-link"></span></a>no_generative_constructors_in_superclass</h3>

<p><em>The class ‘{0}’ can’t extend ‘{1}’ because ‘{1}’ only has factory constructors
(no generative constructors), and ‘{0}’ has at least one generative constructor.</em></p>

<h4 id="description-299">Description</h4>

<p>The analyzer produces this diagnostic when a class that has at least one
generative constructor (whether explicit or implicit) has a superclass
that doesn’t have any generative constructors. Every generative
constructor, except the one defined in <code class="language-plaintext highlighter-rouge">Object</code>, invokes, either
explicitly or implicitly, one of the generative constructors from its
superclass.</p>

<h4 id="example-270">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">B</code> has an
implicit generative constructor that can’t invoke a generative constructor
from <code class="language-plaintext highlighter-rouge">A</code> because <code class="language-plaintext highlighter-rouge">A</code> doesn’t have any generative constructors:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A.none() =&gt; throw '';
}

class B extends <span class="highlight">A</span> {}</code></pre>

<h4 id="common-fixes-299">Common fixes</h4>

<p>If the superclass should have a generative constructor, then add one:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A();
  factory A.none() =&gt; throw '';
}

class B extends A {}</code></pre>

<p>If the subclass shouldn’t have a generative constructor, then remove it by
adding a factory constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A.none() =&gt; throw '';
}

class B extends A {
  factory B.none() =&gt; throw '';
}</code></pre>

<p>If the subclass must have a generative constructor but the superclass
can’t have one, then implement the superclass instead:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A.none() =&gt; throw '';
}

class B implements A {}</code></pre>

<h3 id="nullable_type_in_catch_clause">
<a class="anchor" href="#nullable_type_in_catch_clause" aria-hidden="true"><span class="octicon octicon-link"></span></a>nullable_type_in_catch_clause</h3>

<p><em>A potentially nullable type can’t be used in an ‘on’ clause because it isn’t
valid to throw a nullable expression.</em></p>

<h4 id="description-300">Description</h4>

<p>The analyzer produces this diagnostic when the type following <code class="language-plaintext highlighter-rouge">on</code> in a
<code class="language-plaintext highlighter-rouge">catch</code> clause is a nullable type. It isn’t valid to specify a nullable
type because it isn’t possible to catch <code class="language-plaintext highlighter-rouge">null</code> (because it’s a runtime
error to throw <code class="language-plaintext highlighter-rouge">null</code>).</p>

<h4 id="example-271">Example</h4>

<p>The following code produces this diagnostic because the exception type is
specified to allow <code class="language-plaintext highlighter-rouge">null</code> when <code class="language-plaintext highlighter-rouge">null</code> can’t be thrown:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
    // ...
  } on <span class="highlight">FormatException?</span> {
  }
}</code></pre>

<h4 id="common-fixes-300">Common fixes</h4>

<p>Remove the question mark from the type:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
    // ...
  } on FormatException {
  }
}</code></pre>

<h3 id="nullable_type_in_extends_clause">
<a class="anchor" href="#nullable_type_in_extends_clause" aria-hidden="true"><span class="octicon octicon-link"></span></a>nullable_type_in_extends_clause</h3>

<p><em>A class can’t extend a nullable type.</em></p>

<h4 id="description-301">Description</h4>

<p>The analyzer produces this diagnostic when a class declaration uses an
<code class="language-plaintext highlighter-rouge">extends</code> clause to specify a superclass, and the superclass is followed by
a <code class="language-plaintext highlighter-rouge">?</code>.</p>

<p>It isn’t valid to specify a nullable superclass because doing so would have
no meaning; it wouldn’t change either the interface or implementation being
inherited by the class containing the <code class="language-plaintext highlighter-rouge">extends</code> clause.</p>

<p>Note, however, that it <em>is</em> valid to use a nullable type as a type argument
to the superclass, such as <code class="language-plaintext highlighter-rouge">class A extends B&lt;C?&gt; {}</code>.</p>

<h4 id="example-272">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">A?</code> is a nullable
type, and nullable types can’t be used in an <code class="language-plaintext highlighter-rouge">extends</code> clause:</p>

<pre class="prettyprint lang-dart"><code>class A {}
class B extends <span class="highlight">A?</span> {}</code></pre>

<h4 id="common-fixes-301">Common fixes</h4>

<p>Remove the question mark from the type:</p>

<pre class="prettyprint lang-dart"><code>class A {}
class B extends A {}</code></pre>

<h3 id="nullable_type_in_implements_clause">
<a class="anchor" href="#nullable_type_in_implements_clause" aria-hidden="true"><span class="octicon octicon-link"></span></a>nullable_type_in_implements_clause</h3>

<p><em>A class or mixin can’t implement a nullable type.</em></p>

<h4 id="description-302">Description</h4>

<p>The analyzer produces this diagnostic when a class or mixin declaration has
an <code class="language-plaintext highlighter-rouge">implements</code> clause, and an interface is followed by a <code class="language-plaintext highlighter-rouge">?</code>.</p>

<p>It isn’t valid to specify a nullable interface because doing so would have
no meaning; it wouldn’t change the interface being inherited by the class
containing the <code class="language-plaintext highlighter-rouge">implements</code> clause.</p>

<p>Note, however, that it <em>is</em> valid to use a nullable type as a type argument
to the interface, such as <code class="language-plaintext highlighter-rouge">class A implements B&lt;C?&gt; {}</code>.</p>

<h4 id="example-273">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">A?</code> is a nullable
type, and nullable types can’t be used in an <code class="language-plaintext highlighter-rouge">implements</code> clause:</p>

<pre class="prettyprint lang-dart"><code>class A {}
class B implements <span class="highlight">A?</span> {}</code></pre>

<h4 id="common-fixes-302">Common fixes</h4>

<p>Remove the question mark from the type:</p>

<pre class="prettyprint lang-dart"><code>class A {}
class B implements A {}</code></pre>

<h3 id="nullable_type_in_on_clause">
<a class="anchor" href="#nullable_type_in_on_clause" aria-hidden="true"><span class="octicon octicon-link"></span></a>nullable_type_in_on_clause</h3>

<p><em>A mixin can’t have a nullable type as a superclass constraint.</em></p>

<h4 id="description-303">Description</h4>

<p>The analyzer produces this diagnostic when a mixin declaration uses an <code class="language-plaintext highlighter-rouge">on</code>
clause to specify a superclass constraint, and the class that’s specified
is followed by a <code class="language-plaintext highlighter-rouge">?</code>.</p>

<p>It isn’t valid to specify a nullable superclass constraint because doing so
would have no meaning; it wouldn’t change the interface being depended on
by the mixin containing the <code class="language-plaintext highlighter-rouge">on</code> clause.</p>

<p>Note, however, that it <em>is</em> valid to use a nullable type as a type argument
to the superclass constraint, such as <code class="language-plaintext highlighter-rouge">mixin A on B&lt;C?&gt; {}</code>.</p>

<h4 id="example-274">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">A?</code> is a nullable type
and nullable types can’t be used in an <code class="language-plaintext highlighter-rouge">on</code> clause:</p>

<pre class="prettyprint lang-dart"><code>class C {}
mixin M on <span class="highlight">C?</span> {}</code></pre>

<h4 id="common-fixes-303">Common fixes</h4>

<p>Remove the question mark from the type:</p>

<pre class="prettyprint lang-dart"><code>class C {}
mixin M on C {}</code></pre>

<h3 id="nullable_type_in_with_clause">
<a class="anchor" href="#nullable_type_in_with_clause" aria-hidden="true"><span class="octicon octicon-link"></span></a>nullable_type_in_with_clause</h3>

<p><em>A class or mixin can’t mix in a nullable type.</em></p>

<h4 id="description-304">Description</h4>

<p>The analyzer produces this diagnostic when a class or mixin declaration has
a <code class="language-plaintext highlighter-rouge">with</code> clause, and a mixin is followed by a <code class="language-plaintext highlighter-rouge">?</code>.</p>

<p>It isn’t valid to specify a nullable mixin because doing so would have no
meaning; it wouldn’t change either the interface or implementation being
inherited by the class containing the <code class="language-plaintext highlighter-rouge">with</code> clause.</p>

<p>Note, however, that it <em>is</em> valid to use a nullable type as a type argument
to the mixin, such as <code class="language-plaintext highlighter-rouge">class A with B&lt;C?&gt; {}</code>.</p>

<h4 id="example-275">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">A?</code> is a nullable
type, and nullable types can’t be used in a <code class="language-plaintext highlighter-rouge">with</code> clause:</p>

<pre class="prettyprint lang-dart"><code>mixin M {}
class C with <span class="highlight">M?</span> {}</code></pre>

<h4 id="common-fixes-304">Common fixes</h4>

<p>Remove the question mark from the type:</p>

<pre class="prettyprint lang-dart"><code>mixin M {}
class C with M {}</code></pre>

<h3 id="null_argument_to_non_null_type">
<a class="anchor" href="#null_argument_to_non_null_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>null_argument_to_non_null_type</h3>

<p><em>‘{0}’ shouldn’t be called with a null argument for the non-nullable type
argument ‘{1}’.</em></p>

<h4 id="description-305">Description</h4>

<p>The analyzer produces this diagnostic when <code class="language-plaintext highlighter-rouge">null</code> is passed to either the
constructor <code class="language-plaintext highlighter-rouge">Future.value</code> or the method <code class="language-plaintext highlighter-rouge">Completer.complete</code> when the type
argument used to create the instance was non-nullable. Even though the type
system can’t express this restriction, passing in a <code class="language-plaintext highlighter-rouge">null</code> results in a
runtime exception.</p>

<h4 id="example-276">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">null</code> is being passed
to the constructor <code class="language-plaintext highlighter-rouge">Future.value</code> even though the type argument is the
non-nullable type <code class="language-plaintext highlighter-rouge">String</code>:</p>

<pre class="prettyprint lang-dart"><code>Future&lt;String&gt; f() {
  return Future.value(<span class="highlight">null</span>);
}</code></pre>

<h4 id="common-fixes-305">Common fixes</h4>

<p>Pass in a non-null value:</p>

<pre class="prettyprint lang-dart"><code>Future&lt;String&gt; f() {
  return Future.value('');
}</code></pre>

<h3 id="null_check_always_fails">
<a class="anchor" href="#null_check_always_fails" aria-hidden="true"><span class="octicon octicon-link"></span></a>null_check_always_fails</h3>

<p><em>This null-check will always throw an exception because the expression will
always evaluate to ‘null’.</em></p>

<h4 id="description-306">Description</h4>

<p>The analyzer produces this diagnostic when the null check operator (<code class="language-plaintext highlighter-rouge">!</code>)
is used on an expression whose value can only be <code class="language-plaintext highlighter-rouge">null</code>. In such a case
the operator always throws an exception, which likely isn’t the intended
behavior.</p>

<h4 id="example-277">Example</h4>

<p>The following code produces this diagnostic because the function <code class="language-plaintext highlighter-rouge">g</code> will
always return <code class="language-plaintext highlighter-rouge">null</code>, which means that the null check in <code class="language-plaintext highlighter-rouge">f</code> will always
throw:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  <span class="highlight">g()!</span>;
}

Null g() =&gt; null;</code></pre>

<h4 id="common-fixes-306">Common fixes</h4>

<p>If you intend to always throw an exception, then replace the null check
with an explicit <code class="language-plaintext highlighter-rouge">throw</code> expression to make the intent more clear:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  g();
  throw TypeError();
}

Null g() =&gt; null;</code></pre>

<h3 id="on_repeated">
<a class="anchor" href="#on_repeated" aria-hidden="true"><span class="octicon octicon-link"></span></a>on_repeated</h3>

<p><em>The type ‘{0}’ can be included in the superclass constraints only once.</em></p>

<h4 id="description-307">Description</h4>

<p>The analyzer produces this diagnostic when the same type is listed in the
superclass constraints of a mixin multiple times.</p>

<h4 id="example-278">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">A</code> is included twice
in the superclass constraints for <code class="language-plaintext highlighter-rouge">M</code>:</p>

<pre class="prettyprint lang-dart"><code>mixin M on A, <span class="highlight">A</span> {
}

class A {}
class B {}</code></pre>

<h4 id="common-fixes-307">Common fixes</h4>

<p>If a different type should be included in the superclass constraints, then
replace one of the occurrences with the other type:</p>

<pre class="prettyprint lang-dart"><code>mixin M on A, B {
}

class A {}
class B {}</code></pre>

<p>If no other type was intended, then remove the repeated type name:</p>

<pre class="prettyprint lang-dart"><code>mixin M on A {
}

class A {}
class B {}</code></pre>

<h3 id="optional_parameter_in_operator">
<a class="anchor" href="#optional_parameter_in_operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>optional_parameter_in_operator</h3>

<p><em>Optional parameters aren’t allowed when defining an operator.</em></p>

<h4 id="description-308">Description</h4>

<p>The analyzer produces this diagnostic when one or more of the parameters in
an operator declaration are optional.</p>

<h4 id="example-279">Example</h4>

<p>The following code produces this diagnostic because the parameter <code class="language-plaintext highlighter-rouge">other</code>
is an optional parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C operator +([<span class="highlight">C? other</span>]) =&gt; this;
}</code></pre>

<h4 id="common-fixes-308">Common fixes</h4>

<p>Make all of the parameters be required parameters:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C operator +(C other) =&gt; this;
}</code></pre>

<h3 id="override_on_non_overriding_member">
<a class="anchor" href="#override_on_non_overriding_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>override_on_non_overriding_member</h3>

<p><em>The field doesn’t override an inherited getter or setter.</em></p>

<p><em>The getter doesn’t override an inherited getter.</em></p>

<p><em>The method doesn’t override an inherited method.</em></p>

<p><em>The setter doesn’t override an inherited setter.</em></p>

<h4 id="description-309">Description</h4>

<p>The analyzer produces this diagnostic when a class member is annotated with
the <code class="language-plaintext highlighter-rouge">@override</code> annotation, but the member isn’t declared in any of the
supertypes of the class.</p>

<h4 id="example-280">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">m</code> isn’t declared in
any of the supertypes of <code class="language-plaintext highlighter-rouge">C</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  @override
  String <span class="highlight">m</span>() =&gt; '';
}</code></pre>

<h4 id="common-fixes-309">Common fixes</h4>

<p>If the member is intended to override a member with a different name, then
update the member to have the same name:</p>

<pre class="prettyprint lang-dart"><code>class C {
  @override
  String toString() =&gt; '';
}</code></pre>

<p>If the member is intended to override a member that was removed from the
superclass, then consider removing the member from the subclass.</p>

<p>If the member can’t be removed, then remove the annotation.</p>

<h3 id="packed_annotation">
<a class="anchor" href="#packed_annotation" aria-hidden="true"><span class="octicon octicon-link"></span></a>packed_annotation</h3>

<p><em>Structs must have at most one ‘Packed’ annotation.</em></p>

<h4 id="description-310">Description</h4>

<p>The analyzer produces this diagnostic when a subclass of <code class="language-plaintext highlighter-rouge">Struct</code> has more
than one <code class="language-plaintext highlighter-rouge">Packed</code> annotation.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-281">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code>, which
is a subclass of <code class="language-plaintext highlighter-rouge">Struct</code>, has two <code class="language-plaintext highlighter-rouge">Packed</code> annotations:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@Packed(1)
<span class="highlight">@Packed(1)</span>
class C extends Struct {
  external Pointer&lt;Uint8&gt; notEmpty;
}</code></pre>

<h4 id="common-fixes-310">Common fixes</h4>

<p>Remove all but one of the annotations:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@Packed(1)
class C extends Struct {
  external Pointer&lt;Uint8&gt; notEmpty;
}</code></pre>

<h3 id="packed_annotation_alignment">
<a class="anchor" href="#packed_annotation_alignment" aria-hidden="true"><span class="octicon octicon-link"></span></a>packed_annotation_alignment</h3>

<p><em>Only packing to 1, 2, 4, 8, and 16 bytes is supported.</em></p>

<h4 id="description-311">Description</h4>

<p>The analyzer produces this diagnostic when the argument to the <code class="language-plaintext highlighter-rouge">Packed</code>
annotation isn’t one of the allowed values: 1, 2, 4, 8, or 16.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-282">Example</h4>

<p>The following code produces this diagnostic because the argument to the
<code class="language-plaintext highlighter-rouge">Packed</code> annotation (<code class="language-plaintext highlighter-rouge">3</code>) isn’t one of the allowed values:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@Packed(<span class="highlight">3</span>)
class C extends Struct {
  external Pointer&lt;Uint8&gt; notEmpty;
}</code></pre>

<h4 id="common-fixes-311">Common fixes</h4>

<p>Change the alignment to be one of the allowed values:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@Packed(4)
class C extends Struct {
  external Pointer&lt;Uint8&gt; notEmpty;
}</code></pre>

<h3 id="packed_nesting_non_packed">
<a class="anchor" href="#packed_nesting_non_packed" aria-hidden="true"><span class="octicon octicon-link"></span></a>packed_nesting_non_packed</h3>

<p><em>Nesting the non-packed or less tightly packed struct ‘{0}’ in a packed struct
‘{1}’ isn’t supported.</em></p>

<h4 id="description-312">Description</h4>

<p>The analyzer produces this diagnostic when a subclass of <code class="language-plaintext highlighter-rouge">Struct</code> that is
annotated as being <code class="language-plaintext highlighter-rouge">Packed</code> declares a field whose type is also a subclass
of <code class="language-plaintext highlighter-rouge">Struct</code> and the field’s type is either not packed or is packed less
tightly.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-283">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">Outer</code>,
which is a subclass of <code class="language-plaintext highlighter-rouge">Struct</code> and is packed on 1-byte boundaries,
declared a field whose type (<code class="language-plaintext highlighter-rouge">Inner</code>) is packed on 8-byte boundaries:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@Packed(8)
class Inner extends Struct {
  external Pointer&lt;Uint8&gt; notEmpty;
}

@Packed(1)
class Outer extends Struct {
  external Pointer&lt;Uint8&gt; notEmpty;

  external <span class="highlight">Inner</span> nestedLooselyPacked;
}</code></pre>

<h4 id="common-fixes-312">Common fixes</h4>

<p>If the inner struct should be packed more tightly, then change the
argument to the inner struct’s <code class="language-plaintext highlighter-rouge">Packed</code> annotation:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@Packed(1)
class Inner extends Struct {
  external Pointer&lt;Uint8&gt; notEmpty;
}

@Packed(1)
class Outer extends Struct {
  external Pointer&lt;Uint8&gt; notEmpty;

  external Inner nestedLooselyPacked;
}</code></pre>

<p>If the outer struct should be packed less tightly, then change the
argument to the outer struct’s <code class="language-plaintext highlighter-rouge">Packed</code> annotation:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

@Packed(8)
class Inner extends Struct {
  external Pointer&lt;Uint8&gt; notEmpty;
}

@Packed(8)
class Outer extends Struct {
  external Pointer&lt;Uint8&gt; notEmpty;

  external Inner nestedLooselyPacked;
}</code></pre>

<p>If the inner struct doesn’t have an annotation and should be packed, then
add an annotation.</p>

<p>If the inner struct doesn’t have an annotation and the outer struct
shouldn’t be packed, then remove its annotation.</p>

<h3 id="part_of_different_library">
<a class="anchor" href="#part_of_different_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>part_of_different_library</h3>

<p><em>Expected this library to be part of ‘{0}’, not ‘{1}’.</em></p>

<h4 id="description-313">Description</h4>

<p>The analyzer produces this diagnostic when a library attempts to include a
file as a part of itself when the other file is a part of a different
library.</p>

<h4 id="example-284">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">part.dart</code> containing</p>

<pre class="prettyprint lang-dart"><code>part of 'library.dart';</code></pre>

<p>The following code, in any file other than <code class="language-plaintext highlighter-rouge">library.dart</code>, produces this
diagnostic because it attempts to include <code class="language-plaintext highlighter-rouge">part.dart</code> as a part of itself
when <code class="language-plaintext highlighter-rouge">part.dart</code> is a part of a different library:</p>

<pre class="prettyprint lang-dart"><code>part <span class="highlight">'package:a/part.dart'</span>;</code></pre>

<h4 id="common-fixes-313">Common fixes</h4>

<p>If the library should be using a different file as a part, then change the
URI in the part directive to be the URI of the other file.</p>

<p>If the <a href="#part-file">part file</a> should be a part of this library, then update the URI
(or library name) in the part-of directive to be the URI (or name) of the
correct library.</p>

<h3 id="part_of_non_part">
<a class="anchor" href="#part_of_non_part" aria-hidden="true"><span class="octicon octicon-link"></span></a>part_of_non_part</h3>

<p><em>The included part ‘{0}’ must have a part-of directive.</em></p>

<h4 id="description-314">Description</h4>

<p>The analyzer produces this diagnostic when a part directive is found and
the referenced file doesn’t have a part-of directive.</p>

<h4 id="example-285">Example</h4>

<p>Given a file (<code class="language-plaintext highlighter-rouge">a.dart</code>) containing:</p>

<pre class="prettyprint lang-dart"><code>class A {}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">a.dart</code> doesn’t
contain a part-of directive:</p>

<pre class="prettyprint lang-dart"><code>part <span class="highlight">'a.dart'</span>;</code></pre>

<h4 id="common-fixes-314">Common fixes</h4>

<p>If the referenced file is intended to be a part of another library, then
add a part-of directive to the file:</p>

<pre class="prettyprint lang-dart"><code>part of 'test.dart';

class A {}</code></pre>

<p>If the referenced file is intended to be a library, then replace the part
directive with an import directive:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart';</code></pre>

<h3 id="part_of_unnamed_library">
<a class="anchor" href="#part_of_unnamed_library" aria-hidden="true"><span class="octicon octicon-link"></span></a>part_of_unnamed_library</h3>

<p><em>The library is unnamed. A URI is expected, not a library name ‘{0}’, in the
part-of directive.</em></p>

<h4 id="description-315">Description</h4>

<p>The analyzer produces this diagnostic when a library that doesn’t have a
<code class="language-plaintext highlighter-rouge">library</code> directive (and hence has no name) contains a <code class="language-plaintext highlighter-rouge">part</code> directive
and the <code class="language-plaintext highlighter-rouge">part of</code> directive in the <a href="#part-file">part file</a> uses a name to specify
the library that it’s a part of.</p>

<h4 id="example-286">Example</h4>

<p>Given a <a href="#part-file">part file</a> named <code class="language-plaintext highlighter-rouge">part_file.dart</code> containing the following
code:</p>

<pre class="prettyprint lang-dart"><code>part of lib;</code></pre>

<p>The following code produces this diagnostic because the library including
the <a href="#part-file">part file</a> doesn’t have a name even though the <a href="#part-file">part file</a> uses a
name to specify which library it’s a part of:</p>

<pre class="prettyprint lang-dart"><code>part <span class="highlight">'part_file.dart'</span>;</code></pre>

<h4 id="common-fixes-315">Common fixes</h4>

<p>Change the <code class="language-plaintext highlighter-rouge">part of</code> directive in the <a href="#part-file">part file</a> to specify its library
by URI:</p>

<pre class="prettyprint lang-dart"><code>part of 'test.dart';</code></pre>

<h3 id="path_does_not_exist">
<a class="anchor" href="#path_does_not_exist" aria-hidden="true"><span class="octicon octicon-link"></span></a>path_does_not_exist</h3>

<p><em>The path ‘{0}’ doesn’t exist.</em></p>

<h4 id="description-316">Description</h4>

<p>The analyzer produces this diagnostic when a dependency has a <code class="language-plaintext highlighter-rouge">path</code> key
referencing a directory that doesn’t exist.</p>

<h4 id="example-287">Example</h4>

<p>Assuming that the directory <code class="language-plaintext highlighter-rouge">doesNotExist</code> doesn’t exist, the following
code produces this diagnostic because it’s listed as the path of a package:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">local_package</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">doesNotExist</span>
</code></pre></div></div>

<h4 id="common-fixes-316">Common fixes</h4>

<p>If the path is correct, then create a directory at that path.</p>

<p>If the path isn’t correct, then change the path to match the path to the
root of the package.</p>

<h3 id="path_not_posix">
<a class="anchor" href="#path_not_posix" aria-hidden="true"><span class="octicon octicon-link"></span></a>path_not_posix</h3>

<p><em>The path ‘{0}’ isn’t a POSIX-style path.</em></p>

<h4 id="description-317">Description</h4>

<p>The analyzer produces this diagnostic when a dependency has a <code class="language-plaintext highlighter-rouge">path</code> key
whose value is a string, but isn’t a POSIX-style path.</p>

<h4 id="example-288">Example</h4>

<p>The following code produces this diagnostic because the path following the
<code class="language-plaintext highlighter-rouge">path</code> key is a Windows path:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">local_package</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">E:\local_package</span>
</code></pre></div></div>

<h4 id="common-fixes-317">Common fixes</h4>

<p>Convert the path to a POSIX path.</p>

<h3 id="path_pubspec_does_not_exist">
<a class="anchor" href="#path_pubspec_does_not_exist" aria-hidden="true"><span class="octicon octicon-link"></span></a>path_pubspec_does_not_exist</h3>

<p><em>The directory ‘{0}’ doesn’t contain a pubspec.</em></p>

<h4 id="description-318">Description</h4>

<p>The analyzer produces this diagnostic when a dependency has a <code class="language-plaintext highlighter-rouge">path</code> key
that references a directory that doesn’t contain a <code class="language-plaintext highlighter-rouge">pubspec.yaml</code> file.</p>

<h4 id="example-289">Example</h4>

<p>Assuming that the directory <code class="language-plaintext highlighter-rouge">local_package</code> doesn’t contain a file named
<code class="language-plaintext highlighter-rouge">pubspec.yaml</code>, the following code produces this diagnostic because it’s
listed as the path of a package:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">local_package</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">local_package</span>
</code></pre></div></div>

<h4 id="common-fixes-318">Common fixes</h4>

<p>If the path is intended to be the root of a package, then add a
<code class="language-plaintext highlighter-rouge">pubspec.yaml</code> file in the directory:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">local_package</span>
</code></pre></div></div>

<p>If the path is wrong, then replace it with the correct path.</p>

<h3 id="positional_super_formal_parameter_with_positional_argument">
<a class="anchor" href="#positional_super_formal_parameter_with_positional_argument" aria-hidden="true"><span class="octicon octicon-link"></span></a>positional_super_formal_parameter_with_positional_argument</h3>

<p><em>Positional super parameters can’t be used when the super constructor invocation
has a positional argument.</em></p>

<h4 id="description-319">Description</h4>

<p>The analyzer produces this diagnostic when some, but not all, of the
positional parameters provided to the constructor of the superclass are
using a super parameter.</p>

<p>Positional super parameters are associated with positional parameters in
the super constructor by their index. That is, the first super parameter
is associated with the first positional parameter in the super
constructor, the second with the second, and so on. The same is true for
positional arguments. Having both positional super parameters and
positional arguments means that there are two values associated with the
same parameter in the superclass’s constructor, and hence isn’t allowed.</p>

<h4 id="example-290">Example</h4>

<p>The following code produces this diagnostic because the constructor
<code class="language-plaintext highlighter-rouge">B.new</code> is using a super parameter to pass one of the required positional
parameters to the super constructor in <code class="language-plaintext highlighter-rouge">A</code>, but is explicitly passing the
other in the super constructor invocation:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x, int y);
}

class B extends A {
  B(int x, super.<span class="highlight">y</span>) : super(x);
}</code></pre>

<h4 id="common-fixes-319">Common fixes</h4>

<p>If all the positional parameters can be super parameters, then convert the
normal positional parameters to be super parameters:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x, int y);
}

class B extends A {
  B(super.x, super.y);
}</code></pre>

<p>If some positional parameters can’t be super parameters, then convert the
super parameters to be normal parameters:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x, int y);
}

class B extends A {
  B(int x, int y) : super(x, y);
}</code></pre>

<h3 id="prefix_collides_with_top_level_member">
<a class="anchor" href="#prefix_collides_with_top_level_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>prefix_collides_with_top_level_member</h3>

<p><em>The name ‘{0}’ is already used as an import prefix and can’t be used to name a
top-level element.</em></p>

<h4 id="description-320">Description</h4>

<p>The analyzer produces this diagnostic when a name is used as both an import
prefix and the name of a top-level declaration in the same library.</p>

<h4 id="example-291">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is used as both an
import prefix and the name of a function:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' as f;

int <span class="highlight">f</span>() =&gt; f.min(0, 1);</code></pre>

<h4 id="common-fixes-320">Common fixes</h4>

<p>If you want to use the name for the import prefix, then rename the
top-level declaration:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' as f;

int g() =&gt; f.min(0, 1);</code></pre>

<p>If you want to use the name for the top-level declaration, then rename the
import prefix:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' as math;

int f() =&gt; math.min(0, 1);</code></pre>

<h3 id="prefix_identifier_not_followed_by_dot">
<a class="anchor" href="#prefix_identifier_not_followed_by_dot" aria-hidden="true"><span class="octicon octicon-link"></span></a>prefix_identifier_not_followed_by_dot</h3>

<p><em>The name ‘{0}’ refers to an import prefix, so it must be followed by ‘.’.</em></p>

<h4 id="description-321">Description</h4>

<p>The analyzer produces this diagnostic when an import prefix is used by
itself, without accessing any of the names declared in the libraries
associated with the prefix. Prefixes aren’t variables, and therefore can’t
be used as a value.</p>

<h4 id="example-292">Example</h4>

<p>The following code produces this diagnostic because the prefix <code class="language-plaintext highlighter-rouge">math</code> is
being used as if it were a variable:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' as math;

void f() {
  print(<span class="highlight">math</span>);
}</code></pre>

<h4 id="common-fixes-321">Common fixes</h4>

<p>If the code is incomplete, then reference something in one of the libraries
associated with the prefix:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' as math;

void f() {
  print(math.pi);
}</code></pre>

<p>If the name is wrong, then correct the name.</p>

<h3 id="prefix_shadowed_by_local_declaration">
<a class="anchor" href="#prefix_shadowed_by_local_declaration" aria-hidden="true"><span class="octicon octicon-link"></span></a>prefix_shadowed_by_local_declaration</h3>

<p><em>The prefix ‘{0}’ can’t be used here because it’s shadowed by a local
declaration.</em></p>

<h4 id="description-322">Description</h4>

<p>The analyzer produces this diagnostic when an import prefix is used in a
context where it isn’t visible because it was shadowed by a local
declaration.</p>

<h4 id="example-293">Example</h4>

<p>The following code produces this diagnostic because the prefix <code class="language-plaintext highlighter-rouge">a</code> is
being used to access the class <code class="language-plaintext highlighter-rouge">Future</code>, but isn’t visible because it’s
shadowed by the parameter <code class="language-plaintext highlighter-rouge">a</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:async' as a;

a.Future? f(int a) {
  <span class="highlight">a</span>.Future? x;
  return x;
}</code></pre>

<h4 id="common-fixes-322">Common fixes</h4>

<p>Rename either the prefix:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:async' as p;

p.Future? f(int a) {
  p.Future? x;
  return x;
}</code></pre>

<p>Or rename the local variable:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:async' as a;

a.Future? f(int p) {
  a.Future? x;
  return x;
}</code></pre>

<h3 id="private_collision_in_mixin_application">
<a class="anchor" href="#private_collision_in_mixin_application" aria-hidden="true"><span class="octicon octicon-link"></span></a>private_collision_in_mixin_application</h3>

<p><em>The private name ‘{0}’, defined by ‘{1}’, conflicts with the same name defined
by ‘{2}’.</em></p>

<h4 id="description-323">Description</h4>

<p>The analyzer produces this diagnostic when two mixins that define the same
private member are used together in a single class in a library other than
the one that defines the mixins.</p>

<h4 id="example-294">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">a.dart</code> containing the following code:</p>

<pre class="prettyprint lang-dart"><code>class A {
  void _foo() {}
}

class B {
  void _foo() {}
}</code></pre>

<p>The following code produces this diagnostic because the classes <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>
both define the method <code class="language-plaintext highlighter-rouge">_foo</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart';

class C extends Object with A, <span class="highlight">B</span> {}</code></pre>

<h4 id="common-fixes-323">Common fixes</h4>

<p>If you don’t need both of the mixins, then remove one of them from the
<code class="language-plaintext highlighter-rouge">with</code> clause:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart';

class C extends Object with A, <span class="highlight">B</span> {}</code></pre>

<p>If you need both of the mixins, then rename the conflicting member in one
of the two mixins.</p>

<h3 id="private_optional_parameter">
<a class="anchor" href="#private_optional_parameter" aria-hidden="true"><span class="octicon octicon-link"></span></a>private_optional_parameter</h3>

<p><em>Named parameters can’t start with an underscore.</em></p>

<h4 id="description-324">Description</h4>

<p>The analyzer produces this diagnostic when the name of a named parameter
starts with an underscore.</p>

<h4 id="example-295">Example</h4>

<p>The following code produces this diagnostic because the named parameter
<code class="language-plaintext highlighter-rouge">_x</code> starts with an underscore:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void m({int <span class="highlight">_x</span> = 0}) {}
}</code></pre>

<h4 id="common-fixes-324">Common fixes</h4>

<p>Rename the parameter so that it doesn’t start with an underscore:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void m({int x = 0}) {}
}</code></pre>

<h3 id="private_setter">
<a class="anchor" href="#private_setter" aria-hidden="true"><span class="octicon octicon-link"></span></a>private_setter</h3>

<p><em>The setter ‘{0}’ is private and can’t be accessed outside the library that
declares it.</em></p>

<h4 id="description-325">Description</h4>

<p>The analyzer produces this diagnostic when a private setter is used in a
library where it isn’t visible.</p>

<h4 id="example-296">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">a.dart</code> that contains the following:</p>

<pre class="prettyprint lang-dart"><code>class A {
  static int _f = 0;
}</code></pre>

<p>The following code produces this diagnostic because it references the
private setter <code class="language-plaintext highlighter-rouge">_f</code> even though the setter isn’t visible:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart';

void f() {
  A.<span class="highlight">_f</span> = 0;
}</code></pre>

<h4 id="common-fixes-325">Common fixes</h4>

<p>If you’re able to make the setter public, then do so:</p>

<pre class="prettyprint lang-dart"><code>class A {
  static int f = 0;
}</code></pre>

<p>If you aren’t able to make the setter public, then find a different way to
implement the code.</p>

<h3 id="read_potentially_unassigned_final">
<a class="anchor" href="#read_potentially_unassigned_final" aria-hidden="true"><span class="octicon octicon-link"></span></a>read_potentially_unassigned_final</h3>

<p><em>The final variable ‘{0}’ can’t be read because it’s potentially unassigned at
this point.</em></p>

<h4 id="description-326">Description</h4>

<p>The analyzer produces this diagnostic when a final local variable that
isn’t initialized at the declaration site is read at a point where the
compiler can’t prove that the variable is always initialized before it’s
referenced.</p>

<h4 id="example-297">Example</h4>

<p>The following code produces this diagnostic because the final local
variable <code class="language-plaintext highlighter-rouge">x</code> is read (on line 3) when it’s possible that it hasn’t yet
been initialized:</p>

<pre class="prettyprint lang-dart"><code>int f() {
  final int x;
  return <span class="highlight">x</span>;
}</code></pre>

<h4 id="common-fixes-326">Common fixes</h4>

<p>Ensure that the variable has been initialized before it’s read:</p>

<pre class="prettyprint lang-dart"><code>int f(bool b) {
  final int x;
  if (b) {
    x = 0;
  } else {
    x = 1;
  }
  return x;
}</code></pre>

<h3 id="recursive_compile_time_constant">
<a class="anchor" href="#recursive_compile_time_constant" aria-hidden="true"><span class="octicon octicon-link"></span></a>recursive_compile_time_constant</h3>

<p><em>The compile-time constant expression depends on itself.</em></p>

<h4 id="description-327">Description</h4>

<p>The analyzer produces this diagnostic when the value of a compile-time
constant is defined in terms of itself, either directly or indirectly,
creating an infinite loop.</p>

<h4 id="example-298">Example</h4>

<p>The following code produces this diagnostic twice because both of the
constants are defined in terms of the other:</p>

<pre class="prettyprint lang-dart"><code>const <span class="highlight">secondsPerHour</span> = minutesPerHour * 60;
const <span class="highlight">minutesPerHour</span> = secondsPerHour / 60;</code></pre>

<h4 id="common-fixes-327">Common fixes</h4>

<p>Break the cycle by finding an alternative way of defining at least one of
the constants:</p>

<pre class="prettyprint lang-dart"><code>const secondsPerHour = minutesPerHour * 60;
const minutesPerHour = 60;</code></pre>

<h3 id="recursive_constructor_redirect">
<a class="anchor" href="#recursive_constructor_redirect" aria-hidden="true"><span class="octicon octicon-link"></span></a>recursive_constructor_redirect</h3>

<p><em>Constructors can’t redirect to themselves either directly or indirectly.</em></p>

<h4 id="description-328">Description</h4>

<p>The analyzer produces this diagnostic when a constructor redirects to
itself, either directly or indirectly, creating an infinite loop.</p>

<h4 id="examples-28">Examples</h4>

<p>The following code produces this diagnostic because the generative
constructors <code class="language-plaintext highlighter-rouge">C.a</code> and <code class="language-plaintext highlighter-rouge">C.b</code> each redirect to the other:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a() : <span class="highlight">this.b()</span>;
  C.b() : <span class="highlight">this.a()</span>;
}</code></pre>

<p>The following code produces this diagnostic because the factory
constructors <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> each redirect to the other:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  factory A() = <span class="highlight">B</span>;
}
class B implements A {
  factory B() = <span class="highlight">A</span>;
  B.named();
}</code></pre>

<h4 id="common-fixes-328">Common fixes</h4>

<p>In the case of generative constructors, break the cycle by finding defining
at least one of the constructors to not redirect to another constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a() : this.b();
  C.b();
}</code></pre>

<p>In the case of factory constructors, break the cycle by defining at least
one of the factory constructors to do one of the following:</p>

<ul>
  <li>Redirect to a generative constructor:</li>
</ul>

<pre class="prettyprint lang-dart"><code>abstract class A {
  factory A() = B;
}
class B implements A {
  factory B() = B.named;
  B.named();
}</code></pre>

<ul>
  <li>Not redirect to another constructor:</li>
</ul>

<pre class="prettyprint lang-dart"><code>abstract class A {
  factory A() = B;
}
class B implements A {
  factory B() {
    return B.named();
  }

  B.named();
}</code></pre>

<ul>
  <li>Not be a factory constructor:</li>
</ul>

<pre class="prettyprint lang-dart"><code>abstract class A {
  factory A() = B;
}
class B implements A {
  B();
  B.named();
}</code></pre>

<h3 id="recursive_interface_inheritance">
<a class="anchor" href="#recursive_interface_inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>recursive_interface_inheritance</h3>

<p><em>‘{0}’ can’t be a superinterface of itself: {1}.</em></p>

<p><em>‘{0}’ can’t extend itself.</em></p>

<p><em>‘{0}’ can’t implement itself.</em></p>

<p><em>‘{0}’ can’t use itself as a mixin.</em></p>

<p><em>‘{0}’ can’t use itself as a superclass constraint.</em></p>

<h4 id="description-329">Description</h4>

<p>The analyzer produces this diagnostic when there’s a circularity in the
type hierarchy. This happens when a type, either directly or indirectly,
is declared to be a subtype of itself.</p>

<h4 id="example-299">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">A</code> is
declared to be a subtype of <code class="language-plaintext highlighter-rouge">B</code>, and <code class="language-plaintext highlighter-rouge">B</code> is a subtype of <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>class <span class="highlight">A</span> extends B {}
class B implements A {}</code></pre>

<h4 id="common-fixes-329">Common fixes</h4>

<p>Change the type hierarchy so that there’s no circularity.</p>

<h3 id="redirect_generative_to_missing_constructor">
<a class="anchor" href="#redirect_generative_to_missing_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>redirect_generative_to_missing_constructor</h3>

<p><em>The constructor ‘{0}’ couldn’t be found in ‘{1}’.</em></p>

<h4 id="description-330">Description</h4>

<p>The analyzer produces this diagnostic when a generative constructor
redirects to a constructor that isn’t defined.</p>

<h4 id="example-300">Example</h4>

<p>The following code produces this diagnostic because the constructor <code class="language-plaintext highlighter-rouge">C.a</code>
redirects to the constructor <code class="language-plaintext highlighter-rouge">C.b</code>, but <code class="language-plaintext highlighter-rouge">C.b</code> isn’t defined:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a() : <span class="highlight">this.b()</span>;
}</code></pre>

<h4 id="common-fixes-330">Common fixes</h4>

<p>If the missing constructor must be called, then define it:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a() : this.b();
  C.b();
}</code></pre>

<p>If the missing constructor doesn’t need to be called, then remove the
redirect:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a();
}</code></pre>

<h3 id="redirect_generative_to_non_generative_constructor">
<a class="anchor" href="#redirect_generative_to_non_generative_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>redirect_generative_to_non_generative_constructor</h3>

<p><em>Generative constructors can’t redirect to a factory constructor.</em></p>

<h4 id="description-331">Description</h4>

<p>The analyzer produces this diagnostic when a generative constructor
redirects to a factory constructor.</p>

<h4 id="example-301">Example</h4>

<p>The following code produces this diagnostic because the generative
constructor <code class="language-plaintext highlighter-rouge">C.a</code> redirects to the factory constructor <code class="language-plaintext highlighter-rouge">C.b</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a() : <span class="highlight">this.b()</span>;
  factory C.b() =&gt; C.a();
}</code></pre>

<h4 id="common-fixes-331">Common fixes</h4>

<p>If the generative constructor doesn’t need to redirect to another
constructor, then remove the redirect.</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a();
  factory C.b() =&gt; C.a();
}</code></pre>

<p>If the generative constructor must redirect to another constructor, then
make the other constructor be a generative (non-factory) constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a() : this.b();
  C.b();
}</code></pre>

<h3 id="redirect_to_abstract_class_constructor">
<a class="anchor" href="#redirect_to_abstract_class_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>redirect_to_abstract_class_constructor</h3>

<p><em>The redirecting constructor ‘{0}’ can’t redirect to a constructor of the
abstract class ‘{1}’.</em></p>

<h4 id="description-332">Description</h4>

<p>The analyzer produces this diagnostic when a constructor redirects to a
constructor in an abstract class.</p>

<h4 id="example-302">Example</h4>

<p>The following code produces this diagnostic because the factory
constructor in <code class="language-plaintext highlighter-rouge">A</code> redirects to a constructor in <code class="language-plaintext highlighter-rouge">B</code>, but <code class="language-plaintext highlighter-rouge">B</code> is an
abstract class:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A() = <span class="highlight">B</span>;
}

abstract class B implements A {}</code></pre>

<h4 id="common-fixes-332">Common fixes</h4>

<p>If the code redirects to the correct constructor, then change the class so
that it isn’t abstract:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A() = B;
}

class B implements A {}</code></pre>

<p>Otherwise, change the factory constructor so that it either redirects to a
constructor in a concrete class, or has a concrete implementation.</p>

<h3 id="redirect_to_invalid_function_type">
<a class="anchor" href="#redirect_to_invalid_function_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>redirect_to_invalid_function_type</h3>

<p><em>The redirected constructor ‘{0}’ has incompatible parameters with ‘{1}’.</em></p>

<h4 id="description-333">Description</h4>

<p>The analyzer produces this diagnostic when a factory constructor attempts
to redirect to another constructor, but the two have incompatible
parameters. The parameters are compatible if all of the parameters of the
redirecting constructor can be passed to the other constructor and if the
other constructor doesn’t require any parameters that aren’t declared by
the redirecting constructor.</p>

<h4 id="examples-29">Examples</h4>

<p>The following code produces this diagnostic because the constructor for <code class="language-plaintext highlighter-rouge">A</code>
doesn’t declare a parameter that the constructor for <code class="language-plaintext highlighter-rouge">B</code> requires:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  factory A() = <span class="highlight">B</span>;
}

class B implements A {
  B(int x);
  B.zero();
}</code></pre>

<p>The following code produces this diagnostic because the constructor for <code class="language-plaintext highlighter-rouge">A</code>
declares a named parameter (<code class="language-plaintext highlighter-rouge">y</code>) that the constructor for <code class="language-plaintext highlighter-rouge">B</code> doesn’t
allow:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  factory A(int x, {int y}) = <span class="highlight">B</span>;
}

class B implements A {
  B(int x);
}</code></pre>

<h4 id="common-fixes-333">Common fixes</h4>

<p>If there’s a different constructor that is compatible with the redirecting
constructor, then redirect to that constructor:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  factory A() = B.zero;
}

class B implements A {
  B(int x);
  B.zero();
}</code></pre>

<p>Otherwise, update the redirecting constructor to be compatible:</p>

<pre class="prettyprint lang-dart"><code>abstract class A {
  factory A(int x) = B;
}

class B implements A {
  B(int x);
}</code></pre>

<h3 id="redirect_to_invalid_return_type">
<a class="anchor" href="#redirect_to_invalid_return_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>redirect_to_invalid_return_type</h3>

<p><em>The return type ‘{0}’ of the redirected constructor isn’t a subtype of ‘{1}’.</em></p>

<h4 id="description-334">Description</h4>

<p>The analyzer produces this diagnostic when a factory constructor redirects
to a constructor whose return type isn’t a subtype of the type that the
factory constructor is declared to produce.</p>

<h4 id="example-303">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">A</code> isn’t a subclass
of <code class="language-plaintext highlighter-rouge">C</code>, which means that the value returned by the constructor <code class="language-plaintext highlighter-rouge">A()</code>
couldn’t be returned from the constructor <code class="language-plaintext highlighter-rouge">C()</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class B implements C {}

class C {
  factory C() = <span class="highlight">A</span>;
}</code></pre>

<h4 id="common-fixes-334">Common fixes</h4>

<p>If the factory constructor is redirecting to a constructor in the wrong
class, then update the factory constructor to redirect to the correct
constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {}

class B implements C {}

class C {
  factory C() = B;
}</code></pre>

<p>If the class defining the constructor being redirected to is the class that
should be returned, then make it a subtype of the factory’s return type:</p>

<pre class="prettyprint lang-dart"><code>class A implements C {}

class B implements C {}

class C {
  factory C() = A;
}</code></pre>

<h3 id="redirect_to_missing_constructor">
<a class="anchor" href="#redirect_to_missing_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>redirect_to_missing_constructor</h3>

<p><em>The constructor ‘{0}’ couldn’t be found in ‘{1}’.</em></p>

<h4 id="description-335">Description</h4>

<p>The analyzer produces this diagnostic when a constructor redirects to a
constructor that doesn’t exist.</p>

<h4 id="example-304">Example</h4>

<p>The following code produces this diagnostic because the factory
constructor in <code class="language-plaintext highlighter-rouge">A</code> redirects to a constructor in <code class="language-plaintext highlighter-rouge">B</code> that doesn’t exist:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A() = <span class="highlight">B.name</span>;
}

class B implements A {
  B();
}</code></pre>

<h4 id="common-fixes-335">Common fixes</h4>

<p>If the constructor being redirected to is correct, then define the
constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A() = B.name;
}

class B implements A {
  B();
  B.name();
}</code></pre>

<p>If a different constructor should be invoked, then update the redirect:</p>

<pre class="prettyprint lang-dart"><code>class A {
  factory A() = B;
}

class B implements A {
  B();
}</code></pre>

<h3 id="redirect_to_non_class">
<a class="anchor" href="#redirect_to_non_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>redirect_to_non_class</h3>

<p><em>The name ‘{0}’ isn’t a type and can’t be used in a redirected constructor.</em></p>

<h4 id="description-336">Description</h4>

<p>One way to implement a factory constructor is to redirect to another
constructor by referencing the name of the constructor. The analyzer
produces this diagnostic when the redirect is to something other than a
constructor.</p>

<h4 id="example-305">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is a function:</p>

<pre class="prettyprint lang-dart"><code>C f() =&gt; throw 0;

class C {
  factory C() = <span class="highlight">f</span>;
}</code></pre>

<h4 id="common-fixes-336">Common fixes</h4>

<p>If the constructor isn’t defined, then either define it or replace it with
a constructor that is defined.</p>

<p>If the constructor is defined but the class that defines it isn’t visible,
then you probably need to add an import.</p>

<p>If you’re trying to return the value returned by a function, then rewrite
the constructor to return the value from the constructor’s body:</p>

<pre class="prettyprint lang-dart"><code>C f() =&gt; throw 0;

class C {
  factory C() =&gt; f();
}</code></pre>

<h3 id="redirect_to_non_const_constructor">
<a class="anchor" href="#redirect_to_non_const_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>redirect_to_non_const_constructor</h3>

<p><em>A constant redirecting constructor can’t redirect to a non-constant
constructor.</em></p>

<h4 id="description-337">Description</h4>

<p>The analyzer produces this diagnostic when a constructor marked as <code class="language-plaintext highlighter-rouge">const</code>
redirects to a constructor that isn’t marked as <code class="language-plaintext highlighter-rouge">const</code>.</p>

<h4 id="example-306">Example</h4>

<p>The following code produces this diagnostic because the constructor <code class="language-plaintext highlighter-rouge">C.a</code>
is marked as <code class="language-plaintext highlighter-rouge">const</code> but redirects to the constructor <code class="language-plaintext highlighter-rouge">C.b</code>, which isn’t:</p>

<pre class="prettyprint lang-dart"><code>class C {
  const C.a() : this.<span class="highlight">b</span>();
  C.b();
}</code></pre>

<h4 id="common-fixes-337">Common fixes</h4>

<p>If the non-constant constructor can be marked as <code class="language-plaintext highlighter-rouge">const</code>, then mark it as
<code class="language-plaintext highlighter-rouge">const</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  const C.a() : this.b();
  const C.b();
}</code></pre>

<p>If the non-constant constructor can’t be marked as <code class="language-plaintext highlighter-rouge">const</code>, then either
remove the redirect or remove <code class="language-plaintext highlighter-rouge">const</code> from the redirecting constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a() : this.b();
  C.b();
}</code></pre>

<h3 id="redirect_to_type_alias_expands_to_type_parameter">
<a class="anchor" href="#redirect_to_type_alias_expands_to_type_parameter" aria-hidden="true"><span class="octicon octicon-link"></span></a>redirect_to_type_alias_expands_to_type_parameter</h3>

<p><em>A redirecting constructor can’t redirect to a type alias that expands to a type
parameter.</em></p>

<h4 id="description-338">Description</h4>

<p>The analyzer produces this diagnostic when a redirecting factory
constructor redirects to a type alias, and the type alias expands to one of
the type parameters of the type alias. This isn’t allowed because the value
of the type parameter is a type rather than a class.</p>

<h4 id="example-307">Example</h4>

<p>The following code produces this diagnostic because the redirect to <code class="language-plaintext highlighter-rouge">B&lt;A&gt;</code>
is to a type alias whose value is <code class="language-plaintext highlighter-rouge">T</code>, even though it looks like the value
should be <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>class A implements C {}

typedef B&lt;T&gt; = T;

abstract class C {
  factory C() = <span class="highlight">B</span>&lt;A&gt;;
}</code></pre>

<h4 id="common-fixes-338">Common fixes</h4>

<p>Use either a class name or a type alias that is defined to be a class
rather than a type alias defined to be a type parameter:</p>

<pre class="prettyprint lang-dart"><code>class A implements C {}

abstract class C {
  factory C() = A;
}</code></pre>

<h3 id="referenced_before_declaration">
<a class="anchor" href="#referenced_before_declaration" aria-hidden="true"><span class="octicon octicon-link"></span></a>referenced_before_declaration</h3>

<p><em>Local variable ‘{0}’ can’t be referenced before it is declared.</em></p>

<h4 id="description-339">Description</h4>

<p>The analyzer produces this diagnostic when a variable is referenced before
it’s declared. In Dart, variables are visible everywhere in the block in
which they are declared, but can only be referenced after they are
declared.</p>

<p>The analyzer also produces a context message that indicates where the
declaration is located.</p>

<h4 id="example-308">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">i</code> is used before it
is declared:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  print(<span class="highlight">i</span>);
  int i = 5;
}</code></pre>

<h4 id="common-fixes-339">Common fixes</h4>

<p>If you intended to reference the local variable, move the declaration
before the first reference:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  int i = 5;
  print(i);
}</code></pre>

<p>If you intended to reference a name from an outer scope, such as a
parameter, instance field or top-level variable, then rename the local
declaration so that it doesn’t hide the outer variable.</p>

<pre class="prettyprint lang-dart"><code>void f(int i) {
  print(i);
  int x = 5;
  print(x);
}</code></pre>

<h3 id="rethrow_outside_catch">
<a class="anchor" href="#rethrow_outside_catch" aria-hidden="true"><span class="octicon octicon-link"></span></a>rethrow_outside_catch</h3>

<p><em>A rethrow must be inside of a catch clause.</em></p>

<h4 id="description-340">Description</h4>

<p>The analyzer produces this diagnostic when a <code class="language-plaintext highlighter-rouge">rethrow</code> statement is outside
a <code class="language-plaintext highlighter-rouge">catch</code> clause. The <code class="language-plaintext highlighter-rouge">rethrow</code> statement is used to throw a caught
exception again, but there’s no caught exception outside of a <code class="language-plaintext highlighter-rouge">catch</code>
clause.</p>

<h4 id="example-309">Example</h4>

<p>The following code produces this diagnostic because the<code class="language-plaintext highlighter-rouge">rethrow</code> statement
is outside of a <code class="language-plaintext highlighter-rouge">catch</code> clause:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  <span class="highlight">rethrow</span>;
}</code></pre>

<h4 id="common-fixes-340">Common fixes</h4>

<p>If you’re trying to rethrow an exception, then wrap the <code class="language-plaintext highlighter-rouge">rethrow</code> statement
in a <code class="language-plaintext highlighter-rouge">catch</code> clause:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
    // ...
  } catch (exception) {
    rethrow;
  }
}</code></pre>

<p>If you’re trying to throw a new exception, then replace the <code class="language-plaintext highlighter-rouge">rethrow</code>
statement with a <code class="language-plaintext highlighter-rouge">throw</code> expression:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  throw UnsupportedError('Not yet implemented');
}</code></pre>

<h3 id="return_in_generative_constructor">
<a class="anchor" href="#return_in_generative_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>return_in_generative_constructor</h3>

<p><em>Constructors can’t return values.</em></p>

<h4 id="description-341">Description</h4>

<p>The analyzer produces this diagnostic when a generative constructor
contains a <code class="language-plaintext highlighter-rouge">return</code> statement that specifies a value to be returned.
Generative constructors always return the object that was created, and
therefore can’t return a different object.</p>

<h4 id="example-310">Example</h4>

<p>The following code produces this diagnostic because the <code class="language-plaintext highlighter-rouge">return</code> statement
has an expression:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C() {
    return <span class="highlight">this</span>;
  }
}</code></pre>

<h4 id="common-fixes-341">Common fixes</h4>

<p>If the constructor should create a new instance, then remove either the
<code class="language-plaintext highlighter-rouge">return</code> statement or the expression:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C();
}</code></pre>

<p>If the constructor shouldn’t create a new instance, then convert it to be a
factory constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  factory C() {
    return _instance;
  }

  static C _instance = C._();

  C._();
}</code></pre>

<h3 id="return_in_generator">
<a class="anchor" href="#return_in_generator" aria-hidden="true"><span class="octicon octicon-link"></span></a>return_in_generator</h3>

<p><em>Can’t return a value from a generator function that uses the ‘async*’ or
‘sync*’ modifier.</em></p>

<h4 id="description-342">Description</h4>

<p>The analyzer produces this diagnostic when a generator function (one whose
body is marked with either <code class="language-plaintext highlighter-rouge">async*</code> or <code class="language-plaintext highlighter-rouge">sync*</code>) uses either a <code class="language-plaintext highlighter-rouge">return</code>
statement to return a value or implicitly returns a value because of using
<code class="language-plaintext highlighter-rouge">=&gt;</code>. In any of these cases, they should use <code class="language-plaintext highlighter-rouge">yield</code> instead of <code class="language-plaintext highlighter-rouge">return</code>.</p>

<h4 id="examples-30">Examples</h4>

<p>The following code produces this diagnostic because the method <code class="language-plaintext highlighter-rouge">f</code> is a
generator and is using <code class="language-plaintext highlighter-rouge">return</code> to return a value:</p>

<pre class="prettyprint lang-dart"><code>Iterable&lt;int&gt; f() sync* {
  <span class="highlight">return 3</span>;
}</code></pre>

<p>The following code produces this diagnostic because the function <code class="language-plaintext highlighter-rouge">f</code> is a
generator and is implicitly returning a value:</p>

<pre class="prettyprint lang-dart"><code>Stream&lt;int&gt; f() async* <span class="highlight">=&gt;</span> 3;</code></pre>

<h4 id="common-fixes-342">Common fixes</h4>

<p>If the function is using <code class="language-plaintext highlighter-rouge">=&gt;</code> for the body of the function, then convert it
to a block function body, and use <code class="language-plaintext highlighter-rouge">yield</code> to return a value:</p>

<pre class="prettyprint lang-dart"><code>Stream&lt;int&gt; f() async* {
  yield 3;
}</code></pre>

<p>If the method is intended to be a generator, then use <code class="language-plaintext highlighter-rouge">yield</code> to return a
value:</p>

<pre class="prettyprint lang-dart"><code>Iterable&lt;int&gt; f() sync* {
  yield 3;
}</code></pre>

<p>If the method isn’t intended to be a generator, then remove the modifier
from the body (or use <code class="language-plaintext highlighter-rouge">async</code> if you’re returning a future):</p>

<pre class="prettyprint lang-dart"><code>int f() {
  return 3;
}</code></pre>

<h3 id="return_of_do_not_store">
<a class="anchor" href="#return_of_do_not_store" aria-hidden="true"><span class="octicon octicon-link"></span></a>return_of_do_not_store</h3>

<p><em>‘{0}’ is annotated with ‘doNotStore’ and shouldn’t be returned unless ‘{1}’ is
also annotated.</em></p>

<h4 id="description-343">Description</h4>

<p>The analyzer produces this diagnostic when a value that is annotated with
the <code class="language-plaintext highlighter-rouge">[doNotStore][meta-doNotStore]</code> annotation is returned from a method,
getter, or function that doesn’t have the same annotation.</p>

<h4 id="example-311">Example</h4>

<p>The following code produces this diagnostic because the result of invoking
<code class="language-plaintext highlighter-rouge">f</code> shouldn’t be stored, but the function <code class="language-plaintext highlighter-rouge">g</code> isn’t annotated to preserve
that semantic:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@doNotStore
int f() =&gt; 0;

int g() =&gt; <span class="highlight">f()</span>;</code></pre>

<h4 id="common-fixes-343">Common fixes</h4>

<p>If the value that shouldn’t be stored is the correct value to return, then
mark the function with the <code class="language-plaintext highlighter-rouge">[doNotStore][meta-doNotStore]</code> annotation:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@doNotStore
int f() =&gt; 0;

@doNotStore
int g() =&gt; f();</code></pre>

<p>Otherwise, return a different value from the function:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@doNotStore
int f() =&gt; 0;

int g() =&gt; 0;</code></pre>

<h3 id="return_of_invalid_type">
<a class="anchor" href="#return_of_invalid_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>return_of_invalid_type</h3>

<p><em>A value of type ‘{0}’ can’t be returned from the constructor ‘{2}’ because it
has a return type of ‘{1}’.</em></p>

<p><em>A value of type ‘{0}’ can’t be returned from the function ‘{2}’ because it has
a return type of ‘{1}’.</em></p>

<p><em>A value of type ‘{0}’ can’t be returned from the method ‘{2}’ because it has a
return type of ‘{1}’.</em></p>

<h4 id="description-344">Description</h4>

<p>The analyzer produces this diagnostic when a method or function returns a
value whose type isn’t assignable to the declared return type.</p>

<h4 id="example-312">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> has a return type
of <code class="language-plaintext highlighter-rouge">String</code> but is returning an <code class="language-plaintext highlighter-rouge">int</code>:</p>

<pre class="prettyprint lang-dart"><code>String f() =&gt; <span class="highlight">3</span>;</code></pre>

<h4 id="common-fixes-344">Common fixes</h4>

<p>If the return type is correct, then replace the value being returned with a
value of the correct type, possibly by converting the existing value:</p>

<pre class="prettyprint lang-dart"><code>String f() =&gt; 3.toString();</code></pre>

<p>If the value is correct, then change the return type to match:</p>

<pre class="prettyprint lang-dart"><code>int f() =&gt; 3;</code></pre>

<h3 id="return_of_invalid_type_from_closure">
<a class="anchor" href="#return_of_invalid_type_from_closure" aria-hidden="true"><span class="octicon octicon-link"></span></a>return_of_invalid_type_from_closure</h3>

<p><em>The return type ‘{0}’ isn’t a ‘{1}’, as required by the closure’s context.</em></p>

<h4 id="description-345">Description</h4>

<p>The analyzer produces this diagnostic when the static type of a returned
expression isn’t assignable to the return type that the closure is required
to have.</p>

<h4 id="example-313">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> is defined to be a
function that returns a <code class="language-plaintext highlighter-rouge">String</code>, but the closure assigned to it returns an
<code class="language-plaintext highlighter-rouge">int</code>:</p>

<pre class="prettyprint lang-dart"><code>String Function(String) f = (s) =&gt; <span class="highlight">3</span>;</code></pre>

<h4 id="common-fixes-345">Common fixes</h4>

<p>If the return type is correct, then replace the returned value with a value
of the correct type, possibly by converting the existing value:</p>

<pre class="prettyprint lang-dart"><code>String Function(String) f = (s) =&gt; 3.toString();</code></pre>

<h3 id="return_without_value">
<a class="anchor" href="#return_without_value" aria-hidden="true"><span class="octicon octicon-link"></span></a>return_without_value</h3>

<p><em>The return value is missing after ‘return’.</em></p>

<h4 id="description-346">Description</h4>

<p>The analyzer produces this diagnostic when it finds a <code class="language-plaintext highlighter-rouge">return</code> statement
without an expression in a function that declares a return type.</p>

<h4 id="example-314">Example</h4>

<p>The following code produces this diagnostic because the function <code class="language-plaintext highlighter-rouge">f</code> is
expected to return an <code class="language-plaintext highlighter-rouge">int</code>, but no value is being returned:</p>

<pre class="prettyprint lang-dart"><code>int f() {
  <span class="highlight">return</span>;
}</code></pre>

<h4 id="common-fixes-346">Common fixes</h4>

<p>Add an expression that computes the value to be returned:</p>

<pre class="prettyprint lang-dart"><code>int f() {
  return 0;
}</code></pre>

<h3 id="sdk_version_async_exported_from_core">
<a class="anchor" href="#sdk_version_async_exported_from_core" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_async_exported_from_core</h3>

<p><em>The class ‘{0}’ wasn’t exported from ‘dart:core’ until version 2.1, but this
code is required to be able to run on earlier versions.</em></p>

<h4 id="description-347">Description</h4>

<p>The analyzer produces this diagnostic when either the class <code class="language-plaintext highlighter-rouge">Future</code> or
<code class="language-plaintext highlighter-rouge">Stream</code> is referenced in a library that doesn’t import <code class="language-plaintext highlighter-rouge">dart:async</code> in
code that has an SDK constraint whose lower bound is less than 2.1.0. In
earlier versions, these classes weren’t defined in <code class="language-plaintext highlighter-rouge">dart:core</code>, so the
import was necessary.</p>

<h4 id="example-315">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.1.0:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.0.0</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces this
diagnostic:</p>

<pre class="prettyprint lang-dart"><code>void f(<span class="highlight">Future</span> f) {}</code></pre>

<h4 id="common-fixes-347">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the classes to be referenced:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.1.0</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then import the
<code class="language-plaintext highlighter-rouge">dart:async</code> library.</p>

<pre class="prettyprint lang-dart"><code>import 'dart:async';

void f(Future f) {}</code></pre>

<h3 id="sdk_version_as_expression_in_const_context">
<a class="anchor" href="#sdk_version_as_expression_in_const_context" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_as_expression_in_const_context</h3>

<p><em>The use of an as expression in a constant expression wasn’t supported until
version 2.3.2, but this code is required to be able to run on earlier versions.</em></p>

<h4 id="description-348">Description</h4>

<p>The analyzer produces this diagnostic when an <code class="language-plaintext highlighter-rouge">as</code> expression inside a
<a href="#constant-context">constant context</a> is found in code that has an SDK constraint whose
lower bound is less than 2.3.2. Using an <code class="language-plaintext highlighter-rouge">as</code> expression in a
<a href="#constant-context">constant context</a> wasn’t supported in earlier versions, so this code
won’t be able to run against earlier versions of the SDK.</p>

<h4 id="example-316">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.3.2:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.1.0</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces
this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>const num n = 3;
const int i = <span class="highlight">n as int</span>;</code></pre>

<h4 id="common-fixes-348">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the expression to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.3.2</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then either rewrite the
code to not use an <code class="language-plaintext highlighter-rouge">as</code> expression, or change the code so that the <code class="language-plaintext highlighter-rouge">as</code>
expression isn’t in a <a href="#constant-context">constant context</a>:</p>

<pre class="prettyprint lang-dart"><code>num x = 3;
int y = x as int;</code></pre>

<h3 id="sdk_version_bool_operator_in_const_context">
<a class="anchor" href="#sdk_version_bool_operator_in_const_context" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_bool_operator_in_const_context</h3>

<p><em>The use of the operator ‘{0}’ for ‘bool’ operands in a constant context wasn’t
supported until version 2.3.2, but this code is required to be able to run on earlier versions.</em></p>

<h4 id="description-349">Description</h4>

<p>The analyzer produces this diagnostic when any use of the <code class="language-plaintext highlighter-rouge">&amp;</code>, <code class="language-plaintext highlighter-rouge">|</code>, or <code class="language-plaintext highlighter-rouge">^</code>
operators on the class <code class="language-plaintext highlighter-rouge">bool</code> inside a <a href="#constant-context">constant context</a> is found in
code that has an SDK constraint whose lower bound is less than 2.3.2. Using
these operators in a <a href="#constant-context">constant context</a> wasn’t supported in earlier
versions, so this code won’t be able to run against earlier versions of the
SDK.</p>

<h4 id="example-317">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.3.2:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.1.0</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces this
diagnostic:</p>

<pre class="prettyprint lang-dart"><code>const bool a = true;
const bool b = false;
const bool c = a <span class="highlight">&amp;</span> b;</code></pre>

<h4 id="common-fixes-349">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the operators to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
 <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.3.2</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then either rewrite the
code to not use these operators, or change the code so that the expression
isn’t in a <a href="#constant-context">constant context</a>:</p>

<pre class="prettyprint lang-dart"><code>const bool a = true;
const bool b = false;
bool c = a &amp; b;</code></pre>

<h3 id="sdk_version_constructor_tearoffs">
<a class="anchor" href="#sdk_version_constructor_tearoffs" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_constructor_tearoffs</h3>

<p><em>Tearing off a constructor requires the ‘constructor-tearoffs’ language
feature.</em></p>

<h4 id="description-350">Description</h4>

<p>The analyzer produces this diagnostic when a constructor tear-off is found
in code that has an SDK constraint whose lower bound is less than 2.15.
Constructor tear-offs weren’t supported in earlier versions, so this code
won’t be able to run against earlier versions of the SDK.</p>

<h4 id="example-318">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.15:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.9.0</span><span class="nv"> </span><span class="s">&lt;2.15.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces this
diagnostic:</p>

<pre class="prettyprint lang-dart"><code>var setConstructor = <span class="highlight">Set.identity</span>;</code></pre>

<h4 id="common-fixes-350">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the operator to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.15.0</span><span class="nv"> </span><span class="s">&lt;2.16.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then rewrite the code to
not use constructor tear-offs:</p>

<pre class="prettyprint lang-dart"><code>var setConstructor = () =&gt; Set.identity();</code></pre>

<h3 id="sdk_version_eq_eq_operator_in_const_context">
<a class="anchor" href="#sdk_version_eq_eq_operator_in_const_context" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_eq_eq_operator_in_const_context</h3>

<p><em>Using the operator ‘==’ for non-primitive types wasn’t supported until version
2.3.2, but this code is required to be able to run on earlier versions.</em></p>

<h4 id="description-351">Description</h4>

<p>The analyzer produces this diagnostic when the operator <code class="language-plaintext highlighter-rouge">==</code> is used on a
non-primitive type inside a <a href="#constant-context">constant context</a> is found in code that has
an SDK constraint whose lower bound is less than 2.3.2. Using this operator
in a <a href="#constant-context">constant context</a> wasn’t supported in earlier versions, so this
code won’t be able to run against earlier versions of the SDK.</p>

<h4 id="example-319">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.3.2:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.1.0</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces this
diagnostic:</p>

<pre class="prettyprint lang-dart"><code>class C {}
const C a = null;
const C b = null;
const bool same = a <span class="highlight">==</span> b;</code></pre>

<h4 id="common-fixes-351">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the operator to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.3.2</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then either rewrite the
code to not use the <code class="language-plaintext highlighter-rouge">==</code> operator, or change the code so that the
expression isn’t in a <a href="#constant-context">constant context</a>:</p>

<pre class="prettyprint lang-dart"><code>class C {}
const C a = null;
const C b = null;
bool same = a == b;</code></pre>

<h3 id="sdk_version_extension_methods">
<a class="anchor" href="#sdk_version_extension_methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_extension_methods</h3>

<p><em>Extension methods weren’t supported until version 2.6.0, but this code is
required to be able to run on earlier versions.</em></p>

<h4 id="description-352">Description</h4>

<p>The analyzer produces this diagnostic when an extension declaration or an
extension override is found in code that has an SDK constraint whose lower
bound is less than 2.6.0. Using extensions wasn’t supported in earlier
versions, so this code won’t be able to run against earlier versions of the
SDK.</p>

<h4 id="example-320">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.6.0:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
 <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.4.0</span><span class="nv"> </span><span class="s">&lt;2.7.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces
this diagnostic:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">extension</span> E on String {
  void sayHello() {
    print('Hello $this');
  }
}</code></pre>

<h4 id="common-fixes-352">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the syntax to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.6.0</span><span class="nv"> </span><span class="s">&lt;2.7.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then rewrite the code to
not make use of extensions. The most common way to do this is to rewrite
the members of the extension as top-level functions (or methods) that take
the value that would have been bound to <code class="language-plaintext highlighter-rouge">this</code> as a parameter:</p>

<pre class="prettyprint lang-dart"><code>void sayHello(String s) {
  print('Hello $s');
}</code></pre>

<h3 id="sdk_version_gt_gt_gt_operator">
<a class="anchor" href="#sdk_version_gt_gt_gt_operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_gt_gt_gt_operator</h3>

<p><em>The operator ‘»&gt;’ wasn’t supported until version 2.14.0, but this code is
required to be able to run on earlier versions.</em></p>

<h4 id="description-353">Description</h4>

<p>The analyzer produces this diagnostic when the operator <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code> is used in
code that has an SDK constraint whose lower bound is less than 2.14.0. This
operator wasn’t supported in earlier versions, so this code won’t be able
to run against earlier versions of the SDK.</p>

<h4 id="example-321">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.14.0:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
 <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.0.0</span><span class="nv"> </span><span class="s">&lt;2.15.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces this
diagnostic:</p>

<pre class="prettyprint lang-dart"><code>int x = 3 <span class="highlight">&gt;&gt;&gt;</span> 4;</code></pre>

<h4 id="common-fixes-353">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the operator to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.14.0</span><span class="nv"> </span><span class="s">&lt;2.15.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then rewrite the code to
not use the <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code> operator:</p>

<pre class="prettyprint lang-dart"><code>int x = logicalShiftRight(3, 4);

int logicalShiftRight(int leftOperand, int rightOperand) {
  int divisor = 1 &lt;&lt; rightOperand;
  if (divisor == 0) {
    return 0;
  }
  return leftOperand ~/ divisor;
}</code></pre>

<h3 id="sdk_version_is_expression_in_const_context">
<a class="anchor" href="#sdk_version_is_expression_in_const_context" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_is_expression_in_const_context</h3>

<p><em>The use of an is expression in a constant context wasn’t supported until
version 2.3.2, but this code is required to be able to run on earlier versions.</em></p>

<h4 id="description-354">Description</h4>

<p>The analyzer produces this diagnostic when an <code class="language-plaintext highlighter-rouge">is</code> expression inside a
<a href="#constant-context">constant context</a> is found in code that has an SDK constraint whose
lower bound is less than 2.3.2. Using an <code class="language-plaintext highlighter-rouge">is</code> expression in a
<a href="#constant-context">constant context</a> wasn’t supported in earlier versions, so this code
won’t be able to run against earlier versions of the SDK.</p>

<h4 id="example-322">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.3.2:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.1.0</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces
this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>const Object x = 4;
const y = <span class="highlight">x is int</span> ? 0 : 1;</code></pre>

<h4 id="common-fixes-354">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the expression to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.3.2</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then either rewrite the
code to not use the <code class="language-plaintext highlighter-rouge">is</code> operator, or, if that isn’t possible, change the
code so that the <code class="language-plaintext highlighter-rouge">is</code> expression isn’t in a
<a href="#constant-context">constant context</a>:</p>

<pre class="prettyprint lang-dart"><code>const Object x = 4;
var y = x is int ? 0 : 1;</code></pre>

<h3 id="sdk_version_never">
<a class="anchor" href="#sdk_version_never" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_never</h3>

<p><em>The type ‘Never’ wasn’t supported until version 2.12.0, but this code is
required to be able to run on earlier versions.</em></p>

<h4 id="description-355">Description</h4>

<p>The analyzer produces this diagnostic when a reference to the class <code class="language-plaintext highlighter-rouge">Never</code>
is found in code that has an SDK constraint whose lower bound is less than
2.12.0. This class wasn’t defined in earlier versions, so this code won’t
be able to run against earlier versions of the SDK.</p>

<h4 id="example-323">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.12.0:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.5.0</span><span class="nv"> </span><span class="s">&lt;2.6.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces this
diagnostic:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">Never</span> n;</code></pre>

<h4 id="common-fixes-355">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the type to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.12.0</span><span class="nv"> </span><span class="s">&lt;2.13.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then rewrite the code to
not reference this class:</p>

<pre class="prettyprint lang-dart"><code>dynamic x;</code></pre>

<h3 id="sdk_version_set_literal">
<a class="anchor" href="#sdk_version_set_literal" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_set_literal</h3>

<p><em>Set literals weren’t supported until version 2.2, but this code is required to
be able to run on earlier versions.</em></p>

<h4 id="description-356">Description</h4>

<p>The analyzer produces this diagnostic when a set literal is found in code
that has an SDK constraint whose lower bound is less than 2.2.0. Set
literals weren’t supported in earlier versions, so this code won’t be able
to run against earlier versions of the SDK.</p>

<h4 id="example-324">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.2.0:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.1.0</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces this
diagnostic:</p>

<pre class="prettyprint lang-dart"><code>var s = <span class="highlight">&lt;int&gt;{}</span>;</code></pre>

<h4 id="common-fixes-356">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the syntax to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.2.0</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>If you do need to support older versions of the SDK, then replace the set
literal with code that creates the set without the use of a literal:</p>

<pre class="prettyprint lang-dart"><code>var s = new Set&lt;int&gt;();</code></pre>

<h3 id="sdk_version_ui_as_code">
<a class="anchor" href="#sdk_version_ui_as_code" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_ui_as_code</h3>

<p><em>The for, if, and spread elements weren’t supported until version 2.3.0, but
this code is required to be able to run on earlier versions.</em></p>

<h4 id="description-357">Description</h4>

<p>The analyzer produces this diagnostic when a for, if, or spread element is
found in code that has an SDK constraint whose lower bound is less than
2.3.0. Using a for, if, or spread element wasn’t supported in earlier
versions, so this code won’t be able to run against earlier versions of the
SDK.</p>

<h4 id="example-325">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.3.0:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.2.0</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces
this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>var digits = [<span class="highlight">for (int i = 0; i &lt; 10; i++) i</span>];</code></pre>

<h4 id="common-fixes-357">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the syntax to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.3.0</span><span class="nv"> </span><span class="s">&lt;2.4.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then rewrite the code to
not make use of those elements:</p>

<pre class="prettyprint lang-dart"><code>var digits = _initializeDigits();

List&lt;int&gt; _initializeDigits() {
  var digits = &lt;int&gt;[];
  for (int i = 0; i &lt; 10; i++) {
    digits.add(i);
  }
  return digits;
}</code></pre>

<h3 id="sdk_version_ui_as_code_in_const_context">
<a class="anchor" href="#sdk_version_ui_as_code_in_const_context" aria-hidden="true"><span class="octicon octicon-link"></span></a>sdk_version_ui_as_code_in_const_context</h3>

<p><em>The if and spread elements weren’t supported in constant expressions until
version 2.5.0, but this code is required to be able to run on earlier versions.</em></p>

<h4 id="description-358">Description</h4>

<p>The analyzer produces this diagnostic when an if or spread element inside
a <a href="#constant-context">constant context</a> is found in code that has an SDK constraint whose
lower bound is less than 2.5.0. Using an if or spread element inside a
<a href="#constant-context">constant context</a> wasn’t supported in earlier versions, so this code
won’t be able to run against earlier versions of the SDK.</p>

<h4 id="example-326">Example</h4>

<p>Here’s an example of a pubspec that defines an SDK constraint with a lower
bound of less than 2.5.0:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.4.0</span><span class="nv"> </span><span class="s">&lt;2.6.0'</span>
</code></pre></div></div>

<p>In the package that has that pubspec, code like the following produces
this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>const a = [1, 2];
const b = [<span class="highlight">...a</span>];</code></pre>

<h4 id="common-fixes-358">Common fixes</h4>

<p>If you don’t need to support older versions of the SDK, then you can
increase the SDK constraint to allow the syntax to be used:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">environment</span><span class="pi">:</span>
  <span class="na">sdk</span><span class="pi">:</span> <span class="s1">'</span><span class="s">&gt;=2.5.0</span><span class="nv"> </span><span class="s">&lt;2.6.0'</span>
</code></pre></div></div>

<p>If you need to support older versions of the SDK, then rewrite the code to
not make use of those elements:</p>

<pre class="prettyprint lang-dart"><code>const a = [1, 2];
const b = [1, 2];</code></pre>

<p>If that isn’t possible, change the code so that the element isn’t in a
<a href="#constant-context">constant context</a>:</p>

<pre class="prettyprint lang-dart"><code>const a = [1, 2];
var b = [...a];</code></pre>

<h3 id="set_element_type_not_assignable">
<a class="anchor" href="#set_element_type_not_assignable" aria-hidden="true"><span class="octicon octicon-link"></span></a>set_element_type_not_assignable</h3>

<p><em>The element type ‘{0}’ can’t be assigned to the set type ‘{1}’.</em></p>

<h4 id="description-359">Description</h4>

<p>The analyzer produces this diagnostic when an element in a set literal has
a type that isn’t assignable to the element type of the set.</p>

<h4 id="example-327">Example</h4>

<p>The following code produces this diagnostic because the type of the string
literal <code class="language-plaintext highlighter-rouge">'0'</code> is <code class="language-plaintext highlighter-rouge">String</code>, which isn’t assignable to <code class="language-plaintext highlighter-rouge">int</code>, the element
type of the set:</p>

<pre class="prettyprint lang-dart"><code>var s = &lt;int&gt;{<span class="highlight">'0'</span>};</code></pre>

<h4 id="common-fixes-359">Common fixes</h4>

<p>If the element type of the set literal is wrong, then change the element
type of the set:</p>

<pre class="prettyprint lang-dart"><code>var s = &lt;String&gt;{'0'};</code></pre>

<p>If the type of the element is wrong, then change the element:</p>

<pre class="prettyprint lang-dart"><code>var s = &lt;int&gt;{'0'.length};</code></pre>

<h3 id="shared_deferred_prefix">
<a class="anchor" href="#shared_deferred_prefix" aria-hidden="true"><span class="octicon octicon-link"></span></a>shared_deferred_prefix</h3>

<p><em>The prefix of a deferred import can’t be used in other import directives.</em></p>

<h4 id="description-360">Description</h4>

<p>The analyzer produces this diagnostic when a prefix in a deferred import is
also used as a prefix in other imports (whether deferred or not). The
prefix in a deferred import can’t be shared with other imports because the
prefix is used to load the imported library.</p>

<h4 id="example-328">Example</h4>

<p>The following code produces this diagnostic because the prefix <code class="language-plaintext highlighter-rouge">x</code> is used
as the prefix for a deferred import and is also used for one other import:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' <span class="highlight">deferred</span> as x;
import 'dart:convert' as x;

var y = x.json.encode(x.min(0, 1));</code></pre>

<h4 id="common-fixes-360">Common fixes</h4>

<p>If you can use a different name for the deferred import, then do so:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' deferred as math;
import 'dart:convert' as x;

var y = x.json.encode(math.min(0, 1));</code></pre>

<p>If you can use a different name for the other imports, then do so:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' deferred as x;
import 'dart:convert' as convert;

var y = convert.json.encode(x.min(0, 1));</code></pre>

<h3 id="size_annotation_dimensions">
<a class="anchor" href="#size_annotation_dimensions" aria-hidden="true"><span class="octicon octicon-link"></span></a>size_annotation_dimensions</h3>

<p><em>‘Array’s must have an ‘Array’ annotation that matches the dimensions.</em></p>

<h4 id="description-361">Description</h4>

<p>The analyzer produces this diagnostic when the number of dimensions
specified in an <code class="language-plaintext highlighter-rouge">Array</code> annotation doesn’t match the number of nested
arrays specified by the type of a field.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-329">Example</h4>

<p>The following code produces this diagnostic because the field <code class="language-plaintext highlighter-rouge">a0</code> has a
type with three nested arrays, but only two dimensions are given in the
<code class="language-plaintext highlighter-rouge">Array</code> annotation:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  <span class="highlight">@Array(8, 8)</span>
  external Array&lt;Array&lt;Array&lt;Uint8&gt;&gt;&gt; a0;
}</code></pre>

<h4 id="common-fixes-361">Common fixes</h4>

<p>If the type of the field is correct, then fix the annotation to have the
required number of dimensions:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Array(8, 8, 4)
  external Array&lt;Array&lt;Array&lt;Uint8&gt;&gt;&gt; a0;
}</code></pre>

<p>If the type of the field is wrong, then fix the type of the field:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Array(8, 8)
  external Array&lt;Array&lt;Uint8&gt;&gt; a0;
}</code></pre>

<h3 id="static_access_to_instance_member">
<a class="anchor" href="#static_access_to_instance_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>static_access_to_instance_member</h3>

<p><em>Instance member ‘{0}’ can’t be accessed using static access.</em></p>

<h4 id="description-362">Description</h4>

<p>The analyzer produces this diagnostic when a class name is used to access
an instance field. Instance fields don’t exist on a class; they exist only
on an instance of the class.</p>

<h4 id="example-330">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> is an instance
field:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static int a;

  int b;
}

int f() =&gt; C.<span class="highlight">b</span>;</code></pre>

<h4 id="common-fixes-362">Common fixes</h4>

<p>If you intend to access a static field, then change the name of the field
to an existing static field:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static int a;

  int b;
}

int f() =&gt; C.a;</code></pre>

<p>If you intend to access the instance field, then use an instance of the
class to access the field:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static int a;

  int b;
}

int f(C c) =&gt; c.b;</code></pre>

<h3 id="subtype_of_deferred_class">
<a class="anchor" href="#subtype_of_deferred_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>subtype_of_deferred_class</h3>

<p><em>Classes and mixins can’t implement deferred classes.</em></p>

<p><em>Classes can’t extend deferred classes.</em></p>

<p><em>Classes can’t mixin deferred classes.</em></p>

<h4 id="description-363">Description</h4>

<p>The analyzer produces this diagnostic when a type (class or mixin) is a
subtype of a class from a library being imported using a deferred import.
The supertypes of a type must be compiled at the same time as the type, and
classes from deferred libraries aren’t compiled until the library is
loaded.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-331">Example</h4>

<p>Given a file (<code class="language-plaintext highlighter-rouge">a.dart</code>) that defines the class <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {}</code></pre>

<p>The following code produces this diagnostic because the superclass of <code class="language-plaintext highlighter-rouge">B</code>
is declared in a deferred library:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' deferred as a;

class B extends <span class="highlight">a.A</span> {}</code></pre>

<h4 id="common-fixes-363">Common fixes</h4>

<p>If you need to create a subtype of a type from the deferred library, then
remove the <code class="language-plaintext highlighter-rouge">deferred</code> keyword:</p>

<pre class="prettyprint lang-dart"><code>import 'a.dart' as a;

class B extends a.A {}</code></pre>

<h3 id="subtype_of_disallowed_type">
<a class="anchor" href="#subtype_of_disallowed_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>subtype_of_disallowed_type</h3>

<p><em>’‘{0}’ can’t be used as a superclass constraint.</em></p>

<p><em>Classes and mixins can’t implement ‘{0}’.</em></p>

<p><em>Classes can’t extend ‘{0}’.</em></p>

<p><em>Classes can’t mixin ‘{0}’.</em></p>

<h4 id="description-364">Description</h4>

<p>The analyzer produces this diagnostic when one of the restricted classes is
used in either an <code class="language-plaintext highlighter-rouge">extends</code>, <code class="language-plaintext highlighter-rouge">implements</code>, <code class="language-plaintext highlighter-rouge">with</code>, or <code class="language-plaintext highlighter-rouge">on</code> clause. The
classes <code class="language-plaintext highlighter-rouge">bool</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">FutureOr</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">Null</code>, <code class="language-plaintext highlighter-rouge">num</code>, and <code class="language-plaintext highlighter-rouge">String</code>
are all restricted in this way, to allow for more efficient
implementations.</p>

<h4 id="examples-31">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">String</code> is used in an
<code class="language-plaintext highlighter-rouge">extends</code> clause:</p>

<pre class="prettyprint lang-dart"><code>class A extends <span class="highlight">String</span> {}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">String</code> is used in an
<code class="language-plaintext highlighter-rouge">implements</code> clause:</p>

<pre class="prettyprint lang-dart"><code>class B implements <span class="highlight">String</span> {}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">String</code> is used in a
<code class="language-plaintext highlighter-rouge">with</code> clause:</p>

<pre class="prettyprint lang-dart"><code>class C with <span class="highlight">String</span> {}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">String</code> is used in an
<code class="language-plaintext highlighter-rouge">on</code> clause:</p>

<pre class="prettyprint lang-dart"><code>mixin M on <span class="highlight">String</span> {}</code></pre>

<h4 id="common-fixes-364">Common fixes</h4>

<p>If a different type should be specified, then replace the type:</p>

<pre class="prettyprint lang-dart"><code>class A extends Object {}</code></pre>

<p>If there isn’t a different type that would be appropriate, then remove the
type, and possibly the whole clause:</p>

<pre class="prettyprint lang-dart"><code>class B {}</code></pre>

<h3 id="subtype_of_ffi_class">
<a class="anchor" href="#subtype_of_ffi_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>subtype_of_ffi_class</h3>

<p><em>The class ‘{0}’ can’t extend ‘{1}’.</em></p>

<p><em>The class ‘{0}’ can’t implement ‘{1}’.</em></p>

<p><em>The class ‘{0}’ can’t mix in ‘{1}’.</em></p>

<h4 id="description-365">Description</h4>

<p>The analyzer produces this diagnostic when a class extends any FFI class
other than <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code>, or implements or mixes in any FFI class.
<code class="language-plaintext highlighter-rouge">Struct</code> and <code class="language-plaintext highlighter-rouge">Union</code> are the only FFI classes that can be subtyped, and
then only by extending them.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-332">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code> extends
<code class="language-plaintext highlighter-rouge">Double</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends <span class="highlight">Double</span> {}</code></pre>

<h4 id="common-fixes-365">Common fixes</h4>

<p>If the class should extend either <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code>, then change the
declaration of the class:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class C extends Struct {
  @Int32()
  external int i;
}</code></pre>

<p>If the class shouldn’t extend either <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code>, then remove any
references to FFI classes:</p>

<pre class="prettyprint lang-dart"><code>class C {}</code></pre>

<h3 id="subtype_of_sealed_class">
<a class="anchor" href="#subtype_of_sealed_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>subtype_of_sealed_class</h3>

<p><em>The class ‘{0}’ shouldn’t be extended, mixed in, or implemented because it’s
sealed.</em></p>

<h4 id="description-366">Description</h4>

<p>The analyzer produces this diagnostic when a sealed class (one that either
has the <code class="language-plaintext highlighter-rouge">[sealed][meta-sealed]</code> annotation or inherits or mixes in a
sealed class) is referenced in either the <code class="language-plaintext highlighter-rouge">extends</code>, <code class="language-plaintext highlighter-rouge">implements</code>, or
<code class="language-plaintext highlighter-rouge">with</code> clause of a class or mixin declaration if the declaration isn’t in
the same package as the sealed class.</p>

<h4 id="example-333">Example</h4>

<p>Given a library in a package other than the package being analyzed that
contains the following:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class A {}

@sealed
class B {}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">C</code>, which isn’t in the
same package as <code class="language-plaintext highlighter-rouge">B</code>, is extending the sealed class <code class="language-plaintext highlighter-rouge">B</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'package:a/a.dart';

<span class="highlight">class C extends B {}</span></code></pre>

<h4 id="common-fixes-366">Common fixes</h4>

<p>If the class doesn’t need to be a subtype of the sealed class, then change
the declaration so that it isn’t:</p>

<pre class="prettyprint lang-dart"><code>import 'package:a/a.dart';

class B extends A {}</code></pre>

<p>If the class needs to be a subtype of the sealed class, then either change
the sealed class so that it’s no longer sealed or move the subclass into
the same package as the sealed class.</p>

<h3 id="subtype_of_struct_class">
<a class="anchor" href="#subtype_of_struct_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>subtype_of_struct_class</h3>

<p><em>The class ‘{0}’ can’t extend ‘{1}’ because ‘{1}’ is a subtype of ‘Struct’,
‘Union’, or ‘AbiSpecificInteger’.</em></p>

<p><em>The class ‘{0}’ can’t implement ‘{1}’ because ‘{1}’ is a subtype of ‘Struct’,
‘Union’, or ‘AbiSpecificInteger’.</em></p>

<p><em>The class ‘{0}’ can’t mix in ‘{1}’ because ‘{1}’ is a subtype of ‘Struct’,
‘Union’, or ‘AbiSpecificInteger’.</em></p>

<h4 id="description-367">Description</h4>

<p>The analyzer produces this diagnostic when a class extends, implements, or
mixes in a class that extends either <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code>. Classes can only
extend either <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code> directly.</p>

<p>For more information about FFI, see <a href="https://dart.dev/guides/libraries/c-interop">C interop using dart:ffi</a>.</p>

<h4 id="example-334">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code> extends
<code class="language-plaintext highlighter-rouge">S</code>, and <code class="language-plaintext highlighter-rouge">S</code> extends <code class="language-plaintext highlighter-rouge">Struct</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class S extends Struct {
  external Pointer f;
}

class C extends <span class="highlight">S</span> {
  external Pointer g;
}</code></pre>

<h4 id="common-fixes-367">Common fixes</h4>

<p>If you’re trying to define a struct or union that shares some fields
declared by a different struct or union, then extend <code class="language-plaintext highlighter-rouge">Struct</code> or <code class="language-plaintext highlighter-rouge">Union</code>
directly and copy the shared fields:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:ffi';

class S extends Struct {
  external Pointer f;
}

class C extends Struct {
  external Pointer f;

  external Pointer g;
}</code></pre>

<h3 id="supertype_expands_to_type_parameter">
<a class="anchor" href="#supertype_expands_to_type_parameter" aria-hidden="true"><span class="octicon octicon-link"></span></a>supertype_expands_to_type_parameter</h3>

<p><em>A type alias that expands to a type parameter can’t be implemented.</em></p>

<p><em>A type alias that expands to a type parameter can’t be mixed in.</em></p>

<p><em>A type alias that expands to a type parameter can’t be used as a superclass
constraint.</em></p>

<p><em>A type alias that expands to a type parameter can’t be used as a superclass.</em></p>

<h4 id="description-368">Description</h4>

<p>The analyzer produces this diagnostic when a type alias that expands to a
type parameter is used in an <code class="language-plaintext highlighter-rouge">extends</code>, <code class="language-plaintext highlighter-rouge">implements</code>, <code class="language-plaintext highlighter-rouge">with</code>, or <code class="language-plaintext highlighter-rouge">on</code>
clause.</p>

<h4 id="example-335">Example</h4>

<p>The following code produces this diagnostic because the type alias <code class="language-plaintext highlighter-rouge">T</code>,
which expands to the type parameter <code class="language-plaintext highlighter-rouge">S</code>, is used in the <code class="language-plaintext highlighter-rouge">extends</code> clause of
the class <code class="language-plaintext highlighter-rouge">C</code>:</p>

<pre class="prettyprint lang-dart"><code>typedef T&lt;S&gt; = S;

class C extends <span class="highlight">T</span>&lt;Object&gt; {}</code></pre>

<h4 id="common-fixes-368">Common fixes</h4>

<p>Use the value of the type argument directly:</p>

<pre class="prettyprint lang-dart"><code>typedef T&lt;S&gt; = S;

class C extends Object {}</code></pre>

<h3 id="super_formal_parameter_type_is_not_subtype_of_associated">
<a class="anchor" href="#super_formal_parameter_type_is_not_subtype_of_associated" aria-hidden="true"><span class="octicon octicon-link"></span></a>super_formal_parameter_type_is_not_subtype_of_associated</h3>

<p><em>The type ‘{0}’ of this parameter isn’t a subtype of the type ‘{1}’ of the
associated super constructor parameter.</em></p>

<h4 id="description-369">Description</h4>

<p>The analyzer produces this diagnostic when the type of a super parameter
isn’t a subtype of the corresponding parameter from the super constructor.</p>

<h4 id="example-336">Example</h4>

<p>The following code produces this diagnostic because the type of the super
parameter <code class="language-plaintext highlighter-rouge">x</code> in the constructor for <code class="language-plaintext highlighter-rouge">B</code> isn’t a subtype of the parameter
<code class="language-plaintext highlighter-rouge">x</code> in the constructor for <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(num x);
}

class B extends A {
  B(String super.<span class="highlight">x</span>);
}</code></pre>

<h4 id="common-fixes-369">Common fixes</h4>

<p>If the type of the super parameter can be the same as the parameter from
the super constructor, then remove the type annotation from the super
parameter (if the type is implicit, it is inferred from the type in the
super constructor):</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(num x);
}

class B extends A {
  B(super.x);
}</code></pre>

<p>If the type of the super parameter can be a subtype of the corresponding
parameter’s type, then change the type of the super parameter:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(num x);
}

class B extends A {
  B(int super.x);
}</code></pre>

<p>If the type of the super parameter can’t be changed, then use a normal
parameter instead of a super parameter:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(num x);
}

class B extends A {
  B(String x) : super(x.length);
}</code></pre>

<h3 id="super_formal_parameter_without_associated_named">
<a class="anchor" href="#super_formal_parameter_without_associated_named" aria-hidden="true"><span class="octicon octicon-link"></span></a>super_formal_parameter_without_associated_named</h3>

<p><em>No associated named super constructor parameter.</em></p>

<h4 id="description-370">Description</h4>

<p>The analyzer produces this diagnostic when there’s a named super parameter
in a constructor and the implicitly or explicitly invoked super
constructor doesn’t have a named parameter with the same name.</p>

<p>Named super parameters are associated by name with named parameters in the
super constructor.</p>

<h4 id="example-337">Example</h4>

<p>The following code produces this diagnostic because the constructor in <code class="language-plaintext highlighter-rouge">A</code>
doesn’t have a parameter named <code class="language-plaintext highlighter-rouge">y</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A({int? x});
}

class B extends A {
  B({super.<span class="highlight">y</span>});
}</code></pre>

<h4 id="common-fixes-370">Common fixes</h4>

<p>If the super parameter should be associated with an existing parameter
from the super constructor, then change the name to match the name of the
corresponding parameter:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A({int? x});
}

class B extends A {
  B({super.x});
}</code></pre>

<p>If the super parameter should be associated with a parameter that hasn’t
yet been added to the super constructor, then add it:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A({int? x, int? y});
}

class B extends A {
  B({super.y});
}</code></pre>

<p>If the super parameter doesn’t correspond to a named parameter from the
super constructor, then change it to be a normal parameter:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A({int? x});
}

class B extends A {
  B({int? y});
}</code></pre>

<h3 id="super_formal_parameter_without_associated_positional">
<a class="anchor" href="#super_formal_parameter_without_associated_positional" aria-hidden="true"><span class="octicon octicon-link"></span></a>super_formal_parameter_without_associated_positional</h3>

<p><em>No associated positional super constructor parameter.</em></p>

<h4 id="description-371">Description</h4>

<p>The analyzer produces this diagnostic when there’s a positional super
parameter in a constructor and the implicitly or explicitly invoked super
constructor doesn’t have a positional parameter at the corresponding
index.</p>

<p>Positional super parameters are associated with positional parameters in
the super constructor by their index. That is, the first super parameter
is associated with the first positional parameter in the super
constructor, the second with the second, and so on.</p>

<h4 id="examples-32">Examples</h4>

<p>The following code produces this diagnostic because the constructor in <code class="language-plaintext highlighter-rouge">B</code>
has a positional super parameter, but there’s no positional parameter in
the super constructor in <code class="language-plaintext highlighter-rouge">A</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A({int? x});
}

class B extends A {
  B(super.<span class="highlight">x</span>);
}</code></pre>

<p>The following code produces this diagnostic because the constructor in <code class="language-plaintext highlighter-rouge">B</code>
has two positional super parameters, but there’s only one positional
parameter in the super constructor in <code class="language-plaintext highlighter-rouge">A</code>, which means that there’s no
corresponding parameter for <code class="language-plaintext highlighter-rouge">y</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class B extends A {
  B(super.x, super.<span class="highlight">y</span>);
}</code></pre>

<h4 id="common-fixes-371">Common fixes</h4>

<p>If the super constructor should have a positional parameter corresponding
to the super parameter, then update the super constructor appropriately:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x, int y);
}

class B extends A {
  B(super.x, super.y);
}</code></pre>

<p>If the super constructor is correct, or can’t be changed, then convert the
super parameter into a normal parameter:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class B extends A {
  B(super.x, int y);
}</code></pre>

<h3 id="super_invocation_not_last">
<a class="anchor" href="#super_invocation_not_last" aria-hidden="true"><span class="octicon octicon-link"></span></a>super_invocation_not_last</h3>

<p><a id="invalid_super_invocation" aria-hidden="true"></a><em>(Previously known as <code class="language-plaintext highlighter-rouge">invalid_super_invocation</code>)</em></p>

<p><em>The superconstructor call must be last in an initializer list: ‘{0}’.</em></p>

<h4 id="description-372">Description</h4>

<p>The analyzer produces this diagnostic when the initializer list of a
constructor contains an invocation of a constructor in the superclass, but
the invocation isn’t the last item in the initializer list.</p>

<h4 id="example-338">Example</h4>

<p>The following code produces this diagnostic because the invocation of the
superclass’ constructor isn’t the last item in the initializer list:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class B extends A {
  B(int x) : <span class="highlight">super</span>(x), assert(x &gt;= 0);
}</code></pre>

<h4 id="common-fixes-372">Common fixes</h4>

<p>Move the invocation of the superclass’ constructor to the end of the
initializer list:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int x);
}

class B extends A {
  B(int x) : assert(x &gt;= 0), super(x);
}</code></pre>

<h3 id="super_in_enum_constructor">
<a class="anchor" href="#super_in_enum_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>super_in_enum_constructor</h3>

<p><em>The enum constructor can’t have a ‘super’ initializer.</em></p>

<h4 id="description-373">Description</h4>

<p>The analyzer produces this diagnostic when the initializer list in a
constructor in an enum contains an invocation of a super constructor.</p>

<h4 id="example-339">Example</h4>

<p>The following code produces this diagnostic because the constructor in
the enum <code class="language-plaintext highlighter-rouge">E</code> has a super constructor invocation in the initializer list:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  e;

  const E() : <span class="highlight">super</span>();
}</code></pre>

<h4 id="common-fixes-373">Common fixes</h4>

<p>Remove the super constructor invocation:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  e;

  const E();
}</code></pre>

<h3 id="super_in_extension">
<a class="anchor" href="#super_in_extension" aria-hidden="true"><span class="octicon octicon-link"></span></a>super_in_extension</h3>

<p><em>The ‘super’ keyword can’t be used in an extension because an extension doesn’t
have a superclass.</em></p>

<h4 id="description-374">Description</h4>

<p>The analyzer produces this diagnostic when a member declared inside an
extension uses the <code class="language-plaintext highlighter-rouge">super</code> keyword . Extensions aren’t classes and don’t
have superclasses, so the <code class="language-plaintext highlighter-rouge">super</code> keyword serves no purpose.</p>

<h4 id="example-340">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">super</code> can’t be used
in an extension:</p>

<pre class="prettyprint lang-dart"><code>extension E on Object {
  String get displayString =&gt; <span class="highlight">super</span>.toString();
}</code></pre>

<h4 id="common-fixes-374">Common fixes</h4>

<p>Remove the <code class="language-plaintext highlighter-rouge">super</code> keyword :</p>

<pre class="prettyprint lang-dart"><code>extension E on Object {
  String get displayString =&gt; toString();
}</code></pre>

<h3 id="super_in_invalid_context">
<a class="anchor" href="#super_in_invalid_context" aria-hidden="true"><span class="octicon octicon-link"></span></a>super_in_invalid_context</h3>

<p><em>Invalid context for ‘super’ invocation.</em></p>

<h4 id="description-375">Description</h4>

<p>The analyzer produces this diagnostic when the keyword <code class="language-plaintext highlighter-rouge">super</code> is used
outside of a instance method.</p>

<h4 id="example-341">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">super</code> is used in a
top-level function:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  <span class="highlight">super</span>.f();
}</code></pre>

<h4 id="common-fixes-375">Common fixes</h4>

<p>Rewrite the code to not use <code class="language-plaintext highlighter-rouge">super</code>.</p>

<h3 id="super_in_redirecting_constructor">
<a class="anchor" href="#super_in_redirecting_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>super_in_redirecting_constructor</h3>

<p><em>The redirecting constructor can’t have a ‘super’ initializer.</em></p>

<h4 id="description-376">Description</h4>

<p>The analyzer produces this diagnostic when a constructor that redirects to
another constructor also attempts to invoke a constructor from the
superclass. The superclass constructor will be invoked when the constructor
that the redirecting constructor is redirected to is invoked.</p>

<h4 id="example-342">Example</h4>

<p>The following code produces this diagnostic because the constructor <code class="language-plaintext highlighter-rouge">C.a</code>
both redirects to <code class="language-plaintext highlighter-rouge">C.b</code> and invokes a constructor from the superclass:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a() : this.b(), <span class="highlight">super()</span>;
  C.b();
}</code></pre>

<h4 id="common-fixes-376">Common fixes</h4>

<p>Remove the invocation of the <code class="language-plaintext highlighter-rouge">super</code> constructor:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C.a() : this.b();
  C.b();
}</code></pre>

<h3 id="switch_case_completes_normally">
<a class="anchor" href="#switch_case_completes_normally" aria-hidden="true"><span class="octicon octicon-link"></span></a>switch_case_completes_normally</h3>

<p><em>The ‘case’ shouldn’t complete normally.</em></p>

<h4 id="description-377">Description</h4>

<p>The analyzer produces this diagnostic when the statements following a
<code class="language-plaintext highlighter-rouge">case</code> label in a <code class="language-plaintext highlighter-rouge">switch</code> statement could fall through to the next <code class="language-plaintext highlighter-rouge">case</code>
or <code class="language-plaintext highlighter-rouge">default</code> label.</p>

<h4 id="example-343">Example</h4>

<p>The following code produces this diagnostic because the <code class="language-plaintext highlighter-rouge">case</code> label with
 a value of zero (<code class="language-plaintext highlighter-rouge">0</code>) falls through to the <code class="language-plaintext highlighter-rouge">default</code> statements:</p>

<pre class="prettyprint lang-dart"><code>void f(int a) {
  switch (a) {
    <span class="highlight">case</span> 0:
      print(0);
    default:
      return;
  }
}</code></pre>

<h4 id="common-fixes-377">Common fixes</h4>

<p>Change the flow of control so that the <code class="language-plaintext highlighter-rouge">case</code> won’t fall through. There
are several ways that this can be done, including adding one of the
following at the end of the current list of statements:</p>
<ul>
  <li>a <code class="language-plaintext highlighter-rouge">return</code> statement,</li>
  <li>a <code class="language-plaintext highlighter-rouge">throw</code> expression,</li>
  <li>a <code class="language-plaintext highlighter-rouge">break</code> statement,</li>
  <li>a <code class="language-plaintext highlighter-rouge">continue</code>, or</li>
  <li>an invocation of a function or method whose return type is <code class="language-plaintext highlighter-rouge">Never</code>.</li>
</ul>

<h3 id="switch_expression_not_assignable">
<a class="anchor" href="#switch_expression_not_assignable" aria-hidden="true"><span class="octicon octicon-link"></span></a>switch_expression_not_assignable</h3>

<p><em>Type ‘{0}’ of the switch expression isn’t assignable to the type ‘{1}’ of case
expressions.</em></p>

<h4 id="description-378">Description</h4>

<p>The analyzer produces this diagnostic when the type of the expression in a
<code class="language-plaintext highlighter-rouge">switch</code> statement isn’t assignable to the type of the expressions in the
<code class="language-plaintext highlighter-rouge">case</code> clauses.</p>

<h4 id="example-344">Example</h4>

<p>The following code produces this diagnostic because the type of <code class="language-plaintext highlighter-rouge">s</code>
(<code class="language-plaintext highlighter-rouge">String</code>) isn’t assignable to the type of <code class="language-plaintext highlighter-rouge">0</code> (<code class="language-plaintext highlighter-rouge">int</code>):</p>

<pre class="prettyprint lang-dart"><code>void f(String s) {
  switch (<span class="highlight">s</span>) {
    case 0:
      break;
  }
}</code></pre>

<h4 id="common-fixes-378">Common fixes</h4>

<p>If the type of the <code class="language-plaintext highlighter-rouge">case</code> expressions is correct, then change the
expression in the <code class="language-plaintext highlighter-rouge">switch</code> statement to have the correct type:</p>

<pre class="prettyprint lang-dart"><code>void f(String s) {
  switch (int.parse(s)) {
    case 0:
      break;
  }
}</code></pre>

<p>If the type of the <code class="language-plaintext highlighter-rouge">switch</code> expression is correct, then change the <code class="language-plaintext highlighter-rouge">case</code>
expressions to have the correct type:</p>

<pre class="prettyprint lang-dart"><code>void f(String s) {
  switch (s) {
    case '0':
      break;
  }
}</code></pre>

<h3 id="tearoff_of_generative_constructor_of_abstract_class">
<a class="anchor" href="#tearoff_of_generative_constructor_of_abstract_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>tearoff_of_generative_constructor_of_abstract_class</h3>

<p><em>A generative constructor of an abstract class can’t be torn off.</em></p>

<h4 id="description-379">Description</h4>

<p>The analyzer produces this diagnostic when a generative constructor from an
abstract class is being torn off. This isn’t allowed because it isn’t valid
to create an instance of an abstract class, which means that there isn’t
any valid use for the torn off constructor.</p>

<h4 id="example-345">Example</h4>

<p>The following code produces this diagnostic because the constructor <code class="language-plaintext highlighter-rouge">C.new</code>
is being torn off and the class <code class="language-plaintext highlighter-rouge">C</code> is an abstract class:</p>

<pre class="prettyprint lang-dart"><code>abstract class C {
  C();
}

void f() {
  <span class="highlight">C.new</span>;
}</code></pre>

<h4 id="common-fixes-379">Common fixes</h4>

<p>Tear off the constructor of a concrete class.</p>

<h3 id="text_direction_code_point_in_comment">
<a class="anchor" href="#text_direction_code_point_in_comment" aria-hidden="true"><span class="octicon octicon-link"></span></a>text_direction_code_point_in_comment</h3>

<p><em>The Unicode code point ‘U+{0}’ changes the appearance of text from how it’s
interpreted by the compiler.</em></p>

<h4 id="description-380">Description</h4>

<p>The analyzer produces this diagnostic when it encounters source that
contains text direction Unicode code points. These code points cause
source code in either a string literal or a comment to be interpreted
and compiled differently than how it appears in editors, leading to
possible security vulnerabilities.</p>

<h4 id="example-346">Example</h4>

<p>The following code produces this diagnostic twice because there are
hidden characters at the start and end of the label string:</p>

<pre class="prettyprint lang-dart"><code>var label = '<span class="highlight">I</span>nteractive text<span class="highlight">'</span>;</code></pre>

<h4 id="common-fixes-380">Common fixes</h4>

<p>If the code points are intended to be included in the string literal,
then escape them:</p>

<pre class="prettyprint lang-dart"><code>var label = '\u202AInteractive text\u202C';</code></pre>

<p>If the code points aren’t intended to be included in the string literal,
then remove them:</p>

<pre class="prettyprint lang-dart"><code>var label = 'Interactive text';</code></pre>

<h3 id="text_direction_code_point_in_literal">
<a class="anchor" href="#text_direction_code_point_in_literal" aria-hidden="true"><span class="octicon octicon-link"></span></a>text_direction_code_point_in_literal</h3>

<p><em>The Unicode code point ‘U+{0}’ changes the appearance of text from how it’s
interpreted by the compiler.</em></p>

<h4 id="description-381">Description</h4>

<p>The analyzer produces this diagnostic when it encounters source that
contains text direction Unicode code points. These code points cause
source code in either a string literal or a comment to be interpreted
and compiled differently than how it appears in editors, leading to
possible security vulnerabilities.</p>

<h4 id="example-347">Example</h4>

<p>The following code produces this diagnostic twice because there are
hidden characters at the start and end of the label string:</p>

<pre class="prettyprint lang-dart"><code>var label = '<span class="highlight">I</span>nteractive text<span class="highlight">'</span>;</code></pre>

<h4 id="common-fixes-381">Common fixes</h4>

<p>If the code points are intended to be included in the string literal,
then escape them:</p>

<pre class="prettyprint lang-dart"><code>var label = '\u202AInteractive text\u202C';</code></pre>

<p>If the code points aren’t intended to be included in the string literal,
then remove them:</p>

<pre class="prettyprint lang-dart"><code>var label = 'Interactive text';</code></pre>

<h3 id="throw_of_invalid_type">
<a class="anchor" href="#throw_of_invalid_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>throw_of_invalid_type</h3>

<p><em>The type ‘{0}’ of the thrown expression must be assignable to ‘Object’.</em></p>

<h4 id="description-382">Description</h4>

<p>The analyzer produces this diagnostic when the type of the expression in a
throw expression isn’t assignable to <code class="language-plaintext highlighter-rouge">Object</code>. It isn’t valid to throw
<code class="language-plaintext highlighter-rouge">null</code>, so it isn’t valid to use an expression that might evaluate to
<code class="language-plaintext highlighter-rouge">null</code>.</p>

<h4 id="example-348">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">s</code> might be <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(String? s) {
  throw <span class="highlight">s</span>;
}</code></pre>

<h4 id="common-fixes-382">Common fixes</h4>

<p>Add an explicit null check to the expression:</p>

<pre class="prettyprint lang-dart"><code>void f(String? s) {
  throw s!;
}</code></pre>

<h3 id="top_level_cycle">
<a class="anchor" href="#top_level_cycle" aria-hidden="true"><span class="octicon octicon-link"></span></a>top_level_cycle</h3>

<p><em>The type of ‘{0}’ can’t be inferred because it depends on itself through the
cycle: {1}.</em></p>

<h4 id="description-383">Description</h4>

<p>The analyzer produces this diagnostic when a top-level variable has no type
annotation and the variable’s initializer refers to the variable, either
directly or indirectly.</p>

<h4 id="example-349">Example</h4>

<p>The following code produces this diagnostic because the variables <code class="language-plaintext highlighter-rouge">x</code> and
<code class="language-plaintext highlighter-rouge">y</code> are defined in terms of each other, and neither has an explicit type,
so the type of the other can’t be inferred:</p>

<pre class="prettyprint lang-dart"><code>var x = y;
var y = <span class="highlight">x</span>;</code></pre>

<h4 id="common-fixes-383">Common fixes</h4>

<p>If the two variables don’t need to refer to each other, then break the
cycle:</p>

<pre class="prettyprint lang-dart"><code>var x = 0;
var y = x;</code></pre>

<p>If the two variables need to refer to each other, then give at least one of
them an explicit type:</p>

<pre class="prettyprint lang-dart"><code>int x = y;
var y = x;</code></pre>

<p>Note, however, that while this code doesn’t produce any diagnostics, it
will produce a stack overflow at runtime unless at least one of the
variables is assigned a value that doesn’t depend on the other variables
before any of the variables in the cycle are referenced.</p>

<h3 id="type_alias_cannot_reference_itself">
<a class="anchor" href="#type_alias_cannot_reference_itself" aria-hidden="true"><span class="octicon octicon-link"></span></a>type_alias_cannot_reference_itself</h3>

<p><em>Typedefs can’t reference themselves directly or recursively via another
typedef.</em></p>

<h4 id="description-384">Description</h4>

<p>The analyzer produces this diagnostic when a typedef refers to itself,
either directly or indirectly.</p>

<h4 id="example-350">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">F</code> depends on itself
indirectly through <code class="language-plaintext highlighter-rouge">G</code>:</p>

<pre class="prettyprint lang-dart"><code>typedef <span class="highlight">F</span> = void Function(G);
typedef G = void Function(F);</code></pre>

<h4 id="common-fixes-384">Common fixes</h4>

<p>Change one or more of the typedefs in the cycle so that none of them refer
to themselves:</p>

<pre class="prettyprint lang-dart"><code>typedef F = void Function(G);
typedef G = void Function(int);</code></pre>

<h3 id="type_annotation_deferred_class">
<a class="anchor" href="#type_annotation_deferred_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>type_annotation_deferred_class</h3>

<p><em>The deferred type ‘{0}’ can’t be used in a declaration, cast, or type test.</em></p>

<h4 id="description-385">Description</h4>

<p>The analyzer produces this diagnostic when the type annotation is in a
variable declaration, or the type used in a cast (<code class="language-plaintext highlighter-rouge">as</code>) or type test (<code class="language-plaintext highlighter-rouge">is</code>)
is a type declared in a library that is imported using a deferred import.
These types are required to be available at compile time, but aren’t.</p>

<p>For more information, see the language tour’s coverage of
<a href="https://dart.dev/guides/language/language-tour#lazily-loading-a-library">deferred loading</a>.</p>

<h4 id="example-351">Example</h4>

<p>The following code produces this diagnostic because the type of the
parameter <code class="language-plaintext highlighter-rouge">f</code> is imported from a deferred library:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:io' deferred as io;

void f(<span class="highlight">io.File</span> f) {}</code></pre>

<h4 id="common-fixes-385">Common fixes</h4>

<p>If you need to reference the imported type, then remove the <code class="language-plaintext highlighter-rouge">deferred</code>
keyword:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:io' as io;

void f(io.File f) {}</code></pre>

<p>If the import is required to be deferred and there’s another type that is
appropriate, then use that type in place of the type from the deferred
library.</p>

<h3 id="type_argument_not_matching_bounds">
<a class="anchor" href="#type_argument_not_matching_bounds" aria-hidden="true"><span class="octicon octicon-link"></span></a>type_argument_not_matching_bounds</h3>

<p><em>‘{0}’ doesn’t conform to the bound ‘{2}’ of the type parameter ‘{1}’.</em></p>

<h4 id="description-386">Description</h4>

<p>The analyzer produces this diagnostic when a type argument isn’t the same
as or a subclass of the bounds of the corresponding type parameter.</p>

<h4 id="example-352">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">String</code> isn’t a
subclass of <code class="language-plaintext highlighter-rouge">num</code>:</p>

<pre class="prettyprint lang-dart"><code>class A&lt;E extends num&gt; {}

var a = A&lt;<span class="highlight">String</span>&gt;();</code></pre>

<h4 id="common-fixes-386">Common fixes</h4>

<p>Change the type argument to be a subclass of the bounds:</p>

<pre class="prettyprint lang-dart"><code>class A&lt;E extends num&gt; {}

var a = A&lt;int&gt;();</code></pre>

<h3 id="type_check_with_null">
<a class="anchor" href="#type_check_with_null" aria-hidden="true"><span class="octicon octicon-link"></span></a>type_check_with_null</h3>

<p><em>Tests for non-null should be done with ‘!= null’.</em></p>

<p><em>Tests for null should be done with ‘== null’.</em></p>

<h4 id="description-387">Description</h4>

<p>The analyzer produces this diagnostic when there’s a type check (using the
<code class="language-plaintext highlighter-rouge">as</code> operator) where the type is <code class="language-plaintext highlighter-rouge">Null</code>. There’s only one value whose type
is <code class="language-plaintext highlighter-rouge">Null</code>, so the code is both more readable and more performant when it
tests for <code class="language-plaintext highlighter-rouge">null</code> explicitly.</p>

<h4 id="examples-33">Examples</h4>

<p>The following code produces this diagnostic because the code is testing to
see whether the value of <code class="language-plaintext highlighter-rouge">s</code> is <code class="language-plaintext highlighter-rouge">null</code> by using a type check:</p>

<pre class="prettyprint lang-dart"><code>void f(String? s) {
  if (<span class="highlight">s is Null</span>) {
    return;
  }
  print(s);
}</code></pre>

<p>The following code produces this diagnostic because the code is testing to
see whether the value of <code class="language-plaintext highlighter-rouge">s</code> is something other than <code class="language-plaintext highlighter-rouge">null</code> by using a type
check:</p>

<pre class="prettyprint lang-dart"><code>void f(String? s) {
  if (<span class="highlight">s is! Null</span>) {
    print(s);
  }
}</code></pre>

<h4 id="common-fixes-387">Common fixes</h4>

<p>Replace the type check with the equivalent comparison with <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(String? s) {
  if (s == null) {
    return;
  }
  print(s);
}</code></pre>

<h3 id="type_parameter_referenced_by_static">
<a class="anchor" href="#type_parameter_referenced_by_static" aria-hidden="true"><span class="octicon octicon-link"></span></a>type_parameter_referenced_by_static</h3>

<p><em>Static members can’t reference type parameters of the class.</em></p>

<h4 id="description-388">Description</h4>

<p>The analyzer produces this diagnostic when a static member references a
type parameter that is declared for the class. Type parameters only have
meaning for instances of the class.</p>

<h4 id="example-353">Example</h4>

<p>The following code produces this diagnostic because the static method
<code class="language-plaintext highlighter-rouge">hasType</code> has a reference to the type parameter <code class="language-plaintext highlighter-rouge">T</code>:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  static bool hasType(Object o) =&gt; o is <span class="highlight">T</span>;
}</code></pre>

<h4 id="common-fixes-388">Common fixes</h4>

<p>If the member can be an instance member, then remove the keyword <code class="language-plaintext highlighter-rouge">static</code>:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  bool hasType(Object o) =&gt; o is T;
}</code></pre>

<p>If the member must be a static member, then make the member be generic:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  static bool hasType&lt;S&gt;(Object o) =&gt; o is S;
}</code></pre>

<p>Note, however, that there isn’t a relationship between <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">S</code>, so this
second option changes the semantics from what was likely to be intended.</p>

<h3 id="type_parameter_supertype_of_its_bound">
<a class="anchor" href="#type_parameter_supertype_of_its_bound" aria-hidden="true"><span class="octicon octicon-link"></span></a>type_parameter_supertype_of_its_bound</h3>

<p><em>‘{0}’ can’t be a supertype of its upper bound.</em></p>

<h4 id="description-389">Description</h4>

<p>The analyzer produces this diagnostic when the bound of a type parameter
(the type following the <code class="language-plaintext highlighter-rouge">extends</code> keyword) is either directly or indirectly
the type parameter itself. Stating that the type parameter must be the same
as itself or a subtype of itself or a subtype of itself isn’t helpful
because it will always be the same as itself.</p>

<h4 id="examples-34">Examples</h4>

<p>The following code produces this diagnostic because the bound of <code class="language-plaintext highlighter-rouge">T</code> is
<code class="language-plaintext highlighter-rouge">T</code>:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;<span class="highlight">T</span> extends T&gt; {}</code></pre>

<p>The following code produces this diagnostic because the bound of <code class="language-plaintext highlighter-rouge">T1</code> is
<code class="language-plaintext highlighter-rouge">T2</code>, and the bound of <code class="language-plaintext highlighter-rouge">T2</code> is <code class="language-plaintext highlighter-rouge">T1</code>, effectively making the bound of <code class="language-plaintext highlighter-rouge">T1</code>
be <code class="language-plaintext highlighter-rouge">T1</code>:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;<span class="highlight">T1</span> extends T2, T2 extends T1&gt; {}</code></pre>

<h4 id="common-fixes-389">Common fixes</h4>

<p>If the type parameter needs to be a subclass of some type, then replace the
bound with the required type:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T extends num&gt; {}</code></pre>

<p>If the type parameter can be any type, then remove the <code class="language-plaintext highlighter-rouge">extends</code> clause:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {}</code></pre>

<h3 id="type_test_with_non_type">
<a class="anchor" href="#type_test_with_non_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>type_test_with_non_type</h3>

<p><em>The name ‘{0}’ isn’t a type and can’t be used in an ‘is’ expression.</em></p>

<h4 id="description-390">Description</h4>

<p>The analyzer produces this diagnostic when the right-hand side of an <code class="language-plaintext highlighter-rouge">is</code>
or <code class="language-plaintext highlighter-rouge">is!</code> test isn’t a type.</p>

<h4 id="example-354">Example</h4>

<p>The following code produces this diagnostic because the right-hand side is
a parameter, not a type:</p>

<pre class="prettyprint lang-dart"><code>typedef B = int Function(int);

void f(Object a, B b) {
  if (a is <span class="highlight">b</span>) {
    return;
  }
}</code></pre>

<h4 id="common-fixes-390">Common fixes</h4>

<p>If you intended to use a type test, then replace the right-hand side with a
type:</p>

<pre class="prettyprint lang-dart"><code>typedef B = int Function(int);

void f(Object a, B b) {
  if (a is B) {
    return;
  }
}</code></pre>

<p>If you intended to use a different kind of test, then change the test:</p>

<pre class="prettyprint lang-dart"><code>typedef B = int Function(int);

void f(Object a, B b) {
  if (a == b) {
    return;
  }
}</code></pre>

<h3 id="type_test_with_undefined_name">
<a class="anchor" href="#type_test_with_undefined_name" aria-hidden="true"><span class="octicon octicon-link"></span></a>type_test_with_undefined_name</h3>

<p><em>The name ‘{0}’ isn’t defined, so it can’t be used in an ‘is’ expression.</em></p>

<h4 id="description-391">Description</h4>

<p>The analyzer produces this diagnostic when the name following the <code class="language-plaintext highlighter-rouge">is</code> in a
type test expression isn’t defined.</p>

<h4 id="example-355">Example</h4>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">Srting</code> isn’t
defined:</p>

<pre class="prettyprint lang-dart"><code>void f(Object o) {
  if (o is <span class="highlight">Srting</span>) {
    // ...
  }
}</code></pre>

<h4 id="common-fixes-391">Common fixes</h4>

<p>Replace the name with the name of a type:</p>

<pre class="prettyprint lang-dart"><code>void f(Object o) {
  if (o is String) {
    // ...
  }
}</code></pre>

<h3 id="unchecked_use_of_nullable_value">
<a class="anchor" href="#unchecked_use_of_nullable_value" aria-hidden="true"><span class="octicon octicon-link"></span></a>unchecked_use_of_nullable_value</h3>

<p><em>A nullable expression can’t be used as a condition.</em></p>

<p><em>A nullable expression can’t be used as an iterator in a for-in loop.</em></p>

<p><em>A nullable expression can’t be used in a spread.</em></p>

<p><em>A nullable expression can’t be used in a yield-each statement.</em></p>

<p><em>The function can’t be unconditionally invoked because it can be ‘null’.</em></p>

<p><em>The method ‘{0}’ can’t be unconditionally invoked because the receiver can be
‘null’.</em></p>

<p><em>The operator ‘{0}’ can’t be unconditionally invoked because the receiver can be
‘null’.</em></p>

<p><em>The property ‘{0}’ can’t be unconditionally accessed because the receiver can
be ‘null’.</em></p>

<h4 id="description-392">Description</h4>

<p>The analyzer produces this diagnostic when an expression whose type is
<a href="#potentially-non-nullable">potentially non-nullable</a> is dereferenced without first verifying that
the value isn’t <code class="language-plaintext highlighter-rouge">null</code>.</p>

<h4 id="example-356">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">s</code> can be <code class="language-plaintext highlighter-rouge">null</code> at
the point where it’s referenced:</p>

<pre class="prettyprint lang-dart"><code>void f(String? s) {
  if (s.<span class="highlight">length</span> &gt; 3) {
    // ...
  }
}</code></pre>

<h4 id="common-fixes-392">Common fixes</h4>

<p>If the value really can be <code class="language-plaintext highlighter-rouge">null</code>, then add a test to ensure that members
are only accessed when the value isn’t <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(String? s) {
  if (s != null &amp;&amp; s.length &gt; 3) {
    // ...
  }
}</code></pre>

<p>If the expression is a variable and the value should never be <code class="language-plaintext highlighter-rouge">null</code>, then
change the type of the variable to be non-nullable:</p>

<pre class="prettyprint lang-dart"><code>void f(String s) {
  if (s.length &gt; 3) {
    // ...
  }
}</code></pre>

<p>If you believe that the value of the expression should never be <code class="language-plaintext highlighter-rouge">null</code>, but
you can’t change the type of the variable, and you’re willing to risk
having an exception thrown at runtime if you’re wrong, then you can assert
that the value isn’t null:</p>

<pre class="prettyprint lang-dart"><code>void f(String? s) {
  if (s!.length &gt; 3) {
    // ...
  }
}</code></pre>

<h3 id="undefined_annotation">
<a class="anchor" href="#undefined_annotation" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_annotation</h3>

<p><em>Undefined name ‘{0}’ used as an annotation.</em></p>

<h4 id="description-393">Description</h4>

<p>The analyzer produces this diagnostic when a name that isn’t defined is
used as an annotation.</p>

<h4 id="example-357">Example</h4>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">undefined</code>
isn’t defined:</p>

<pre class="prettyprint lang-dart"><code><span class="highlight">@undefined</span>
void f() {}</code></pre>

<h4 id="common-fixes-393">Common fixes</h4>

<p>If the name is correct, but it isn’t declared yet, then declare the name as
a constant value:</p>

<pre class="prettyprint lang-dart"><code>const undefined = 'undefined';

@undefined
void f() {}</code></pre>

<p>If the name is wrong, replace the name with the name of a valid constant:</p>

<pre class="prettyprint lang-dart"><code>@deprecated
void f() {}</code></pre>

<p>Otherwise, remove the annotation.</p>

<h3 id="undefined_class">
<a class="anchor" href="#undefined_class" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_class</h3>

<p><em>Undefined class ‘{0}’.</em></p>

<h4 id="description-394">Description</h4>

<p>The analyzer produces this diagnostic when it encounters an identifier that
appears to be the name of a class but either isn’t defined or isn’t visible
in the scope in which it’s being referenced.</p>

<h4 id="example-358">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">Piont</code> isn’t defined:</p>

<pre class="prettyprint lang-dart"><code>class Point {}

void f(<span class="highlight">Piont</span> p) {}</code></pre>

<h4 id="common-fixes-394">Common fixes</h4>

<p>If the identifier isn’t defined, then either define it or replace it with
the name of a class that is defined. The example above can be corrected by
fixing the spelling of the class:</p>

<pre class="prettyprint lang-dart"><code>class Point {}

void f(Point p) {}</code></pre>

<p>If the class is defined but isn’t visible, then you probably need to add an
import.</p>

<h3 id="undefined_constructor_in_initializer">
<a class="anchor" href="#undefined_constructor_in_initializer" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_constructor_in_initializer</h3>

<p><em>The class ‘{0}’ doesn’t have a constructor named ‘{1}’.</em></p>

<p><em>The class ‘{0}’ doesn’t have an unnamed constructor.</em></p>

<h4 id="description-395">Description</h4>

<p>The analyzer produces this diagnostic when a superclass constructor is
invoked in the initializer list of a constructor, but the superclass
doesn’t define the constructor being invoked.</p>

<h4 id="examples-35">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">A</code> doesn’t have an
unnamed constructor:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A.n();
}
class B extends A {
  B() : <span class="highlight">super()</span>;
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">A</code> doesn’t have a
constructor named <code class="language-plaintext highlighter-rouge">m</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A.n();
}
class B extends A {
  B() : <span class="highlight">super.m()</span>;
}</code></pre>

<h4 id="common-fixes-395">Common fixes</h4>

<p>If the superclass defines a constructor that should be invoked, then change
the constructor being invoked:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A.n();
}
class B extends A {
  B() : super.n();
}</code></pre>

<p>If the superclass doesn’t define an appropriate constructor, then define
the constructor being invoked:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A.m();
  A.n();
}
class B extends A {
  B() : super.m();
}</code></pre>

<h3 id="undefined_enum_constant">
<a class="anchor" href="#undefined_enum_constant" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_enum_constant</h3>

<p><em>There’s no constant named ‘{0}’ in ‘{1}’.</em></p>

<h4 id="description-396">Description</h4>

<p>The analyzer produces this diagnostic when it encounters an identifier that
appears to be the name of an enum constant, and the name either isn’t
defined or isn’t visible in the scope in which it’s being referenced.</p>

<h4 id="example-359">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">E</code> doesn’t define a
constant named <code class="language-plaintext highlighter-rouge">c</code>:</p>

<pre class="prettyprint lang-dart"><code>enum E {a, b}

var e = E.<span class="highlight">c</span>;</code></pre>

<h4 id="common-fixes-396">Common fixes</h4>

<p>If the constant should be defined, then add it to the declaration of the
enum:</p>

<pre class="prettyprint lang-dart"><code>enum E {a, b, c}

var e = E.c;</code></pre>

<p>If the constant shouldn’t be defined, then change the name to the name of
an existing constant:</p>

<pre class="prettyprint lang-dart"><code>enum E {a, b}

var e = E.b;</code></pre>

<h3 id="undefined_enum_constructor">
<a class="anchor" href="#undefined_enum_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_enum_constructor</h3>

<p><em>The enum doesn’t have a constructor named ‘{0}’.</em></p>

<p><em>The enum doesn’t have an unnamed constructor.</em></p>

<h4 id="description-397">Description</h4>

<p>The analyzer produces this diagnostic when the constructor invoked to
initialize an enum constant doesn’t exist.</p>

<h4 id="examples-36">Examples</h4>

<p>The following code produces this diagnostic because the enum constant <code class="language-plaintext highlighter-rouge">c</code>
is being initialized by the unnamed constructor, but there’s no unnamed
constructor defined in <code class="language-plaintext highlighter-rouge">E</code>:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  <span class="highlight">c</span>();

  const E.x();
}</code></pre>

<p>The following code produces this diagnostic because the enum constant <code class="language-plaintext highlighter-rouge">c</code>
is being initialized by the constructor named <code class="language-plaintext highlighter-rouge">x</code>, but there’s no
constructor named <code class="language-plaintext highlighter-rouge">x</code> defined in <code class="language-plaintext highlighter-rouge">E</code>:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  c.<span class="highlight">x</span>();

  const E.y();
}</code></pre>

<h4 id="common-fixes-397">Common fixes</h4>

<p>If the enum constant is being initialized by the unnamed constructor and
one of the named constructors should have been used, then add the name of
the constructor:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  c.x();

  const E.x();
}</code></pre>

<p>If the enum constant is being initialized by the unnamed constructor and
none of the named constructors are appropriate, then define the unnamed
constructor:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  c();

  const E();
}</code></pre>

<p>If the enum constant is being initialized by a named constructor and one
of the existing constructors should have been used, then change the name
of the constructor being invoked (or remove it if the unnamed constructor
should be used):</p>

<pre class="prettyprint lang-dart"><code>enum E {
  c.y();

  const E();
  const E.y();
}</code></pre>

<p>If the enum constant is being initialized by a named constructor and none
of the existing constructors should have been used, then define a
constructor with the name that was used:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  c.x();

  const E.x();
}</code></pre>

<h3 id="undefined_extension_getter">
<a class="anchor" href="#undefined_extension_getter" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_extension_getter</h3>

<p><em>The getter ‘{0}’ isn’t defined for the extension ‘{1}’.</em></p>

<h4 id="description-398">Description</h4>

<p>The analyzer produces this diagnostic when an extension override is used to
invoke a getter, but the getter isn’t defined by the specified extension.
The analyzer also produces this diagnostic when a static getter is
referenced but isn’t defined by the specified extension.</p>

<h4 id="examples-37">Examples</h4>

<p>The following code produces this diagnostic because the extension <code class="language-plaintext highlighter-rouge">E</code>
doesn’t declare an instance getter named <code class="language-plaintext highlighter-rouge">b</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String get a =&gt; 'a';
}

extension F on String {
  String get b =&gt; 'b';
}

void f() {
  E('c').<span class="highlight">b</span>;
}</code></pre>

<p>The following code produces this diagnostic because the extension <code class="language-plaintext highlighter-rouge">E</code>
doesn’t declare a static getter named <code class="language-plaintext highlighter-rouge">a</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {}

var x = E.<span class="highlight">a</span>;</code></pre>

<h4 id="common-fixes-398">Common fixes</h4>

<p>If the name of the getter is incorrect, then change it to the name of an
existing getter:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String get a =&gt; 'a';
}

extension F on String {
  String get b =&gt; 'b';
}

void f() {
  E('c').a;
}</code></pre>

<p>If the name of the getter is correct but the name of the extension is
wrong, then change the name of the extension to the correct name:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String get a =&gt; 'a';
}

extension F on String {
  String get b =&gt; 'b';
}

void f() {
  F('c').b;
}</code></pre>

<p>If the name of the getter and extension are both correct, but the getter
isn’t defined, then define the getter:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String get a =&gt; 'a';
  String get b =&gt; 'z';
}

extension F on String {
  String get b =&gt; 'b';
}

void f() {
  E('c').b;
}</code></pre>

<h3 id="undefined_extension_method">
<a class="anchor" href="#undefined_extension_method" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_extension_method</h3>

<p><em>The method ‘{0}’ isn’t defined for the extension ‘{1}’.</em></p>

<h4 id="description-399">Description</h4>

<p>The analyzer produces this diagnostic when an extension override is used to
invoke a method, but the method isn’t defined by the specified extension.
The analyzer also produces this diagnostic when a static method is
referenced but isn’t defined by the specified extension.</p>

<h4 id="examples-38">Examples</h4>

<p>The following code produces this diagnostic because the extension <code class="language-plaintext highlighter-rouge">E</code>
doesn’t declare an instance method named <code class="language-plaintext highlighter-rouge">b</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String a() =&gt; 'a';
}

extension F on String {
  String b() =&gt; 'b';
}

void f() {
  E('c').<span class="highlight">b</span>();
}</code></pre>

<p>The following code produces this diagnostic because the extension <code class="language-plaintext highlighter-rouge">E</code>
doesn’t declare a static method named <code class="language-plaintext highlighter-rouge">a</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {}

var x = E.<span class="highlight">a</span>();</code></pre>

<h4 id="common-fixes-399">Common fixes</h4>

<p>If the name of the method is incorrect, then change it to the name of an
existing method:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String a() =&gt; 'a';
}

extension F on String {
  String b() =&gt; 'b';
}

void f() {
  E('c').a();
}</code></pre>

<p>If the name of the method is correct, but the name of the extension is
wrong, then change the name of the extension to the correct name:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String a() =&gt; 'a';
}

extension F on String {
  String b() =&gt; 'b';
}

void f() {
  F('c').b();
}</code></pre>

<p>If the name of the method and extension are both correct, but the method
isn’t defined, then define the method:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  String a() =&gt; 'a';
  String b() =&gt; 'z';
}

extension F on String {
  String b() =&gt; 'b';
}

void f() {
  E('c').b();
}</code></pre>

<h3 id="undefined_extension_operator">
<a class="anchor" href="#undefined_extension_operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_extension_operator</h3>

<p><em>The operator ‘{0}’ isn’t defined for the extension ‘{1}’.</em></p>

<h4 id="description-400">Description</h4>

<p>The analyzer produces this diagnostic when an operator is invoked on a
specific extension when that extension doesn’t implement the operator.</p>

<h4 id="example-360">Example</h4>

<p>The following code produces this diagnostic because the extension <code class="language-plaintext highlighter-rouge">E</code>
doesn’t define the operator <code class="language-plaintext highlighter-rouge">*</code>:</p>

<pre class="prettyprint lang-dart"><code>var x = E('') <span class="highlight">*</span> 4;

extension E on String {}</code></pre>

<h4 id="common-fixes-400">Common fixes</h4>

<p>If the extension is expected to implement the operator, then add an
implementation of the operator to the extension:</p>

<pre class="prettyprint lang-dart"><code>var x = E('') * 4;

extension E on String {
  int operator *(int multiplier) =&gt; length * multiplier;
}</code></pre>

<p>If the operator is defined by a different extension, then change the name
of the extension to the name of the one that defines the operator.</p>

<p>If the operator is defined on the argument of the extension override, then
remove the extension override:</p>

<pre class="prettyprint lang-dart"><code>var x = '' * 4;

extension E on String {}</code></pre>

<h3 id="undefined_extension_setter">
<a class="anchor" href="#undefined_extension_setter" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_extension_setter</h3>

<p><em>The setter ‘{0}’ isn’t defined for the extension ‘{1}’.</em></p>

<h4 id="description-401">Description</h4>

<p>The analyzer produces this diagnostic when an extension override is used to
invoke a setter, but the setter isn’t defined by the specified extension.
The analyzer also produces this diagnostic when a static setter is
referenced but isn’t defined by the specified extension.</p>

<h4 id="examples-39">Examples</h4>

<p>The following code produces this diagnostic because the extension <code class="language-plaintext highlighter-rouge">E</code>
doesn’t declare an instance setter named <code class="language-plaintext highlighter-rouge">b</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  set a(String v) {}
}

extension F on String {
  set b(String v) {}
}

void f() {
  E('c').<span class="highlight">b</span> = 'd';
}</code></pre>

<p>The following code produces this diagnostic because the extension <code class="language-plaintext highlighter-rouge">E</code>
doesn’t declare a static setter named <code class="language-plaintext highlighter-rouge">a</code>:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {}

void f() {
  E.<span class="highlight">a</span> = 3;
}</code></pre>

<h4 id="common-fixes-401">Common fixes</h4>

<p>If the name of the setter is incorrect, then change it to the name of an
existing setter:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  set a(String v) {}
}

extension F on String {
  set b(String v) {}
}

void f() {
  E('c').a = 'd';
}</code></pre>

<p>If the name of the setter is correct, but the name of the extension is
wrong, then change the name of the extension to the correct name:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  set a(String v) {}
}

extension F on String {
  set b(String v) {}
}

void f() {
  F('c').b = 'd';
}</code></pre>

<p>If the name of the setter and extension are both correct, but the setter
isn’t defined, then define the setter:</p>

<pre class="prettyprint lang-dart"><code>extension E on String {
  set a(String v) {}
  set b(String v) {}
}

extension F on String {
  set b(String v) {}
}

void f() {
  E('c').b = 'd';
}</code></pre>

<h3 id="undefined_function">
<a class="anchor" href="#undefined_function" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_function</h3>

<p><em>The function ‘{0}’ isn’t defined.</em></p>

<h4 id="description-402">Description</h4>

<p>The analyzer produces this diagnostic when it encounters an identifier that
appears to be the name of a function but either isn’t defined or isn’t
visible in the scope in which it’s being referenced.</p>

<h4 id="example-361">Example</h4>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">emty</code> isn’t
defined:</p>

<pre class="prettyprint lang-dart"><code>List&lt;int&gt; empty() =&gt; [];

void main() {
  print(<span class="highlight">emty</span>());
}</code></pre>

<h4 id="common-fixes-402">Common fixes</h4>

<p>If the identifier isn’t defined, then either define it or replace it with
the name of a function that is defined. The example above can be corrected
by fixing the spelling of the function:</p>

<pre class="prettyprint lang-dart"><code>List&lt;int&gt; empty() =&gt; [];

void main() {
  print(empty());
}</code></pre>

<p>If the function is defined but isn’t visible, then you probably need to add
an import or re-arrange your code to make the function visible.</p>

<h3 id="undefined_getter">
<a class="anchor" href="#undefined_getter" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_getter</h3>

<p><em>The getter ‘{0}’ isn’t defined for the ‘{1}’ function type.</em></p>

<p><em>The getter ‘{0}’ isn’t defined for the type ‘{1}’.</em></p>

<h4 id="description-403">Description</h4>

<p>The analyzer produces this diagnostic when it encounters an identifier that
appears to be the name of a getter but either isn’t defined or isn’t
visible in the scope in which it’s being referenced.</p>

<h4 id="example-362">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">String</code> has no member
named <code class="language-plaintext highlighter-rouge">len</code>:</p>

<pre class="prettyprint lang-dart"><code>int f(String s) =&gt; s.<span class="highlight">len</span>;</code></pre>

<h4 id="common-fixes-403">Common fixes</h4>

<p>If the identifier isn’t defined, then either define it or replace it with
the name of a getter that is defined. The example above can be corrected by
fixing the spelling of the getter:</p>

<pre class="prettyprint lang-dart"><code>int f(String s) =&gt; s.length;</code></pre>

<h3 id="undefined_hidden_name">
<a class="anchor" href="#undefined_hidden_name" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_hidden_name</h3>

<p><em>The library ‘{0}’ doesn’t export a member with the hidden name ‘{1}’.</em></p>

<h4 id="description-404">Description</h4>

<p>The analyzer produces this diagnostic when a hide combinator includes a
name that isn’t defined by the library being imported.</p>

<h4 id="example-363">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">dart:math</code> doesn’t
define the name <code class="language-plaintext highlighter-rouge">String</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' hide <span class="highlight">String</span>, max;

var x = min(0, 1);</code></pre>

<h4 id="common-fixes-404">Common fixes</h4>

<p>If a different name should be hidden, then correct the name. Otherwise,
remove the name from the list:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' hide max;

var x = min(0, 1);</code></pre>

<h3 id="undefined_identifier">
<a class="anchor" href="#undefined_identifier" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_identifier</h3>

<p><em>Undefined name ‘{0}’.</em></p>

<h4 id="description-405">Description</h4>

<p>The analyzer produces this diagnostic when it encounters an identifier that
either isn’t defined or isn’t visible in the scope in which it’s being
referenced.</p>

<h4 id="example-364">Example</h4>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">rihgt</code> isn’t
defined:</p>

<pre class="prettyprint lang-dart"><code>int min(int left, int right) =&gt; left &lt;= <span class="highlight">rihgt</span> ? left : right;</code></pre>

<h4 id="common-fixes-405">Common fixes</h4>

<p>If the identifier isn’t defined, then either define it or replace it with
an identifier that is defined. The example above can be corrected by
fixing the spelling of the variable:</p>

<pre class="prettyprint lang-dart"><code>int min(int left, int right) =&gt; left &lt;= right ? left : right;</code></pre>

<p>If the identifier is defined but isn’t visible, then you probably need to
add an import or re-arrange your code to make the identifier visible.</p>

<h3 id="undefined_identifier_await">
<a class="anchor" href="#undefined_identifier_await" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_identifier_await</h3>

<p><em>Undefined name ‘await’ in function body not marked with ‘async’.</em></p>

<h4 id="description-406">Description</h4>

<p>The analyzer produces this diagnostic when the name <code class="language-plaintext highlighter-rouge">await</code> is used in a
method or function body without being declared, and the body isn’t marked
with the <code class="language-plaintext highlighter-rouge">async</code> keyword. The name <code class="language-plaintext highlighter-rouge">await</code> only introduces an await
expression in an asynchronous function.</p>

<h4 id="example-365">Example</h4>

<p>The following code produces this diagnostic because the name <code class="language-plaintext highlighter-rouge">await</code> is
used in the body of <code class="language-plaintext highlighter-rouge">f</code> even though the body of <code class="language-plaintext highlighter-rouge">f</code> isn’t marked with the
<code class="language-plaintext highlighter-rouge">async</code> keyword:</p>

<pre class="prettyprint lang-dart"><code>void f(p) { <span class="highlight">await</span> p; }</code></pre>

<h4 id="common-fixes-406">Common fixes</h4>

<p>Add the keyword <code class="language-plaintext highlighter-rouge">async</code> to the function body:</p>

<pre class="prettyprint lang-dart"><code>void f(p) async { await p; }</code></pre>

<h3 id="undefined_method">
<a class="anchor" href="#undefined_method" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_method</h3>

<p><em>The method ‘{0}’ isn’t defined for the ‘{1}’ function type.</em></p>

<p><em>The method ‘{0}’ isn’t defined for the type ‘{1}’.</em></p>

<h4 id="description-407">Description</h4>

<p>The analyzer produces this diagnostic when it encounters an identifier that
appears to be the name of a method but either isn’t defined or isn’t
visible in the scope in which it’s being referenced.</p>

<h4 id="example-366">Example</h4>

<p>The following code produces this diagnostic because the identifier
<code class="language-plaintext highlighter-rouge">removeMiddle</code> isn’t defined:</p>

<pre class="prettyprint lang-dart"><code>int f(List&lt;int&gt; l) =&gt; l.<span class="highlight">removeMiddle</span>();</code></pre>

<h4 id="common-fixes-407">Common fixes</h4>

<p>If the identifier isn’t defined, then either define it or replace it with
the name of a method that is defined. The example above can be corrected by
fixing the spelling of the method:</p>

<pre class="prettyprint lang-dart"><code>int f(List&lt;int&gt; l) =&gt; l.removeLast();</code></pre>

<h3 id="undefined_named_parameter">
<a class="anchor" href="#undefined_named_parameter" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_named_parameter</h3>

<p><em>The named parameter ‘{0}’ isn’t defined.</em></p>

<h4 id="description-408">Description</h4>

<p>The analyzer produces this diagnostic when a method or function invocation
has a named argument, but the method or function being invoked doesn’t
define a parameter with the same name.</p>

<h4 id="example-367">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">m</code> doesn’t declare a
named parameter named <code class="language-plaintext highlighter-rouge">a</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  m({int b}) {}
}

void f(C c) {
  c.m(<span class="highlight">a</span>: 1);
}</code></pre>

<h4 id="common-fixes-408">Common fixes</h4>

<p>If the argument name is mistyped, then replace it with the correct name.
The example above can be fixed by changing <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">b</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  m({int b}) {}
}

void f(C c) {
  c.m(b: 1);
}</code></pre>

<p>If a subclass adds a parameter with the name in question, then cast the
receiver to the subclass:</p>

<pre class="prettyprint lang-dart"><code>class C {
  m({int b}) {}
}

class D extends C {
  m({int a, int b}) {}
}

void f(C c) {
  (c as D).m(a: 1);
}</code></pre>

<p>If the parameter should be added to the function, then add it:</p>

<pre class="prettyprint lang-dart"><code>class C {
  m({int a, int b}) {}
}

void f(C c) {
  c.m(a: 1);
}</code></pre>

<h3 id="undefined_operator">
<a class="anchor" href="#undefined_operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_operator</h3>

<p><em>The operator ‘{0}’ isn’t defined for the type ‘{1}’.</em></p>

<h4 id="description-409">Description</h4>

<p>The analyzer produces this diagnostic when a user-definable operator is
invoked on an object for which the operator isn’t defined.</p>

<h4 id="example-368">Example</h4>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">C</code> doesn’t
define the operator <code class="language-plaintext highlighter-rouge">+</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {}

C f(C c) =&gt; c <span class="highlight">+</span> 2;</code></pre>

<h4 id="common-fixes-409">Common fixes</h4>

<p>If the operator should be defined for the class, then define it:</p>

<pre class="prettyprint lang-dart"><code>class C {
  C operator +(int i) =&gt; this;
}

C f(C c) =&gt; c + 2;</code></pre>

<h3 id="undefined_prefixed_name">
<a class="anchor" href="#undefined_prefixed_name" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_prefixed_name</h3>

<p><em>The name ‘{0}’ is being referenced through the prefix ‘{1}’, but it isn’t
defined in any of the libraries imported using that prefix.</em></p>

<h4 id="description-410">Description</h4>

<p>The analyzer produces this diagnostic when a prefixed identifier is found
where the prefix is valid, but the identifier isn’t declared in any of the
libraries imported using that prefix.</p>

<h4 id="example-369">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">dart:core</code> doesn’t
define anything named <code class="language-plaintext highlighter-rouge">a</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:core' as p;

void f() {
  p.<span class="highlight">a</span>;
}</code></pre>

<h4 id="common-fixes-410">Common fixes</h4>

<p>If the library in which the name is declared isn’t imported yet, add an
import for the library.</p>

<p>If the name is wrong, then change it to one of the names that’s declared in
the imported libraries.</p>

<h3 id="undefined_referenced_parameter">
<a class="anchor" href="#undefined_referenced_parameter" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_referenced_parameter</h3>

<p><em>The parameter ‘{0}’ isn’t defined by ‘{1}’.</em></p>

<h4 id="description-411">Description</h4>

<p>The analyzer produces this diagnostic when an annotation of the form
<code class="language-plaintext highlighter-rouge">[UseResult][meta-UseResult].unless(parameterDefined: parameterName)</code>
specifies a parameter name that isn’t defined by the annotated function.</p>

<h4 id="example-370">Example</h4>

<p>The following code produces this diagnostic because the function <code class="language-plaintext highlighter-rouge">f</code>
doesn’t have a parameter named <code class="language-plaintext highlighter-rouge">b</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@UseResult.unless(parameterDefined: <span class="highlight">'b'</span>)
int f([int? a]) =&gt; a ?? 0;</code></pre>

<h4 id="common-fixes-411">Common fixes</h4>

<p>Change the argument named <code class="language-plaintext highlighter-rouge">parameterDefined</code> to match the name of one of
the parameters to the function:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

@UseResult.unless(parameterDefined: 'a')
int f([int? a]) =&gt; a ?? 0;</code></pre>

<h3 id="undefined_setter">
<a class="anchor" href="#undefined_setter" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_setter</h3>

<p><em>The setter ‘{0}’ isn’t defined for the ‘{1}’ function type.</em></p>

<p><em>The setter ‘{0}’ isn’t defined for the type ‘{1}’.</em></p>

<h4 id="description-412">Description</h4>

<p>The analyzer produces this diagnostic when it encounters an identifier that
appears to be the name of a setter but either isn’t defined or isn’t
visible in the scope in which the identifier is being referenced.</p>

<h4 id="example-371">Example</h4>

<p>The following code produces this diagnostic because there isn’t a setter
named <code class="language-plaintext highlighter-rouge">z</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x = 0;
  void m(int y) {
    this.<span class="highlight">z</span> = y;
  }
}</code></pre>

<h4 id="common-fixes-412">Common fixes</h4>

<p>If the identifier isn’t defined, then either define it or replace it with
the name of a setter that is defined. The example above can be corrected by
fixing the spelling of the setter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int x = 0;
  void m(int y) {
    this.x = y;
  }
}</code></pre>

<h3 id="undefined_shown_name">
<a class="anchor" href="#undefined_shown_name" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_shown_name</h3>

<p><em>The library ‘{0}’ doesn’t export a member with the shown name ‘{1}’.</em></p>

<h4 id="description-413">Description</h4>

<p>The analyzer produces this diagnostic when a show combinator includes a
name that isn’t defined by the library being imported.</p>

<h4 id="example-372">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">dart:math</code> doesn’t
define the name <code class="language-plaintext highlighter-rouge">String</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' show min, <span class="highlight">String</span>;

var x = min(0, 1);</code></pre>

<h4 id="common-fixes-413">Common fixes</h4>

<p>If a different name should be shown, then correct the name. Otherwise,
remove the name from the list:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' show min;

var x = min(0, 1);</code></pre>

<h3 id="undefined_super_member">
<a class="anchor" href="#undefined_super_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>undefined_super_member</h3>

<p><a id="undefined_super_method" aria-hidden="true"></a><em>(Previously known as <code class="language-plaintext highlighter-rouge">undefined_super_method</code>)</em></p>

<p><em>The getter ‘{0}’ isn’t defined in a superclass of ‘{1}’.</em></p>

<p><em>The method ‘{0}’ isn’t defined in a superclass of ‘{1}’.</em></p>

<p><em>The operator ‘{0}’ isn’t defined in a superclass of ‘{1}’.</em></p>

<p><em>The setter ‘{0}’ isn’t defined in a superclass of ‘{1}’.</em></p>

<h4 id="description-414">Description</h4>

<p>The analyzer produces this diagnostic when an inherited member (method,
getter, setter, or operator) is referenced using <code class="language-plaintext highlighter-rouge">super</code>, but there’s no
member with that name in the superclass chain.</p>

<h4 id="examples-40">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">Object</code> doesn’t define
a method named <code class="language-plaintext highlighter-rouge">n</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void m() {
    super.<span class="highlight">n</span>();
  }
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">Object</code> doesn’t define
a getter named <code class="language-plaintext highlighter-rouge">g</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void m() {
    super.<span class="highlight">g</span>;
  }
}</code></pre>

<h4 id="common-fixes-414">Common fixes</h4>

<p>If the inherited member you intend to invoke has a different name, then
make the name of the invoked member match the inherited member.</p>

<p>If the member you intend to invoke is defined in the same class, then
remove the <code class="language-plaintext highlighter-rouge">super.</code>.</p>

<p>If the member isn’t defined, then either add the member to one of the
superclasses or remove the invocation.</p>

<h3 id="unnecessary_cast">
<a class="anchor" href="#unnecessary_cast" aria-hidden="true"><span class="octicon octicon-link"></span></a>unnecessary_cast</h3>

<p><em>Unnecessary cast.</em></p>

<h4 id="description-415">Description</h4>

<p>The analyzer produces this diagnostic when the value being cast is already
known to be of the type that it’s being cast to.</p>

<h4 id="example-373">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">n</code> is already known to
be an <code class="language-plaintext highlighter-rouge">int</code> as a result of the <code class="language-plaintext highlighter-rouge">is</code> test:</p>

<pre class="prettyprint lang-dart"><code>void f(num n) {
  if (n is int) {
    (<span class="highlight">n as int</span>).isEven;
  }
}</code></pre>

<h4 id="common-fixes-415">Common fixes</h4>

<p>Remove the unnecessary cast:</p>

<pre class="prettyprint lang-dart"><code>void f(num n) {
  if (n is int) {
    n.isEven;
  }
}</code></pre>

<h3 id="unnecessary_dev_dependency">
<a class="anchor" href="#unnecessary_dev_dependency" aria-hidden="true"><span class="octicon octicon-link"></span></a>unnecessary_dev_dependency</h3>

<p><em>The dev dependency on {0} is unnecessary because there is also a normal
dependency on that package.</em></p>

<h4 id="description-416">Description</h4>

<p>The analyzer produces this diagnostic when there’s an entry under
<code class="language-plaintext highlighter-rouge">dev_dependencies</code> for a package that is also listed under <code class="language-plaintext highlighter-rouge">dependencies</code>.
The packages under <code class="language-plaintext highlighter-rouge">dependencies</code> are available to all of the code in the
package, so there’s no need to also list them under <code class="language-plaintext highlighter-rouge">dev_dependencies</code>.</p>

<h4 id="example-374">Example</h4>

<p>The following code produces this diagnostic because the package <code class="language-plaintext highlighter-rouge">meta</code> is
listed under both <code class="language-plaintext highlighter-rouge">dependencies</code> and <code class="language-plaintext highlighter-rouge">dev_dependencies</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">meta</span><span class="pi">:</span> <span class="s">^1.0.2</span>
<span class="na">dev_dependencies</span><span class="pi">:</span>
  <span class="na">meta</span><span class="pi">:</span> <span class="s">^1.0.2</span>
</code></pre></div></div>

<h4 id="common-fixes-416">Common fixes</h4>

<p>Remove the entry under <code class="language-plaintext highlighter-rouge">dev_dependencies</code> (and the <code class="language-plaintext highlighter-rouge">dev_dependencies</code> key
if that’s the only package listed there):</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">example</span>
<span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">meta</span><span class="pi">:</span> <span class="s">^1.0.2</span>
</code></pre></div></div>

<h3 id="unnecessary_final">
<a class="anchor" href="#unnecessary_final" aria-hidden="true"><span class="octicon octicon-link"></span></a>unnecessary_final</h3>

<p><em>The keyword ‘final’ isn’t necessary because the parameter is implicitly
‘final’.</em></p>

<h4 id="description-417">Description</h4>

<p>The analyzer produces this diagnostic when either a field initializing
parameter or a super parameter in a constructor has the keyword <code class="language-plaintext highlighter-rouge">final</code>.
In both cases the keyword is unnecessary because the parameter is
implicitly <code class="language-plaintext highlighter-rouge">final</code>.</p>

<h4 id="examples-41">Examples</h4>

<p>The following code produces this diagnostic because the field initializing
parameter has the keyword <code class="language-plaintext highlighter-rouge">final</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  int value;

  A(<span class="highlight">final</span> this.value);
}</code></pre>

<p>The following code produces this diagnostic because the super parameter in
<code class="language-plaintext highlighter-rouge">B</code> has the keyword <code class="language-plaintext highlighter-rouge">final</code>:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int value);
}

class B extends A {
  B(<span class="highlight">final</span> super.value);
}</code></pre>

<h4 id="common-fixes-417">Common fixes</h4>

<p>Remove the unnecessary <code class="language-plaintext highlighter-rouge">final</code> keyword:</p>

<pre class="prettyprint lang-dart"><code>class A {
  A(int value);
}

class B extends A {
  B(super.value);
}</code></pre>

<h3 id="unnecessary_import">
<a class="anchor" href="#unnecessary_import" aria-hidden="true"><span class="octicon octicon-link"></span></a>unnecessary_import</h3>

<p><em>The import of ‘{0}’ is unnecessary because all of the used elements are also
provided by the import of ‘{1}’.</em></p>

<h4 id="description-418">Description</h4>

<p>The analyzer produces this diagnostic when an import isn’t needed because
all of the names that are imported and referenced within the importing
library are also visible through another import.</p>

<h4 id="example-375">Example</h4>

<p>Given a file named <code class="language-plaintext highlighter-rouge">a.dart</code> that contains the following:</p>

<pre class="prettyprint lang-dart"><code>class A {}</code></pre>

<p>And, given a file named <code class="language-plaintext highlighter-rouge">b.dart</code> that contains the following:</p>

<pre class="prettyprint lang-dart"><code>export 'a.dart';

class B {}</code></pre>

<p>The following code produces this diagnostic because the class <code class="language-plaintext highlighter-rouge">A</code>, which is
imported from <code class="language-plaintext highlighter-rouge">a.dart</code>, is also imported from <code class="language-plaintext highlighter-rouge">b.dart</code>. Removing the import
of <code class="language-plaintext highlighter-rouge">a.dart</code> leaves the semantics unchanged:</p>

<pre class="prettyprint lang-dart"><code>import <span class="highlight">'a.dart'</span>;
import 'b.dart';

void f(A a, B b) {}</code></pre>

<h4 id="common-fixes-418">Common fixes</h4>

<p>If the import isn’t needed, then remove it.</p>

<p>If some of the names imported by this import are intended to be used but
aren’t yet, and if those names aren’t imported by other imports, then add
the missing references to those names.</p>

<h3 id="unnecessary_non_null_assertion">
<a class="anchor" href="#unnecessary_non_null_assertion" aria-hidden="true"><span class="octicon octicon-link"></span></a>unnecessary_non_null_assertion</h3>

<p><em>The ‘!’ will have no effect because the receiver can’t be null.</em></p>

<h4 id="description-419">Description</h4>

<p>The analyzer produces this diagnostic when the operand of the <code class="language-plaintext highlighter-rouge">!</code> operator
can’t be <code class="language-plaintext highlighter-rouge">null</code>.</p>

<h4 id="example-376">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> can’t be <code class="language-plaintext highlighter-rouge">null</code>:</p>

<pre class="prettyprint lang-dart"><code>int f(int x) {
  return x<span class="highlight">!</span>;
}</code></pre>

<h4 id="common-fixes-419">Common fixes</h4>

<p>Remove the null check operator (<code class="language-plaintext highlighter-rouge">!</code>):</p>

<pre class="prettyprint lang-dart"><code>int f(int x) {
  return x;
}</code></pre>

<h3 id="unnecessary_no_such_method">
<a class="anchor" href="#unnecessary_no_such_method" aria-hidden="true"><span class="octicon octicon-link"></span></a>unnecessary_no_such_method</h3>

<p><em>Unnecessary ‘noSuchMethod’ declaration.</em></p>

<h4 id="description-420">Description</h4>

<p>The analyzer produces this diagnostic when there’s a declaration of
<code class="language-plaintext highlighter-rouge">noSuchMethod</code>, the only thing the declaration does is invoke the
overridden declaration, and the overridden declaration isn’t the
declaration in <code class="language-plaintext highlighter-rouge">Object</code>.</p>

<p>Overriding the implementation of <code class="language-plaintext highlighter-rouge">Object</code>’s <code class="language-plaintext highlighter-rouge">noSuchMethod</code> (no matter what
the implementation does) signals to the analyzer that it shouldn’t flag any
inherited abstract methods that aren’t implemented in that class. This
works even if the overriding implementation is inherited from a superclass,
so there’s no value to declare it again in a subclass.</p>

<h4 id="example-377">Example</h4>

<p>The following code produces this diagnostic because the declaration of
<code class="language-plaintext highlighter-rouge">noSuchMethod</code> in <code class="language-plaintext highlighter-rouge">A</code> makes the declaration of <code class="language-plaintext highlighter-rouge">noSuchMethod</code> in <code class="language-plaintext highlighter-rouge">B</code>
unnecessary:</p>

<pre class="prettyprint lang-dart"><code>class A {
  @override
  dynamic noSuchMethod(x) =&gt; super.noSuchMethod(x);
}
class B extends A {
  @override
  dynamic <span class="highlight">noSuchMethod</span>(y) {
    return super.noSuchMethod(y);
  }
}</code></pre>

<h4 id="common-fixes-420">Common fixes</h4>

<p>Remove the unnecessary declaration:</p>

<pre class="prettyprint lang-dart"><code>class A {
  @override
  dynamic noSuchMethod(x) =&gt; super.noSuchMethod(x);
}
class B extends A {}</code></pre>

<h3 id="unnecessary_null_comparison">
<a class="anchor" href="#unnecessary_null_comparison" aria-hidden="true"><span class="octicon octicon-link"></span></a>unnecessary_null_comparison</h3>

<p><em>The operand can’t be null, so the condition is always false.</em></p>

<p><em>The operand can’t be null, so the condition is always true.</em></p>

<h4 id="description-421">Description</h4>

<p>The analyzer produces this diagnostic when it finds an equality comparison
(either <code class="language-plaintext highlighter-rouge">==</code> or <code class="language-plaintext highlighter-rouge">!=</code>) with one operand of <code class="language-plaintext highlighter-rouge">null</code> and the other operand
can’t be <code class="language-plaintext highlighter-rouge">null</code>. Such comparisons are always either <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>, so
they serve no purpose.</p>

<h4 id="examples-42">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> can never be
<code class="language-plaintext highlighter-rouge">null</code>, so the comparison always evaluates to <code class="language-plaintext highlighter-rouge">true</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(int x) {
  if (x <span class="highlight">!= null</span>) {
    print(x);
  }
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">x</code> can never be
<code class="language-plaintext highlighter-rouge">null</code>, so the comparison always evaluates to <code class="language-plaintext highlighter-rouge">false</code>:</p>

<pre class="prettyprint lang-dart"><code>void f(int x) {
  if (x <span class="highlight">== null</span>) {
    throw ArgumentError("x can't be null");
  }
}</code></pre>

<h4 id="common-fixes-421">Common fixes</h4>

<p>If the other operand should be able to be <code class="language-plaintext highlighter-rouge">null</code>, then change the type of
the operand:</p>

<pre class="prettyprint lang-dart"><code>void f(int? x) {
  if (x != null) {
    print(x);
  }
}</code></pre>

<p>If the other operand really can’t be <code class="language-plaintext highlighter-rouge">null</code>, then remove the condition:</p>

<pre class="prettyprint lang-dart"><code>void f(int x) {
  print(x);
}</code></pre>

<h3 id="unnecessary_question_mark">
<a class="anchor" href="#unnecessary_question_mark" aria-hidden="true"><span class="octicon octicon-link"></span></a>unnecessary_question_mark</h3>

<p><em>The ‘?’ is unnecessary because ‘{0}’ is nullable without it.</em></p>

<h4 id="description-422">Description</h4>

<p>The analyzer produces this diagnostic when either the type <code class="language-plaintext highlighter-rouge">dynamic</code> or the
type <code class="language-plaintext highlighter-rouge">Null</code> is followed by a question mark. Both of these types are
inherently nullable so the question mark doesn’t change the semantics.</p>

<h4 id="example-378">Example</h4>

<p>The following code produces this diagnostic because the question mark
following <code class="language-plaintext highlighter-rouge">dynamic</code> isn’t necessary:</p>

<pre class="prettyprint lang-dart"><code>dynamic<span class="highlight">?</span> x;</code></pre>

<h4 id="common-fixes-422">Common fixes</h4>

<p>Remove the unneeded question mark:</p>

<pre class="prettyprint lang-dart"><code>dynamic x;</code></pre>

<h3 id="unnecessary_type_check">
<a class="anchor" href="#unnecessary_type_check" aria-hidden="true"><span class="octicon octicon-link"></span></a>unnecessary_type_check</h3>

<p><em>Unnecessary type check; the result is always ‘false’.</em></p>

<p><em>Unnecessary type check; the result is always ‘true’.</em></p>

<h4 id="description-423">Description</h4>

<p>The analyzer produces this diagnostic when the value of a type check (using
either <code class="language-plaintext highlighter-rouge">is</code> or <code class="language-plaintext highlighter-rouge">is!</code>) is known at compile time.</p>

<h4 id="example-379">Example</h4>

<p>The following code produces this diagnostic because the test <code class="language-plaintext highlighter-rouge">a is Object?</code>
is always <code class="language-plaintext highlighter-rouge">true</code>:</p>

<pre class="prettyprint lang-dart"><code>bool f&lt;T&gt;(T a) =&gt; <span class="highlight">a is Object?</span>;</code></pre>

<h4 id="common-fixes-423">Common fixes</h4>

<p>If the type check doesn’t check what you intended to check, then change the
test:</p>

<pre class="prettyprint lang-dart"><code>bool f&lt;T&gt;(T a) =&gt; a is Object;</code></pre>

<p>If the type check does check what you intended to check, then replace the
type check with its known value or completely remove it:</p>

<pre class="prettyprint lang-dart"><code>bool f&lt;T&gt;(T a) =&gt; true;</code></pre>

<h3 id="unqualified_reference_to_non_local_static_member">
<a class="anchor" href="#unqualified_reference_to_non_local_static_member" aria-hidden="true"><span class="octicon octicon-link"></span></a>unqualified_reference_to_non_local_static_member</h3>

<p><em>Static members from supertypes must be qualified by the name of the defining
type.</em></p>

<h4 id="description-424">Description</h4>

<p>The analyzer produces this diagnostic when code in one class references a
static member in a superclass without prefixing the member’s name with the
name of the superclass. Static members can only be referenced without a
prefix in the class in which they’re declared.</p>

<h4 id="example-380">Example</h4>

<p>The following code produces this diagnostic because the static field <code class="language-plaintext highlighter-rouge">x</code> is
referenced in the getter <code class="language-plaintext highlighter-rouge">g</code> without prefixing it with the name of the
defining class:</p>

<pre class="prettyprint lang-dart"><code>class A {
  static int x = 3;
}

class B extends A {
  int get g =&gt; <span class="highlight">x</span>;
}</code></pre>

<h4 id="common-fixes-424">Common fixes</h4>

<p>Prefix the name of the static member with the name of the declaring class:</p>

<pre class="prettyprint lang-dart"><code>class A {
  static int x = 3;
}

class B extends A {
  int get g =&gt; A.x;
}</code></pre>

<h3 id="unqualified_reference_to_static_member_of_extended_type">
<a class="anchor" href="#unqualified_reference_to_static_member_of_extended_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>unqualified_reference_to_static_member_of_extended_type</h3>

<p><em>Static members from the extended type or one of its superclasses must be
qualified by the name of the defining type.</em></p>

<h4 id="description-425">Description</h4>

<p>The analyzer produces this diagnostic when an undefined name is found, and
the name is the same as a static member of the extended type or one of its
superclasses.</p>

<h4 id="example-381">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">m</code> is a static member
of the extended type <code class="language-plaintext highlighter-rouge">C</code>:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static void m() {}
}

extension E on C {
  void f() {
    <span class="highlight">m</span>();
  }
}</code></pre>

<h4 id="common-fixes-425">Common fixes</h4>

<p>If you’re trying to reference a static member that’s declared outside the
extension, then add the name of the class or extension before the reference
to the member:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static void m() {}
}

extension E on C {
  void f() {
    C.m();
  }
}</code></pre>

<p>If you’re referencing a member that isn’t declared yet, add a declaration:</p>

<pre class="prettyprint lang-dart"><code>class C {
  static void m() {}
}

extension E on C {
  void f() {
    m();
  }

  void m() {}
}</code></pre>

<h3 id="unused_catch_clause">
<a class="anchor" href="#unused_catch_clause" aria-hidden="true"><span class="octicon octicon-link"></span></a>unused_catch_clause</h3>

<p><em>The exception variable ‘{0}’ isn’t used, so the ‘catch’ clause can be removed.</em></p>

<h4 id="description-426">Description</h4>

<p>The analyzer produces this diagnostic when a <code class="language-plaintext highlighter-rouge">catch</code> clause is found, and
neither the exception parameter nor the optional stack trace parameter are
used in the <code class="language-plaintext highlighter-rouge">catch</code> block.</p>

<h4 id="example-382">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">e</code> isn’t referenced:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
    int.parse(';');
  } on FormatException catch (<span class="highlight">e</span>) {
    // ignored
  }
}</code></pre>

<h4 id="common-fixes-426">Common fixes</h4>

<p>Remove the unused <code class="language-plaintext highlighter-rouge">catch</code> clause:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
    int.parse(';');
  } on FormatException {
    // ignored
  }
}</code></pre>

<h3 id="unused_catch_stack">
<a class="anchor" href="#unused_catch_stack" aria-hidden="true"><span class="octicon octicon-link"></span></a>unused_catch_stack</h3>

<p><em>The stack trace variable ‘{0}’ isn’t used and can be removed.</em></p>

<h4 id="description-427">Description</h4>

<p>The analyzer produces this diagnostic when the stack trace parameter in a
<code class="language-plaintext highlighter-rouge">catch</code> clause isn’t referenced within the body of the <code class="language-plaintext highlighter-rouge">catch</code> block.</p>

<h4 id="example-383">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">stackTrace</code> isn’t
referenced:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
    // ...
  } catch (exception, <span class="highlight">stackTrace</span>) {
    // ...
  }
}</code></pre>

<h4 id="common-fixes-427">Common fixes</h4>

<p>If you need to reference the stack trace parameter, then add a reference to
it. Otherwise, remove it:</p>

<pre class="prettyprint lang-dart"><code>void f() {
  try {
    // ...
  } catch (exception) {
    // ...
  }
}</code></pre>

<h3 id="unused_element">
<a class="anchor" href="#unused_element" aria-hidden="true"><span class="octicon octicon-link"></span></a>unused_element</h3>

<p><em>A value for optional parameter ‘{0}’ isn’t ever given.</em></p>

<p><em>The declaration ‘{0}’ isn’t referenced.</em></p>

<h4 id="description-428">Description</h4>

<p>The analyzer produces this diagnostic when a private declaration isn’t
referenced in the library that contains the declaration. The following
kinds of declarations are analyzed:</p>
<ul>
  <li>Private top-level declarations, such as classes, enums, mixins, typedefs,
top-level variables, and top-level functions</li>
  <li>Private static and instance methods</li>
  <li>Optional parameters of private functions for which a value is never
passed, even when the parameter doesn’t have a private name</li>
</ul>

<h4 id="example-384">Example</h4>

<p>Assuming that no code in the library references <code class="language-plaintext highlighter-rouge">_C</code>, the following code
produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>class <span class="highlight">_C</span> {}</code></pre>

<p>Assuming that no code in the library passes a value for <code class="language-plaintext highlighter-rouge">y</code> in any
invocation of <code class="language-plaintext highlighter-rouge">_m</code>, the following code produces this diagnostic:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void _m(int x, [int <span class="highlight">y</span>]) {}

  void n() =&gt; _m(0);
}</code></pre>

<h4 id="common-fixes-428">Common fixes</h4>

<p>If the declaration isn’t needed, then remove it:</p>

<pre class="prettyprint lang-dart"><code>class C {
  void _m(int x) {}

  void n() =&gt; _m(0);
}</code></pre>

<p>If the declaration is intended to be used, then add the code to use it.</p>

<h3 id="unused_field">
<a class="anchor" href="#unused_field" aria-hidden="true"><span class="octicon octicon-link"></span></a>unused_field</h3>

<p><em>The value of the field ‘{0}’ isn’t used.</em></p>

<h4 id="description-429">Description</h4>

<p>The analyzer produces this diagnostic when a private field is declared but
never read, even if it’s written in one or more places.</p>

<h4 id="example-385">Example</h4>

<p>The following code produces this diagnostic because the field
<code class="language-plaintext highlighter-rouge">_originalValue</code> isn’t read anywhere in the library:</p>

<pre class="prettyprint lang-dart"><code>class C {
  final String <span class="highlight">_originalValue</span>;
  final String _currentValue;

  C(this._originalValue) : _currentValue = _originalValue;

  String get value =&gt; _currentValue;
}</code></pre>

<p>It might appear that the field <code class="language-plaintext highlighter-rouge">_originalValue</code> is being read in the
initializer (<code class="language-plaintext highlighter-rouge">_currentValue = _originalValue</code>), but that is actually a
reference to the parameter of the same name, not a reference to the field.</p>

<h4 id="common-fixes-429">Common fixes</h4>

<p>If the field isn’t needed, then remove it.</p>

<p>If the field was intended to be used, then add the missing code.</p>

<h3 id="unused_import">
<a class="anchor" href="#unused_import" aria-hidden="true"><span class="octicon octicon-link"></span></a>unused_import</h3>

<p><em>Unused import: ‘{0}’.</em></p>

<h4 id="description-430">Description</h4>

<p>The analyzer produces this diagnostic when an import isn’t needed because
none of the names that are imported are referenced within the importing
library.</p>

<h4 id="example-386">Example</h4>

<p>The following code produces this diagnostic because nothing defined in
<code class="language-plaintext highlighter-rouge">dart:async</code> is referenced in the library:</p>

<pre class="prettyprint lang-dart"><code>import <span class="highlight">'dart:async'</span>;

void main() {}</code></pre>

<h4 id="common-fixes-430">Common fixes</h4>

<p>If the import isn’t needed, then remove it.</p>

<p>If some of the imported names are intended to be used, then add the missing
code.</p>

<h3 id="unused_label">
<a class="anchor" href="#unused_label" aria-hidden="true"><span class="octicon octicon-link"></span></a>unused_label</h3>

<p><em>The label ‘{0}’ isn’t used.</em></p>

<h4 id="description-431">Description</h4>

<p>The analyzer produces this diagnostic when a label that isn’t used is
found.</p>

<h4 id="example-387">Example</h4>

<p>The following code produces this diagnostic because the label <code class="language-plaintext highlighter-rouge">loop</code> isn’t
referenced anywhere in the method:</p>

<pre class="prettyprint lang-dart"><code>void f(int limit) {
  <span class="highlight">loop:</span> for (int i = 0; i &lt; limit; i++) {
    print(i);
  }
}</code></pre>

<h4 id="common-fixes-431">Common fixes</h4>

<p>If the label isn’t needed, then remove it:</p>

<pre class="prettyprint lang-dart"><code>void f(int limit) {
  for (int i = 0; i &lt; limit; i++) {
    print(i);
  }
}</code></pre>

<p>If the label is needed, then use it:</p>

<pre class="prettyprint lang-dart"><code>void f(int limit) {
  loop: for (int i = 0; i &lt; limit; i++) {
    print(i);
    break loop;
  }
}</code></pre>

<h3 id="unused_local_variable">
<a class="anchor" href="#unused_local_variable" aria-hidden="true"><span class="octicon octicon-link"></span></a>unused_local_variable</h3>

<p><em>The value of the local variable ‘{0}’ isn’t used.</em></p>

<h4 id="description-432">Description</h4>

<p>The analyzer produces this diagnostic when a local variable is declared but
never read, even if it’s written in one or more places.</p>

<h4 id="example-388">Example</h4>

<p>The following code produces this diagnostic because the value of <code class="language-plaintext highlighter-rouge">count</code> is
never read:</p>

<pre class="prettyprint lang-dart"><code>void main() {
  int <span class="highlight">count</span> = 0;
}</code></pre>

<h4 id="common-fixes-432">Common fixes</h4>

<p>If the variable isn’t needed, then remove it.</p>

<p>If the variable was intended to be used, then add the missing code.</p>

<h3 id="unused_result">
<a class="anchor" href="#unused_result" aria-hidden="true"><span class="octicon octicon-link"></span></a>unused_result</h3>

<p><em>‘{0}’ should be used. {1}.</em></p>

<p><em>The value of ‘{0}’ should be used.</em></p>

<h4 id="description-433">Description</h4>

<p>The analyzer produces this diagnostic when a function annotated with
<code class="language-plaintext highlighter-rouge">[useResult][meta-useResult]</code> is invoked, and the value returned by that
function isn’t used. The value is considered to be used if a member of the
value is invoked, if the value is passed to another function, or if the
value is assigned to a variable or field.</p>

<h4 id="example-389">Example</h4>

<p>The following code produces this diagnostic because the invocation of
<code class="language-plaintext highlighter-rouge">c.a()</code> isn’t used, even though the method <code class="language-plaintext highlighter-rouge">a</code> is annotated with
<code class="language-plaintext highlighter-rouge">[useResult][meta-useResult]</code>:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class C {
  @useResult
  int a() =&gt; 0;

  int b() =&gt; 0;
}

void f(C c) {
  c.<span class="highlight">a</span>();
}</code></pre>

<h4 id="common-fixes-433">Common fixes</h4>

<p>If you intended to invoke the annotated function, then use the value that
was returned:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class C {
  @useResult
  int a() =&gt; 0;

  int b() =&gt; 0;
}

void f(C c) {
  print(c.a());
}</code></pre>

<p>If you intended to invoke a different function, then correct the name of
the function being invoked:</p>

<pre class="prettyprint lang-dart"><code>import 'package:meta/meta.dart';

class C {
  @useResult
  int a() =&gt; 0;

  int b() =&gt; 0;
}

void f(C c) {
  c.b();
}</code></pre>

<h3 id="unused_shown_name">
<a class="anchor" href="#unused_shown_name" aria-hidden="true"><span class="octicon octicon-link"></span></a>unused_shown_name</h3>

<p><em>The name {0} is shown, but isn’t used.</em></p>

<h4 id="description-434">Description</h4>

<p>The analyzer produces this diagnostic when a show combinator includes a
name that isn’t used within the library. Because it isn’t referenced, the
name can be removed.</p>

<h4 id="example-390">Example</h4>

<p>The following code produces this diagnostic because the function <code class="language-plaintext highlighter-rouge">max</code>
isn’t used:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' show min, <span class="highlight">max</span>;

var x = min(0, 1);</code></pre>

<h4 id="common-fixes-434">Common fixes</h4>

<p>Either use the name or remove it:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math' show min;

var x = min(0, 1);</code></pre>

<h3 id="uri_does_not_exist">
<a class="anchor" href="#uri_does_not_exist" aria-hidden="true"><span class="octicon octicon-link"></span></a>uri_does_not_exist</h3>

<p><em>Target of URI doesn’t exist: ‘{0}’.</em></p>

<h4 id="description-435">Description</h4>

<p>The analyzer produces this diagnostic when an import, export, or part
directive is found where the URI refers to a file that doesn’t exist.</p>

<h4 id="example-391">Example</h4>

<p>If the file <code class="language-plaintext highlighter-rouge">lib.dart</code> doesn’t exist, the following code produces this
diagnostic:</p>

<pre class="prettyprint lang-dart"><code>import <span class="highlight">'lib.dart'</span>;</code></pre>

<h4 id="common-fixes-435">Common fixes</h4>

<p>If the URI was mistyped or invalid, then correct the URI.</p>

<p>If the URI is correct, then create the file.</p>

<h3 id="uri_has_not_been_generated">
<a class="anchor" href="#uri_has_not_been_generated" aria-hidden="true"><span class="octicon octicon-link"></span></a>uri_has_not_been_generated</h3>

<p><em>Target of URI hasn’t been generated: ‘{0}’.</em></p>

<h4 id="description-436">Description</h4>

<p>The analyzer produces this diagnostic when an import, export, or part
directive is found where the URI refers to a file that doesn’t exist and
the name of the file ends with a pattern that’s commonly produced by code
generators, such as one of the following:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.g.dart</code></li>
  <li><code class="language-plaintext highlighter-rouge">.pb.dart</code></li>
  <li><code class="language-plaintext highlighter-rouge">.pbenum.dart</code></li>
  <li><code class="language-plaintext highlighter-rouge">.pbserver.dart</code></li>
  <li><code class="language-plaintext highlighter-rouge">.pbjson.dart</code></li>
  <li><code class="language-plaintext highlighter-rouge">.template.dart</code></li>
</ul>

<h4 id="example-392">Example</h4>

<p>If the file <code class="language-plaintext highlighter-rouge">lib.g.dart</code> doesn’t exist, the following code produces this
diagnostic:</p>

<pre class="prettyprint lang-dart"><code>import <span class="highlight">'lib.g.dart'</span>;</code></pre>

<h4 id="common-fixes-436">Common fixes</h4>

<p>If the file is a generated file, then run the generator that generates the
file.</p>

<p>If the file isn’t a generated file, then check the spelling of the URI or
create the file.</p>

<h3 id="uri_with_interpolation">
<a class="anchor" href="#uri_with_interpolation" aria-hidden="true"><span class="octicon octicon-link"></span></a>uri_with_interpolation</h3>

<p><em>URIs can’t use string interpolation.</em></p>

<h4 id="description-437">Description</h4>

<p>The analyzer produces this diagnostic when the string literal in an
<code class="language-plaintext highlighter-rouge">import</code>, <code class="language-plaintext highlighter-rouge">export</code>, or <code class="language-plaintext highlighter-rouge">part</code> directive contains an interpolation. The
resolution of the URIs in directives must happen before the declarations
are compiled, so expressions can’t be  evaluated  while determining the
values of the URIs.</p>

<h4 id="example-393">Example</h4>

<p>The following code produces this diagnostic because the string in the
<code class="language-plaintext highlighter-rouge">import</code> directive contains an interpolation:</p>

<pre class="prettyprint lang-dart"><code>import <span class="highlight">'dart:$m'</span>;

const m = 'math';</code></pre>

<h4 id="common-fixes-437">Common fixes</h4>

<p>Remove the interpolation from the URI:</p>

<pre class="prettyprint lang-dart"><code>import 'dart:math';

var zero = min(0, 0);</code></pre>

<h3 id="use_of_native_extension">
<a class="anchor" href="#use_of_native_extension" aria-hidden="true"><span class="octicon octicon-link"></span></a>use_of_native_extension</h3>

<p><em>Dart native extensions are deprecated and aren’t available in Dart 2.15.</em></p>

<h4 id="description-438">Description</h4>

<p>The analyzer produces this diagnostic when a library is imported using the
<code class="language-plaintext highlighter-rouge">dart-ext</code> scheme.</p>

<h4 id="example-394">Example</h4>

<p>The following code produces this diagnostic because the native library <code class="language-plaintext highlighter-rouge">x</code>
is being imported using a scheme of <code class="language-plaintext highlighter-rouge">dart-ext</code>:</p>

<pre class="prettyprint lang-dart"><code>import <span class="highlight">'dart-ext:x'</span>;</code></pre>

<h4 id="common-fixes-438">Common fixes</h4>

<p>Rewrite the code to use <code class="language-plaintext highlighter-rouge">dart:ffi</code> as a way of invoking the contents of the
native library.</p>

<h3 id="use_of_void_result">
<a class="anchor" href="#use_of_void_result" aria-hidden="true"><span class="octicon octicon-link"></span></a>use_of_void_result</h3>

<p><em>This expression has a type of ‘void’ so its value can’t be used.</em></p>

<h4 id="description-439">Description</h4>

<p>The analyzer produces this diagnostic when it finds an expression whose
type is <code class="language-plaintext highlighter-rouge">void</code>, and the expression is used in a place where a value is
expected, such as before a member access or on the right-hand side of an
assignment.</p>

<h4 id="example-395">Example</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">f</code> doesn’t produce an
object on which <code class="language-plaintext highlighter-rouge">toString</code> can be invoked:</p>

<pre class="prettyprint lang-dart"><code>void f() {}

void g() {
  <span class="highlight">f()</span>.toString();
}</code></pre>

<h4 id="common-fixes-439">Common fixes</h4>

<p>Either rewrite the code so that the expression has a value or rewrite the
code so that it doesn’t depend on the value.</p>

<h3 id="values_declaration_in_enum">
<a class="anchor" href="#values_declaration_in_enum" aria-hidden="true"><span class="octicon octicon-link"></span></a>values_declaration_in_enum</h3>

<p><em>A member named ‘values’ can’t be declared in an enum.</em></p>

<h4 id="description-440">Description</h4>

<p>The analyzer produces this diagnostic when an enum declaration defines a
member named <code class="language-plaintext highlighter-rouge">values</code>, whether the member is an enum constant, an instance
member, or a static member.</p>

<p>Any such member conflicts with the implicit declaration of the static
getter named <code class="language-plaintext highlighter-rouge">values</code> that returns a list containing all the enum
constants.</p>

<h4 id="example-396">Example</h4>

<p>The following code produces this diagnostic because the enum <code class="language-plaintext highlighter-rouge">E</code> defines
an instance member named <code class="language-plaintext highlighter-rouge">values</code>:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  v;
  void <span class="highlight">values</span>() {}
}</code></pre>

<h4 id="common-fixes-440">Common fixes</h4>

<p>Change the name of the conflicting member:</p>

<pre class="prettyprint lang-dart"><code>enum E {
  v;
  void getValues() {}
}</code></pre>

<h3 id="variable_type_mismatch">
<a class="anchor" href="#variable_type_mismatch" aria-hidden="true"><span class="octicon octicon-link"></span></a>variable_type_mismatch</h3>

<p><em>A value of type ‘{0}’ can’t be assigned to a const variable of type ‘{1}’.</em></p>

<h4 id="description-441">Description</h4>

<p>The analyzer produces this diagnostic when the evaluation of a constant
expression would result in a <code class="language-plaintext highlighter-rouge">CastException</code>.</p>

<h4 id="example-397">Example</h4>

<p>The following code produces this diagnostic because the value of <code class="language-plaintext highlighter-rouge">x</code> is an
<code class="language-plaintext highlighter-rouge">int</code>, which can’t be assigned to <code class="language-plaintext highlighter-rouge">y</code> because an <code class="language-plaintext highlighter-rouge">int</code> isn’t a <code class="language-plaintext highlighter-rouge">String</code>:</p>

<pre class="prettyprint lang-dart"><code>const Object x = 0;
const String y = <span class="highlight">x</span>;</code></pre>

<h4 id="common-fixes-441">Common fixes</h4>

<p>If the declaration of the constant is correct, then change the value being
assigned to be of the correct type:</p>

<pre class="prettyprint lang-dart"><code>const Object x = 0;
const String y = '$x';</code></pre>

<p>If the assigned value is correct, then change the declaration to have the
correct type:</p>

<pre class="prettyprint lang-dart"><code>const Object x = 0;
const int y = x;</code></pre>

<h3 id="wrong_number_of_parameters_for_operator">
<a class="anchor" href="#wrong_number_of_parameters_for_operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>wrong_number_of_parameters_for_operator</h3>

<p><em>Operator ‘-‘ should declare 0 or 1 parameter, but {0} found.</em></p>

<p><em>Operator ‘{0}’ should declare exactly {1} parameters, but {2} found.</em></p>

<h4 id="description-442">Description</h4>

<p>The analyzer produces this diagnostic when a declaration of an operator has
the wrong number of parameters.</p>

<h4 id="example-398">Example</h4>

<p>The following code produces this diagnostic because the operator <code class="language-plaintext highlighter-rouge">+</code> must
have a single parameter corresponding to the right operand:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int operator <span class="highlight">+</span>(a, b) =&gt; 0;
}</code></pre>

<h4 id="common-fixes-442">Common fixes</h4>

<p>Add or remove parameters to match the required number:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int operator +(a) =&gt; 0;
}</code></pre>

<h3 id="wrong_number_of_parameters_for_setter">
<a class="anchor" href="#wrong_number_of_parameters_for_setter" aria-hidden="true"><span class="octicon octicon-link"></span></a>wrong_number_of_parameters_for_setter</h3>

<p><em>Setters must declare exactly one required positional parameter.</em></p>

<h4 id="description-443">Description</h4>

<p>The analyzer produces this diagnostic when a setter is found that doesn’t
declare exactly one required positional parameter.</p>

<h4 id="examples-43">Examples</h4>

<p>The following code produces this diagnostic because the setter <code class="language-plaintext highlighter-rouge">s</code> declares
two required parameters:</p>

<pre class="prettyprint lang-dart"><code>class C {
  set <span class="highlight">s</span>(int x, int y) {}
}</code></pre>

<p>The following code produces this diagnostic because the setter <code class="language-plaintext highlighter-rouge">s</code> declares
one optional parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  set <span class="highlight">s</span>([int x]) {}
}</code></pre>

<h4 id="common-fixes-443">Common fixes</h4>

<p>Change the declaration so that there’s exactly one required positional
parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  set s(int x) {}
}</code></pre>

<h3 id="wrong_number_of_type_arguments">
<a class="anchor" href="#wrong_number_of_type_arguments" aria-hidden="true"><span class="octicon octicon-link"></span></a>wrong_number_of_type_arguments</h3>

<p><em>The type ‘{0}’ is declared with {1} type parameters, but {2} type arguments
were given.</em></p>

<h4 id="description-444">Description</h4>

<p>The analyzer produces this diagnostic when a type that has type parameters
is used and type arguments are provided, but the number of type arguments
isn’t the same as the number of type parameters.</p>

<p>The analyzer also produces this diagnostic when a constructor is invoked
and the number of type arguments doesn’t match the number of type
parameters declared for the class.</p>

<h4 id="examples-44">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">C</code> has one type
parameter but two type arguments are provided when it is used as a type
annotation:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;E&gt; {}

void f(<span class="highlight">C&lt;int, int&gt;</span> x) {}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">C</code> declares one type
parameter, but two type arguments are provided when creating an instance:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;E&gt; {}

var c = <span class="highlight">C&lt;int, int&gt;</span>();</code></pre>

<h4 id="common-fixes-444">Common fixes</h4>

<p>Add or remove type arguments, as necessary, to match the number of type
parameters defined for the type:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;E&gt; {}

void f(C&lt;int&gt; x) {}</code></pre>

<h3 id="wrong_number_of_type_arguments_constructor">
<a class="anchor" href="#wrong_number_of_type_arguments_constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>wrong_number_of_type_arguments_constructor</h3>

<p><em>The constructor ‘{0}.{1}’ doesn’t have type parameters.</em></p>

<h4 id="description-445">Description</h4>

<p>The analyzer produces this diagnostic when type arguments are provided
after the name of a named constructor. Constructors can’t declare type
parameters, so invocations can only provide the type arguments associated
with the class, and those type arguments are required to follow the name of
the class rather than the name of the constructor.</p>

<h4 id="example-399">Example</h4>

<p>The following code produces this diagnostic because the type parameters
(<code class="language-plaintext highlighter-rouge">&lt;String&gt;</code>) follow the name of the constructor rather than the name of the
class:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  C.named();
}
C f() =&gt; C.named<span class="highlight">&lt;String&gt;</span>();</code></pre>

<h4 id="common-fixes-445">Common fixes</h4>

<p>If the type arguments are for the class’ type parameters, then move the
type arguments to follow the class name:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  C.named();
}
C f() =&gt; C&lt;String&gt;.named();</code></pre>

<p>If the type arguments aren’t for the class’ type parameters, then remove
them:</p>

<pre class="prettyprint lang-dart"><code>class C&lt;T&gt; {
  C.named();
}
C f() =&gt; C.named();</code></pre>

<h3 id="wrong_number_of_type_arguments_enum">
<a class="anchor" href="#wrong_number_of_type_arguments_enum" aria-hidden="true"><span class="octicon octicon-link"></span></a>wrong_number_of_type_arguments_enum</h3>

<p><em>The enum is declared with {0} type parameters, but {1} type arguments were
given.</em></p>

<h4 id="description-446">Description</h4>

<p>The analyzer produces this diagnostic when an enum constant in an enum
that has type parameters is instantiated and type arguments are provided,
but the number of type arguments isn’t the same as the number of type
parameters.</p>

<h4 id="example-400">Example</h4>

<p>The following code produces this diagnostic because the enum constant <code class="language-plaintext highlighter-rouge">c</code>
provides one type argument even though the enum <code class="language-plaintext highlighter-rouge">E</code> is declared to have
two type parameters:</p>

<pre class="prettyprint lang-dart"><code>enum E&lt;T, U&gt; {
  c<span class="highlight">&lt;int&gt;</span>()
}</code></pre>

<h4 id="common-fixes-446">Common fixes</h4>

<p>If the number of type parameters is correct, then change the number of
type arguments to match the number of type parameters:</p>

<pre class="prettyprint lang-dart"><code>enum E&lt;T, U&gt; {
  c&lt;int, String&gt;()
}</code></pre>

<p>If the number of type arguments is correct, then change the number of type
parameters to match the number of type arguments:</p>

<pre class="prettyprint lang-dart"><code>enum E&lt;T&gt; {
  c&lt;int&gt;()
}</code></pre>

<h3 id="wrong_number_of_type_arguments_extension">
<a class="anchor" href="#wrong_number_of_type_arguments_extension" aria-hidden="true"><span class="octicon octicon-link"></span></a>wrong_number_of_type_arguments_extension</h3>

<p><em>The extension ‘{0}’ is declared with {1} type parameters, but {2} type
arguments were given.</em></p>

<h4 id="description-447">Description</h4>

<p>The analyzer produces this diagnostic when an extension that has type
parameters is used and type arguments are provided, but the number of type
arguments isn’t the same as the number of type parameters.</p>

<h4 id="example-401">Example</h4>

<p>The following code produces this diagnostic because the extension <code class="language-plaintext highlighter-rouge">E</code> is
declared to have a single type parameter (<code class="language-plaintext highlighter-rouge">T</code>), but the extension override
has two type arguments:</p>

<pre class="prettyprint lang-dart"><code>extension E&lt;T&gt; on List&lt;T&gt; {
  int get len =&gt; length;
}

void f(List&lt;int&gt; p) {
  E<span class="highlight">&lt;int, String&gt;</span>(p).len;
}</code></pre>

<h4 id="common-fixes-447">Common fixes</h4>

<p>Change the type arguments so that there are the same number of type
arguments as there are type parameters:</p>

<pre class="prettyprint lang-dart"><code>extension E&lt;T&gt; on List&lt;T&gt; {
  int get len =&gt; length;
}

void f(List&lt;int&gt; p) {
  E&lt;int&gt;(p).len;
}</code></pre>

<h3 id="wrong_number_of_type_arguments_method">
<a class="anchor" href="#wrong_number_of_type_arguments_method" aria-hidden="true"><span class="octicon octicon-link"></span></a>wrong_number_of_type_arguments_method</h3>

<p><em>The method ‘{0}’ is declared with {1} type parameters, but {2} type arguments
are given.</em></p>

<h4 id="description-448">Description</h4>

<p>The analyzer produces this diagnostic when a method or function is invoked
with a different number of type arguments than the number of type
parameters specified in its declaration. There must either be no type
arguments or the number of arguments must match the number of parameters.</p>

<h4 id="example-402">Example</h4>

<p>The following code produces this diagnostic because the invocation of the
method <code class="language-plaintext highlighter-rouge">m</code> has two type arguments, but the declaration of <code class="language-plaintext highlighter-rouge">m</code> only has one
type parameter:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int m&lt;A&gt;(A a) =&gt; 0;
}

int f(C c) =&gt; c.m<span class="highlight">&lt;int, int&gt;</span>(2);</code></pre>

<h4 id="common-fixes-448">Common fixes</h4>

<p>If the type arguments are necessary, then make them match the number of
type parameters by either adding or removing type arguments:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int m&lt;A&gt;(A a) =&gt; 0;
}

int f(C c) =&gt; c.m&lt;int&gt;(2);</code></pre>

<p>If the type arguments aren’t necessary, then remove them:</p>

<pre class="prettyprint lang-dart"><code>class C {
  int m&lt;A&gt;(A a) =&gt; 0;
}

int f(C c) =&gt; c.m(2);</code></pre>

<h3 id="yield_in_non_generator">
<a class="anchor" href="#yield_in_non_generator" aria-hidden="true"><span class="octicon octicon-link"></span></a>yield_in_non_generator</h3>

<p><em>Yield statements must be in a generator function (one marked with either
‘async*’ or ‘sync*’).</em></p>

<p><em>Yield-each statements must be in a generator function (one marked with either
‘async*’ or ‘sync*’).</em></p>

<h4 id="description-449">Description</h4>

<p>The analyzer produces this diagnostic when a <code class="language-plaintext highlighter-rouge">yield</code> or <code class="language-plaintext highlighter-rouge">yield*</code> statement
appears in a function whose body isn’t marked with one of the <code class="language-plaintext highlighter-rouge">async*</code> or
<code class="language-plaintext highlighter-rouge">sync*</code> modifiers.</p>

<h4 id="examples-45">Examples</h4>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">yield</code> is being used
in a function whose body doesn’t have a modifier:</p>

<pre class="prettyprint lang-dart"><code>Iterable&lt;int&gt; get digits {
  yield* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
}</code></pre>

<p>The following code produces this diagnostic because <code class="language-plaintext highlighter-rouge">yield*</code> is being used
in a function whose body has the <code class="language-plaintext highlighter-rouge">async</code> modifier rather than the <code class="language-plaintext highlighter-rouge">async*</code>
modifier:</p>

<pre class="prettyprint lang-dart"><code>Stream&lt;int&gt; get digits async {
  yield* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
}</code></pre>

<h4 id="common-fixes-449">Common fixes</h4>

<p>Add a modifier, or change the existing modifier to be either <code class="language-plaintext highlighter-rouge">async*</code> or
<code class="language-plaintext highlighter-rouge">sync*</code>:</p>

<pre class="prettyprint lang-dart"><code>Iterable&lt;int&gt; get digits sync* {
  yield* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
}</code></pre>

<h3 id="yield_of_invalid_type">
<a class="anchor" href="#yield_of_invalid_type" aria-hidden="true"><span class="octicon octicon-link"></span></a>yield_of_invalid_type</h3>

<p><em>A yielded value of type ‘{0}’ must be assignable to ‘{1}’.</em></p>

<p><em>The type ‘{0}’ implied by the ‘yield*’ expression must be assignable to ‘{1}’.</em></p>

<h4 id="description-450">Description</h4>

<p>The analyzer produces this diagnostic when the type of object produced by
a <code class="language-plaintext highlighter-rouge">yield</code> or <code class="language-plaintext highlighter-rouge">yield*</code> expression doesn’t match the type of objects that
are to be returned from the <code class="language-plaintext highlighter-rouge">Iterable</code> or <code class="language-plaintext highlighter-rouge">Stream</code> types that are returned
from a generator (a function or method marked with either <code class="language-plaintext highlighter-rouge">sync*</code> or
<code class="language-plaintext highlighter-rouge">async*</code>).</p>

<h4 id="example-403">Example</h4>

<p>The following code produces this diagnostic because the getter <code class="language-plaintext highlighter-rouge">zero</code> is
declared to return an <code class="language-plaintext highlighter-rouge">Iterable</code> that returns integers, but the <code class="language-plaintext highlighter-rouge">yield</code> is
returning a string from the iterable:</p>

<pre class="prettyprint lang-dart"><code>Iterable&lt;int&gt; get zero sync* {
  yield <span class="highlight">'0'</span>;
}</code></pre>

<h4 id="common-fixes-450">Common fixes</h4>

<p>If the return type of the function is correct, then fix the expression
following the keyword <code class="language-plaintext highlighter-rouge">yield</code> to return the correct type:</p>

<pre class="prettyprint lang-dart"><code>Iterable&lt;int&gt; get zero sync* {
  yield 0;
}</code></pre>

<p>If the expression following the <code class="language-plaintext highlighter-rouge">yield</code> is correct, then change the return
type of the function to allow it:</p>

<pre class="prettyprint lang-dart"><code>Iterable&lt;String&gt; get zero sync* {
  yield '0';
}</code></pre>


          

        </div>
      </article>
    </main>
    <footer id="page-footer">
  <div class="footer-section footer-main">
    <a href="/" class="brand" title="Dart">
      <img src="/assets/img/shared/dart/logo+text/horizontal/white.svg" alt="Dart" width="164px">
    </a>
    <div class="footer-social-links">
      <a href="https://medium.com/dartlang" target="_blank" rel="noopener" title="Medium blog" class="no-automatic-external">
        <svg>
          <use href="/assets/img/social/medium.svg#medium"></use>
        </svg>
      </a>
      <a href="https://github.com/dart-lang" target="_blank" rel="noopener" title="GitHub" class="no-automatic-external">
        <svg>
          <use href="/assets/img/social/github.svg#github"></use>
        </svg>
      </a>
      <a href="https://twitter.com/dart_lang" target="_blank" rel="noopener" title="Twitter" class="no-automatic-external">
        <svg>
          <use href="/assets/img/social/twitter.svg#twitter"></use>
        </svg>
      </a>
    </div>
  </div>
  <div class="footer-section footer-tray">
    <div class="footer-licenses">
      Salvo que se indique lo contrario, este sitio está bajo una 
      <a href="https://creativecommons.org/licenses/by/4.0/" class="no-automatic-external">licencia internacional Creative Commons Attribution 4.0</a >, 
      y los ejemplos de código tienen licencia 
      <a href="https://opensource.org/licenses/BSD-3-Clause" class="no-automatic-external">3-Clause BSD License</a>.
    </div>
    <div class="footer-utility-links">
      <ul>
        <li><a href="/terms" title="Terms of use">Términos</a></li>
        <li><a href="https://policies.google.com/privacy" target="_blank" rel="noopener" title="Privacy policy" class="no-automatic-external">Privacidad</a></li>
        <li><a href="/security" title="Security philosophy and practices">Seguridad</a></li>
      </ul>
    </div>
  </div>
</footer>

   
  </body>
</html>
