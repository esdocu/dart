<!DOCTYPE html>
<html>
  

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Language" content="es_ES" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-M146BEZEJV"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-M146BEZEJV');
  </script>

  <meta name="description" content="A deep dive into Dart language and library changes related to null safety.">
  <title>Understanding null safety | Dart es Español</title>

  <!-- Favicon / Touch Icons -->
  <link rel="icon" sizes="64x64" href="/assets/shared/dart/icon/64.png">
  <link href="/assets/img/touch-icon-iphone.png" rel="apple-touch-icon">
  <link href="/assets/img/touch-icon-ipad.png" rel="apple-touch-icon" sizes="152x152">
  <link href="/assets/img/touch-icon-iphone-retina.png" rel="apple-touch-icon" sizes="180x180">
  <link href="/assets/img/touch-icon-ipad-retina.png" rel="apple-touch-icon" sizes="167x167">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@dart_lang" />
  <meta name="twitter:title" content="Understanding null safety" />
  <meta name="twitter:description" content="A deep dive into Dart language and library changes related to null safety." />

  <!-- Open Graph -->
  <meta property="og:title" content="Understanding null safety" />
  <meta property="og:description" content="A deep dive into Dart language and library changes related to null safety." />
  <meta property="og:url" content="https://dart.esdocu.com/null-safety/understanding-null-safety/" />
  
  <meta property="og:image" content="https://dart.esdocu.com/assets/shared/dart-logo-for-shares.png?2" />
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans+Display:wght@400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans+Mono:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons&display=swap" rel="stylesheet">
  <script 
    src="https://use.fontawesome.com/releases/v5.15.4/js/all.js"
    data-auto-replace-svg="nest">
  </script>

  <link rel="stylesheet" href="/assets/css/main.css?v=1662050124">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
          integrity="sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK"
          crossorigin="anonymous"
          referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.1/umd/popper.min.js"
          integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN"
          crossorigin="anonymous"
          referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.1/js/bootstrap.min.js"
          integrity="sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2"
          crossorigin="anonymous"
          referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/3.0.1/js.cookie.min.js" 
          integrity="sha512-wT7uPE7tOP6w4o28u1DN775jYjHQApdBnib5Pho4RB0Pgd9y7eSkAV1BTqQydupYDB9GBhTcQQzyNMPMV3cAew==" 
          crossorigin="anonymous" 
          referrerpolicy="no-referrer"></script>

  <script src="/assets/js/vendor/code-prettify/prettify.js"></script>
  <script src="/assets/js/vendor/code-prettify/lang-css.js"></script>
  <script src="/assets/js/vendor/code-prettify/lang-dart.js"></script>
  <script src="/assets/js/vendor/code-prettify/lang-yaml.js"></script>
  <script src="/assets/js/os-tabs.js?v=1662050124"></script>
  <script src="/assets/js/utilities.js?v=1662050124"></script>
  <script src="/assets/js/main.js?v=1662050124"></script>

  <script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26406144-4', 'auto');
ga('send', 'pageview');

</script>


 </head>

  <body class="default show_banner">
    <section id="cookie-notice">
  <div class="container">
    <p>Google utiliza cookies para prestar sus servicios, personalizar anuncios y analizar el tráfico. 
      Puedes ajustar tus controles de privacidad en cualquier momento en tu 
      <a href="https://myaccount.google.com/data-and-personalization" target="_blank" rel="noopener" class="no-automatic-external">Configuración de Google</a>.
      <a href="https://policies.google.com/technologies/cookies" target="_blank" rel="noopener" class="no-automatic-external">Más información</a>.
    </p>
    <button id="cookie-consent" class="btn btn-primary">Está bien</button>
  </div>
</section>

    <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5VSZM5J"
 height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

    <header id="page-header" class="site-header">
  <nav id="mainnav" class="site-header">
  <div id="menu-toggle"><i class="material-icons">menu</i></div>
  <a href="/" class="brand" title="Dart es Español">
    <img src="/assets/img/shared/dart/logo+text/horizontal/white.svg" alt="Dart es Español">
  </a>
  <ul class="navbar">
    <li>
      <a href="/overview" class="nav-link">Overview</a>
    </li>
    <li class="mainnav__get-started">
      <a href="/guides" class="nav-link
        ">
        <span>Docs</span>
      </a>
    </li>
    <li>
      <a href="/community" class="nav-link">Comunidad</a>
    </li>
    <li>
      <a href="/#try-dart" class="nav-link">Probar Dart</a>
    </li>
    <li>
      <a href="/get-dart" class="nav-link">Obtener Dart</a>
    </li>
    <li class="searchfield">
      <form action="/search" class="site-header__search form-inline" id="cse-search-box">
        <input type="hidden" name="cx" value="011220921317074318178:_yy-tmb5t_i">
        <input type="hidden" name="ie" value="UTF-8">
        <input type="hidden" name="hl" value="en">
        <input class="site-header__searchfield form-control search-field" type="search" name="q"
          id="q" autocomplete="off" placeholder="Search" aria-label="Search">
      </form>
    </li>
  </ul>
</nav>

  
</header>
 <div class="banner">
  <p class="banner__text">
    Dart 2.18 ya está disponible con interoperabilidad de Objective-C y Swift y mejoras de networking, la inferencia de tipos y el rendimiento del código asíncrono. <a href="https://medium.com/@mit.mit/dart-2-18-f4b3101f146c">Más información</a><br>
    Los equipos de Flutter y Dart están contratando.
    <a href="https://docs.flutter.dev/jobs">Más información</a>
  </p>
</div> 

    <div id="sidenav" class="">
  <form action="/search/" class="site-header__search form-inline">
    <input class="site-header__searchfield form-control search-field" type="search" name="q"
           id="q" autocomplete="off" placeholder="Search" aria-label="Search">
  </form>

  <div class="site-sidebar">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a href="/overview" class="nav-link">Overview</a>
      </li>
      <li class="nav-item">
        <a href="/community" class="nav-link">Comunidad</a>
      </li>
      <li class="nav-item">
        <a href="https://dartpad.dev" class="nav-link">Probar Dart</a>
      </li>
      <li class="nav-item">
        <a href="/get-dart" class="nav-link">Obtener Dart</a>
      </li>
      <li class="nav-item">
        <a href="/guides" class="nav-link">Docs</a>
      </li>
    </ul>

    <ul class="nav flex-column"><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-1" role="button"
        aria-expanded="false" aria-controls="sidenav-1"
      >Samples & tutorials</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-1">
        <li class="nav-item">
    <a class="nav-link" href="/samples">Language samples</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable"
      data-toggle="collapse" data-target="#sidenav-1-2"
      href="#sidenav-1-2" role="button"
      aria-expanded="true" aria-controls="sidenav-1-2"
    >Codelabs
    </a>
    <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-1-2">
      <li class="nav-item">
    <a class="nav-link" href="/codelabs">List of Dart codelabs</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/codelabs/dart-cheatsheet">Language cheatsheet</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/codelabs/iterables">Iterable collections</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/codelabs/async-await">Asynchronous programming</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/codelabs/null-safety">Null safety</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/tutorials">Tutorials</a>
  </li>
</ul>
    </li><li class="nav-item">
      <a class="nav-link active" data-toggle="collapse" href="#sidenav-2" role="button"
        aria-expanded="true" aria-controls="sidenav-2"
      >Language</a>

      <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-2">
        <li class="nav-item">
    <a class="nav-link" href="/guides/language/language-tour">Tour</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/type-system">Type system</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-2-3"
      href="#sidenav-2-3" role="button"
      aria-expanded="false" aria-controls="sidenav-2-3"
    >Effective Dart
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-2-3">
      <li class="nav-item">
    <a class="nav-link" href="/guides/language/effective-dart">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/effective-dart/style">Style</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/effective-dart/documentation">Documentation</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/effective-dart/usage">Usage</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/effective-dart/design">Design</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-2-4"
      href="#sidenav-2-4" role="button"
      aria-expanded="false" aria-controls="sidenav-2-4"
    >Coming from ...
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-2-4">
      <li class="nav-item">
    <a class="nav-link" href="/guides/language/coming-from/js-to-dart">JavaScript to Dart</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/guides/language/extension-methods">Extension methods</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/concurrency">Concurrency</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/numbers">Numbers</a>
  </li><li class="nav-item">
    <a class="nav-link active collapsable"
      data-toggle="collapse" data-target="#sidenav-2-8"
      href="#sidenav-2-8" role="button"
      aria-expanded="true" aria-controls="sidenav-2-8"
    >Null safety
    </a>
    <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-2-8">
      <li class="nav-item">
    <a class="nav-link" href="/null-safety">Overview: Sound null safety</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/null-safety/migration-guide">Migrating to null safety</a>
  </li><li class="nav-item">
    <a class="nav-link active" href="/null-safety/understanding-null-safety">Understanding null safety</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/null-safety/unsound-null-safety">Unsound null safety</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/null-safety/faq">FAQ</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/guides/language/evolution">Evolution</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/spec">Specification</a>
  </li>
</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-3" role="button"
        aria-expanded="false" aria-controls="sidenav-3"
      >Core libraries</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-3">
        <li class="nav-item">
    <a class="nav-link" href="/guides/libraries">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/library-tour">Tour</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-3-3"
      href="#sidenav-3-3" role="button"
      aria-expanded="false" aria-controls="sidenav-3-3"
    >Articles
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-3-3">
      <li class="nav-item">
    <a class="nav-link" href="/articles/libraries/dart-io">Intro to dart:io</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/articles/libraries/creating-streams">Creating streams</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-4" role="button"
        aria-expanded="false" aria-controls="sidenav-4"
      >Packages</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-4">
        <li class="nav-item">
    <a class="nav-link" href="/guides/packages">How to use packages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/useful-libraries">Commonly used packages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/create-library-packages">Creating packages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/publishing">Publishing packages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/writing-package-pages">Writing package pages</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-4-6"
      href="#sidenav-4-6" role="button"
      aria-expanded="false" aria-controls="sidenav-4-6"
    >Package reference
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-4-6">
      <li class="nav-item">
    <a class="nav-link" href="/tools/pub/dependencies">Dependencies</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/glossary">Glossary</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/package-layout">Package layout conventions</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/environment-variables">Pub environment variables</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/pubspec">Pubspec file</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/troubleshoot">Troubleshooting pub</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/verified-publishers">Verified publishers</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/pub/versioning">Versioning</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-5" role="button"
        aria-expanded="false" aria-controls="sidenav-5"
      >Development</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5">
        <li class="nav-item">
    <a class="nav-link" href="/codelabs/async-await">Futures, async, await</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/language/streams">Streams</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/json">JSON</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-4"
      href="#sidenav-5-4" role="button"
      aria-expanded="false" aria-controls="sidenav-5-4"
    >Interoperability
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-4">
      <li class="nav-item">
    <a class="nav-link" href="/guides/libraries/c-interop">C interop</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/objective-c-interop">Objective-C and Swift interop</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/web/js-interop">JavaScript interop</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/guides/google-apis">Google APIs</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/multiplatform-apps">Multi-platform apps</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-7"
      href="#sidenav-5-7" role="button"
      aria-expanded="false" aria-controls="sidenav-5-7"
    >Command-line & server apps
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-7">
      <li class="nav-item">
    <a class="nav-link" href="/server">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/server/get-started">Get started</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/server/cmdline">Write command-line apps</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/server/httpserver">Write HTTP servers</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/server/libraries">Libraries and packages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/server/google-cloud">Google Cloud</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-8"
      href="#sidenav-5-8" role="button"
      aria-expanded="false" aria-controls="sidenav-5-8"
    >Web apps
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-8">
      <li class="nav-item">
    <a class="nav-link" href="/web">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/web/get-started">Get started</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tutorials/web/fetch-data">Fetch data dynamically</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-5-8-4"
      href="#sidenav-5-8-4" role="button"
      aria-expanded="false" aria-controls="sidenav-5-8-4"
    >Low-level web programming
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-5-8-4">
      <li class="nav-item">
    <a class="nav-link" href="/tutorials/web/low-level-html/connect-dart-html">Connect Dart & HTML</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tutorials/web/low-level-html/add-elements">Add elements to the DOM</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tutorials/web/low-level-html/remove-elements">Remove DOM elements</a>
  </li>
  </ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/web/deployment">Deployment</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/web/libraries">Libraries and packages</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-6" role="button"
        aria-expanded="false" aria-controls="sidenav-6"
      >Tools & techniques</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6">
        <li class="nav-item">
    <a class="nav-link" href="/tools">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-2"
      href="#sidenav-6-2" role="button"
      aria-expanded="false" aria-controls="sidenav-6-2"
    >Editors & debuggers
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-2">
      <li class="nav-item">
    <a class="nav-link" href="/tools/jetbrains-plugin">IntelliJ & Android Studio</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/vs-code">VS Code</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/dart-devtools">Dart DevTools</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/dartpad">DartPad</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-3"
      href="#sidenav-6-3" role="button"
      aria-expanded="false" aria-controls="sidenav-6-3"
    >Command-line tools
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-3">
      <li class="nav-item">
    <a class="nav-link collapsable"
      data-toggle="collapse" data-target="#sidenav-6-3-1"
      href="#sidenav-6-3-1" role="button"
      aria-expanded="true" aria-controls="sidenav-6-3-1"
    >Dart SDK
    </a>
    <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-6-3-1">
      <li class="nav-item">
    <a class="nav-link" href="/tools/sdk">Overview</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-tool">dart</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-analyze">dart analyze</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-compile">dart compile</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-create">dart create</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-doc">dart doc</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-fix">dart fix</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-format">dart format</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/pub/cmd">dart pub</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-run">dart run</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dart-test">dart test</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/dartaotruntime">dartaotruntime</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/experiment-flags">Experiment flags</a>
  </li>
  </ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable"
      data-toggle="collapse" data-target="#sidenav-6-3-2"
      href="#sidenav-6-3-2" role="button"
      aria-expanded="true" aria-controls="sidenav-6-3-2"
    >Other command-line tools
    </a>
    <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-6-3-2">
      <li class="nav-item">
    <a class="nav-link" href="/tools/build_runner">build_runner</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tools/webdev">webdev</a>
  </li>
  </ul>
  </li>
</ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-4"
      href="#sidenav-6-4" role="button"
      aria-expanded="false" aria-controls="sidenav-6-4"
    >Managing source code
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-4">
      <li class="nav-item">
    <a class="nav-link" href="/guides/language/formatting">Formatting code</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/libraries/private-files">What not to commit</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-5"
      href="#sidenav-6-5" role="button"
      aria-expanded="false" aria-controls="sidenav-6-5"
    >Static analysis
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-5">
      <li class="nav-item">
    <a class="nav-link" href="/guides/language/analysis-options">Customizing static analysis</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/guides/language/sound-problems">Fixing common type problems</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/diagnostic-messages">Diagnostic messages</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/tools/linter-rules">Linter rules</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-6-6"
      href="#sidenav-6-6" role="button"
      aria-expanded="false" aria-controls="sidenav-6-6"
    >Testing & optimization
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-6-6">
      <li class="nav-item">
    <a class="nav-link" href="/guides/testing">Testing</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/web/debugging">Debugging web apps</a>
  </li></ul>
  </li>

</ul>
    </li><li class="nav-item">
      <a class="nav-link collapsed" data-toggle="collapse" href="#sidenav-7" role="button"
        aria-expanded="false" aria-controls="sidenav-7"
      >Resources</a>

      <ul class="nav flex-column flex-nowrap collapse " id="sidenav-7">
        <li class="nav-item">
    <a class="nav-link" href="/resources">Overview</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/resources/books">Books</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/resources/dartpad-best-practices">DartPad in tutorials: Best practices</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/code-of-conduct">Code of conduct</a>
  </li><li class="nav-item">
    <a class="nav-link" href="/faq">FAQ</a>
  </li><li class="nav-item">
    <a class="nav-link collapsable collapsed"
      data-toggle="collapse" data-target="#sidenav-7-6"
      href="#sidenav-7-6" role="button"
      aria-expanded="false" aria-controls="sidenav-7-6"
    >History
    </a>
    <ul class="nav flex-column flex-nowrap collapse " id="sidenav-7-6">
      <li class="nav-item">
    <a class="nav-link" href="/dart-2">Migrating to Dart&nbsp;2</a>
  </li></ul>
  </li>
<li class="nav-item">
    <a class="nav-link" href="/resources/videos">Videos</a>
  </li>
</ul>
    </li><li class="nav-item">
      <a class="nav-link " data-toggle="collapse" href="#sidenav-8" role="button"
        aria-expanded="true" aria-controls="sidenav-8"
      >Related sites</a>

      <ul class="nav flex-column flex-nowrap collapse show" id="sidenav-8">
        <li class="nav-item">
    <a class="nav-link" href="https://api.dart.dev" target="_blank" rel="noopener">API reference<span class="material-icons md-24">
        open_in_new
      </span></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://medium.com/dartlang" target="_blank" rel="noopener">Blog<span class="material-icons md-24">
        open_in_new
      </span></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://dartpad.dev" target="_blank" rel="noopener">DartPad (online editor)<span class="material-icons md-24">
        open_in_new
      </span></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://flutter.dev" target="_blank" rel="noopener">Flutter<span class="material-icons md-24">
        open_in_new
      </span></a>
  </li><li class="nav-item">
    <a class="nav-link" href="https://pub.dev" target="_blank" rel="noopener">Package site<span class="material-icons md-24">
        open_in_new
      </span></a>
  </li>
</ul>
    </li></ul>

  </div>
</div>

    <main id="page-content">
      







<div id="site-toc--side" class="site-toc ">
  <header class="site-toc__title">
    Contents
    <button type="button" class="btn site-toc--button__page-top" aria-label="Page top"></button>
    
  </header>
  <ul id="toc" class="section-nav">
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#nullability-in-the-type-system">Nullability in the type system</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#non-nullable-and-nullable-types">Non-nullable and nullable types</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#using-nullable-types">Using nullable types</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#top-and-bottom">Top and bottom</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#ensuring-correctness">Ensuring correctness</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#invalid-returns">Invalid returns</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#uninitialized-variables">Uninitialized variables</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#flow-analysis">Flow analysis</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#reachability-analysis">Reachability analysis</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#never-for-unreachable-code">Never for unreachable code</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#definite-assignment-analysis">Definite assignment analysis</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#type-promotion-on-null-checks">Type promotion on null checks</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#unnecessary-code-warnings">Unnecessary code warnings</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#working-with-nullable-types">Working with nullable types</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#smarter-null-aware-methods">Smarter null-aware methods</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#null-assertion-operator">Null assertion operator</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#late-variables">Late variables</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#lazy-initialization">Lazy initialization</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#late-final-variables">Late final variables</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#required-named-parameters">Required named parameters</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#abstract-fields">Abstract fields</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#working-with-nullable-fields">Working with nullable fields</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#nullability-and-generics">Nullability and generics</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#core-library-changes">Core library changes</a>
<ul class="nav">
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#the-map-index-operator-is-nullable">The Map index operator is nullable</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#no-unnamed-list-constructor">No unnamed List constructor</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#cannot-set-a-larger-length-on-non-nullable-lists">Cannot set a larger length on non-nullable lists</a></li>
<li class="toc-entry nav-item toc-h3"><a class="nav-link" href="#cannot-access-iteratorcurrent-before-or-after-iteration">Cannot access Iterator.current before or after iteration</a></li>
</ul>
</li>
<li class="toc-entry nav-item toc-h2"><a class="nav-link" href="#summary">Summary</a></li>
</ul>
</div>


      <article>
        <div class="content">
          

          <div>
            <div id="page-github-links" class="btn-group" aria-label="Page GitHub links" role="group">
  <a href="https://github.com/dart-lang/site-www/tree/main/src/null-safety/understanding-null-safety/index.md" class="btn no-automatic-external" title="View page source" target="_blank" rel="noopener">
    <i class="fas fa-file-alt fa-sm"></i>
  </a>
  <a href="https://github.com/dart-lang/site-www/issues/new?template=1_page_issue.yml&title=[PAGE ISSUE]: 'Understanding null safety'&page-url=https://dart.esdocu.com/null-safety/understanding-null-safety/&page-source=https://github.com/dart-lang/site-www/tree/main/src/null-safety/understanding-null-safety/index.md" class="btn no-automatic-external" title="Report an issue with this page"
    target="_blank" rel="noopener">
    <i class="fas fa-bug fa-sm"></i>
  </a>
</div>

            <h1>Understanding null safety</h1>
          </div>
          







<div id="site-toc--inline" class="site-toc toc-collapsible toc-collapsed">
  <header class="site-toc__title">
    Contents
    <button type="button" class="btn site-toc--button__page-top" aria-label="Page top"></button>
    
      <span class="site-toc--inline__toggle toc-toggle-down"><i class="material-icons">keyboard_arrow_down</i></span>
      <span class="site-toc--inline__toggle toc-toggle-up"><i class="material-icons">keyboard_arrow_up</i></span>
    
  </header>
  <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#nullability-in-the-type-system">Nullability in the type system</a>
<ul>
<li class="toc-entry toc-h3"><a href="#non-nullable-and-nullable-types">Non-nullable and nullable types</a></li>
<li class="toc-entry toc-h3"><a href="#using-nullable-types">Using nullable types</a></li>
<li class="toc-entry toc-h3"><a href="#top-and-bottom">Top and bottom</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#ensuring-correctness">Ensuring correctness</a>
<ul>
<li class="toc-entry toc-h3"><a href="#invalid-returns">Invalid returns</a></li>
<li class="toc-entry toc-h3"><a href="#uninitialized-variables">Uninitialized variables</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#flow-analysis">Flow analysis</a>
<ul>
<li class="toc-entry toc-h3"><a href="#reachability-analysis">Reachability analysis</a></li>
<li class="toc-entry toc-h3"><a href="#never-for-unreachable-code">Never for unreachable code</a></li>
<li class="toc-entry toc-h3"><a href="#definite-assignment-analysis">Definite assignment analysis</a></li>
<li class="toc-entry toc-h3"><a href="#type-promotion-on-null-checks">Type promotion on null checks</a></li>
<li class="toc-entry toc-h3"><a href="#unnecessary-code-warnings">Unnecessary code warnings</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#working-with-nullable-types">Working with nullable types</a>
<ul>
<li class="toc-entry toc-h3"><a href="#smarter-null-aware-methods">Smarter null-aware methods</a></li>
<li class="toc-entry toc-h3"><a href="#null-assertion-operator">Null assertion operator</a></li>
<li class="toc-entry toc-h3"><a href="#late-variables">Late variables</a></li>
<li class="toc-entry toc-h3"><a href="#lazy-initialization">Lazy initialization</a></li>
<li class="toc-entry toc-h3"><a href="#late-final-variables">Late final variables</a></li>
<li class="toc-entry toc-h3"><a href="#required-named-parameters">Required named parameters</a></li>
<li class="toc-entry toc-h3"><a href="#abstract-fields">Abstract fields</a></li>
<li class="toc-entry toc-h3"><a href="#working-with-nullable-fields">Working with nullable fields</a></li>
<li class="toc-entry toc-h3"><a href="#nullability-and-generics">Nullability and generics</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#core-library-changes">Core library changes</a>
<ul>
<li class="toc-entry toc-h3"><a href="#the-map-index-operator-is-nullable">The Map index operator is nullable</a></li>
<li class="toc-entry toc-h3"><a href="#no-unnamed-list-constructor">No unnamed List constructor</a></li>
<li class="toc-entry toc-h3"><a href="#cannot-set-a-larger-length-on-non-nullable-lists">Cannot set a larger length on non-nullable lists</a></li>
<li class="toc-entry toc-h3"><a href="#cannot-access-iteratorcurrent-before-or-after-iteration">Cannot access Iterator.current before or after iteration</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#summary">Summary</a></li>
</ul>
</div>


          <p><em>Written by Bob Nystrom<br>
July 2020</em></p>

<p>Null safety is the largest change we’ve made to Dart since we replaced the
original unsound optional type system with <a href="/guides/language/type-system">a sound static type system</a>
in Dart 2.0. When Dart first launched, compile-time null safety was a rare
feature needing a long introduction. Today, Kotlin, Swift, Rust, and other
languages all have their own answers to what has become a very <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">familiar
problem.</a> Here is an example:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Without null safety:</span>
<span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="kt">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">string</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>

<span class="n">main</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">isEmpty</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If you run this Dart program without null safety, it throws a
<code class="language-plaintext highlighter-rouge">NoSuchMethodError</code> exception on the call to <code class="language-plaintext highlighter-rouge">.length</code>. The <code class="language-plaintext highlighter-rouge">null</code> value is an
instance of the <code class="language-plaintext highlighter-rouge">Null</code> class, and <code class="language-plaintext highlighter-rouge">Null</code> has no “length” getter. Runtime
failures suck. This is especially true in a language like Dart that is designed
to run on an end-user’s device. If a server application fails, you can often
restart it before anyone notices. But when a Flutter app crashes on a user’s
phone, they are not happy. When your users aren’t happy, you aren’t happy.</p>

<p>Developers like statically-typed languages like Dart because they enable the
type checker to find mistakes in code at compile time, usually right in the IDE.
The sooner you find a bug, the sooner you can fix it. When language designers
talk about “fixing null reference errors”, they mean enriching the static type
checker so that the language can detect mistakes like the above attempt to call
<code class="language-plaintext highlighter-rouge">.length</code> on a value that might be <code class="language-plaintext highlighter-rouge">null</code>.</p>

<p>There is no one true solution to this problem. Rust and Kotlin both have their
own approach that makes sense in the context of those languages. This doc walks
through all the details of our answer for Dart. It includes changes to the
static type system and a suite of other modifications and new language features
to let you not only write null-safe code but hopefully to <em>enjoy</em> doing so.</p>

<p>This document is long. If you want something shorter that covers just what you
need to know to get up and running, start with the <a href="/null-safety">overview</a>. When you are
ready for a deeper understanding and have the time, come back here so you can
understand <em>how</em> the language handles <code class="language-plaintext highlighter-rouge">null</code>, <em>why</em> we designed it that way, and
how to write idiomatic, modern, null-safe Dart. (Spoiler alert: it ends up
surprisingly close to how you write Dart today.)</p>

<p>The various ways a language can tackle null reference errors each have their
pros and cons. These principles guided the choices we made:</p>

<ul>
  <li>
    <p><strong>Code should be safe by default.</strong> If you write new Dart code and don’t use
any explicitly unsafe features, it never throws a null reference error at
runtime. All possible null reference errors are caught statically. If you
want to defer some of that checking to runtime to get greater flexibility,
you can, but you have to choose that by using some feature that is textually
visible in the code.</p>

    <p>In other words, we aren’t giving you a life jacket and leaving it up to you
to remember to put it on every time you go out on the water. Instead, we
give you a boat that doesn’t sink. You stay dry unless you jump overboard.</p>
  </li>
  <li>
    <p><strong>Null safe code should be easy to write.</strong> Most existing Dart code is
dynamically correct and does not throw null reference errors. You like your
Dart program the way it looks now, and we want you to be able to keep
writing code that way. Safety shouldn’t require sacrificing usability,
paying penance to the type checker, or having to significantly change the
way you think.</p>
  </li>
  <li>
    <p><strong>The resulting null safe code should be fully sound.</strong> “Soundness” in the
context of static checking means different things to different people. For
us, in the context of null safety, that means that if an expression has a
static type that does not permit <code class="language-plaintext highlighter-rouge">null</code>, then no possible execution of that
expression can ever evaluate to <code class="language-plaintext highlighter-rouge">null</code>. The language provides this guarantee
mostly through static checks, but there can be some runtime checks involved
too. (Though, note the first principle: any place where those runtime checks
happen will be your choice.)</p>

    <p>Soundness is important for user confidence. A boat that <em>mostly</em> stays
afloat is not one you’re enthused to brave the open seas on. But it’s also
important for our intrepid compiler hackers. When the language makes hard
guarantees about semantic properties of a program, it means that the
compiler can perform optimizations that assume those properties are true.
When it comes to <code class="language-plaintext highlighter-rouge">null</code>, it means we can generate smaller code that
eliminates unneeded <code class="language-plaintext highlighter-rouge">null</code> checks, and faster code that doesn’t need to
verify a receiver is non-<code class="language-plaintext highlighter-rouge">null</code> before calling methods on it.</p>

    <p>One caveat: We only guarantee soundness in Dart programs that are fully null
safe. Dart supports programs that contain a mixture of newer null safe code
and older legacy code. In these mixed-version programs, null reference errors
may still occur. In a mixed-version program, you get all of the <em>static</em> safety
benefits in the portions that are null safe, but you don’t get full runtime
soundness until the entire application is null safe.</p>
  </li>
</ul>

<p>Note that <em>eliminating</em> <code class="language-plaintext highlighter-rouge">null</code> is not a goal. There’s nothing wrong with <code class="language-plaintext highlighter-rouge">null</code>.
On the contrary, it’s really useful to be able to represent the <em>absence</em> of a
value. Building support for a special “absent” value directly into the language
makes working with absence flexible and usable. It underpins optional
parameters, the handy <code class="language-plaintext highlighter-rouge">?.</code> null-aware operator, and default initialization. It
is not <code class="language-plaintext highlighter-rouge">null</code> that is bad, it is having <code class="language-plaintext highlighter-rouge">null</code> go <em>where you don’t expect it</em>
that causes problems.</p>

<p>Thus with null safety, our goal is to give you <em>control</em> and <em>insight</em> into
where <code class="language-plaintext highlighter-rouge">null</code> can flow through your program and certainty that it can’t flow
somewhere that would cause a crash.</p>

<h2 id="nullability-in-the-type-system">
<a class="anchor" href="#nullability-in-the-type-system" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nullability in the type system</h2>

<p>Null safety begins in the static type system because everything else rests upon
that. Your Dart program has a whole universe of types in it: primitive types
like <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">String</code>, collection types like <code class="language-plaintext highlighter-rouge">List</code>, and all of the classes
and types you and the packages you use define. Before null safety, the static
type system allowed the value <code class="language-plaintext highlighter-rouge">null</code> to flow into expressions of any of those
types.</p>

<p>In type theory lingo, the <code class="language-plaintext highlighter-rouge">Null</code> type was treated as a subtype of all types:</p>

<p><img src="understanding-null-safety/hierarchy-before.png" width="335"></p>

<p>The set of operations—getters, setters, methods, and
operators—allowed on some expressions are defined by its type. If the type
is <code class="language-plaintext highlighter-rouge">List</code>, you can call <code class="language-plaintext highlighter-rouge">.add()</code> or <code class="language-plaintext highlighter-rouge">[]</code> on it. If it’s <code class="language-plaintext highlighter-rouge">int</code>, you can call <code class="language-plaintext highlighter-rouge">+</code>.
But the <code class="language-plaintext highlighter-rouge">null</code> value doesn’t define any of those methods. Allowing <code class="language-plaintext highlighter-rouge">null</code> to
flow into an expression of some other type means any of those operations can
fail. This is really the crux of null reference errors—every failure comes
from trying to look up a method or property on <code class="language-plaintext highlighter-rouge">null</code> that it doesn’t have.</p>

<h3 id="non-nullable-and-nullable-types">
<a class="anchor" href="#non-nullable-and-nullable-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Non-nullable and nullable types</h3>

<p>Null safety eliminates that problem at the root by changing the type hierarchy.
The <code class="language-plaintext highlighter-rouge">Null</code> type still exists, but it’s no longer a subtype of all types.
Instead, the type hierarchy looks like this:</p>

<p><img src="understanding-null-safety/hierarchy-after.png" width="344"></p>

<p>Since <code class="language-plaintext highlighter-rouge">Null</code> is no longer a subtype, no type except the special <code class="language-plaintext highlighter-rouge">Null</code> class
permits the value <code class="language-plaintext highlighter-rouge">null</code>. We’ve made all types <em>non-nullable by default</em>. If you
have a variable of type <code class="language-plaintext highlighter-rouge">String</code>, it will always contain <em>a string</em>. There,
we’ve fixed all null reference errors.</p>

<p>If we didn’t think <code class="language-plaintext highlighter-rouge">null</code> was useful at all, we could stop here. But <code class="language-plaintext highlighter-rouge">null</code> is
useful, so we still need a way to handle it. Optional parameters are a good
illustrative case. Consider this null safe Dart code:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="n">makeCoffee</span><span class="o">(</span><span class="kt">String</span> <span class="n">coffee</span><span class="o">,</span> <span class="o">[</span><span class="kt">String</span><span class="o">?</span> <span class="n">dairy</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">dairy</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">'</span><span class="si">$coffee</span><span class="s"> with </span><span class="si">$dairy</span><span class="s">'</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">'Black </span><span class="si">$coffee</span><span class="s">'</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here, we want to allow the <code class="language-plaintext highlighter-rouge">dairy</code> parameter to accept any string, or the value
<code class="language-plaintext highlighter-rouge">null</code>, but nothing else. To express that, we give <code class="language-plaintext highlighter-rouge">dairy</code> a <em>nullable type</em> by
slapping <code class="language-plaintext highlighter-rouge">?</code> at the end of the underlying base type <code class="language-plaintext highlighter-rouge">String</code>. Under the hood,
this is essentially defining a <a href="https://en.wikipedia.org/wiki/Union_type">union</a> of the underlying type and the <code class="language-plaintext highlighter-rouge">Null</code>
type. So <code class="language-plaintext highlighter-rouge">String?</code> would be a shorthand for <code class="language-plaintext highlighter-rouge">String|Null</code> if Dart had
full-featured union types.</p>

<h3 id="using-nullable-types">
<a class="anchor" href="#using-nullable-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using nullable types</h3>

<p>If you have an expression with a nullable type, what can you do with the result?
Since our principle is safe by default, the answer is not much. We can’t let you
call methods of the underlying type on it because those might fail if the value
is <code class="language-plaintext highlighter-rouge">null</code>:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Hypothetical unsound null safety:</span>
<span class="n">bad</span><span class="o">(</span><span class="kt">String</span><span class="o">?</span> <span class="n">maybeString</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">print</span><span class="o">(</span><span class="n">maybeString</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">main</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">bad</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This would crash if we let you run it. The only methods and properties we can
safely let you access are ones defined by both the underlying type and the
<code class="language-plaintext highlighter-rouge">Null</code> class. That’s just <code class="language-plaintext highlighter-rouge">toString()</code>, <code class="language-plaintext highlighter-rouge">==</code>, and <code class="language-plaintext highlighter-rouge">hashCode</code>. So you can use
nullable types as map keys, store them in sets, compare them to other values,
and use them in string interpolation, but that’s about it.</p>

<p>How do they interact with non-nullable types? It’s always safe to pass a
<em>non</em>-nullable type to something expecting a nullable type. If a function
accepts <code class="language-plaintext highlighter-rouge">String?</code> then passing a <code class="language-plaintext highlighter-rouge">String</code> is allowed because it won’t cause any
problems. We model this by making every nullable type a supertype of its
underlying type. You can also safely pass <code class="language-plaintext highlighter-rouge">null</code> to something expecting a nullable type, so
<code class="language-plaintext highlighter-rouge">Null</code> is also a subtype of every nullable type:</p>

<p><img src="understanding-null-safety/nullable-hierarchy.png" width="235"></p>

<p>But going the other direction and passing a nullable type to something expecting
the underlying non-nullable type is unsafe. Code that expects a <code class="language-plaintext highlighter-rouge">String</code> may
call <code class="language-plaintext highlighter-rouge">String</code> methods on the value. If you pass a <code class="language-plaintext highlighter-rouge">String?</code> to it, <code class="language-plaintext highlighter-rouge">null</code> could
flow in and that could fail:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Hypothetical unsound null safety:</span>
<span class="n">requireStringNotNull</span><span class="o">(</span><span class="kt">String</span> <span class="n">definitelyString</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">print</span><span class="o">(</span><span class="n">definitelyString</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">main</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">String</span><span class="o">?</span> <span class="n">maybeString</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// Or not!</span>
  <span class="n">requireStringNotNull</span><span class="o">(</span><span class="n">maybeString</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This program is not safe and we shouldn’t allow it. However, Dart has always had
this thing called <em>implicit downcasts</em>. If you, for example, pass a value of
type <code class="language-plaintext highlighter-rouge">Object</code> to a function expecting an <code class="language-plaintext highlighter-rouge">String</code>, the type checker allows it:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Without null safety:</span>
<span class="n">requireStringNotObject</span><span class="o">(</span><span class="kt">String</span> <span class="n">definitelyString</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">print</span><span class="o">(</span><span class="n">definitelyString</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">main</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">Object</span> <span class="n">maybeString</span> <span class="o">=</span> <span class="s">'it is'</span><span class="o">;</span>
  <span class="n">requireStringNotObject</span><span class="o">(</span><span class="n">maybeString</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>To maintain soundness, the compiler silently inserts an <code class="language-plaintext highlighter-rouge">as String</code> cast on the
argument to <code class="language-plaintext highlighter-rouge">requireStringNotObject()</code>. That cast could fail and throw an
exception at runtime, but at compile time, Dart says this is OK. Since
non-nullable types are modeled as subtypes of nullable types, implicit downcasts
would let you pass a <code class="language-plaintext highlighter-rouge">String?</code> to something expecting a <code class="language-plaintext highlighter-rouge">String</code>. Allowing that
would violate our goal of being safe by default. So with null safety we are
removing implicit downcasts entirely.</p>

<p>This makes the call to <code class="language-plaintext highlighter-rouge">requireStringNotNull()</code> produce a compile error, which
is what you want. But it also means <em>all</em> implicit downcasts become compile
errors, including the call to <code class="language-plaintext highlighter-rouge">requireStringNotObject()</code>. You’ll have to add the
explicit downcast yourself:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="n">requireStringNotObject</span><span class="o">(</span><span class="kt">String</span> <span class="n">definitelyString</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">print</span><span class="o">(</span><span class="n">definitelyString</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">main</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">Object</span> <span class="n">maybeString</span> <span class="o">=</span> <span class="s">'it is'</span><span class="o">;</span>
  <span class="n">requireStringNotObject</span><span class="o">(</span><span class="n">maybeString</span> <span class="k">as</span> <span class="kt">String</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We think this is an overall good change. Our impression is that most users never
liked implicit downcasts. In particular, you may have been burned by this
before:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Without null safety:</span>
<span class="kt">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">filterEvens</span><span class="o">(</span><span class="kt">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">ints</span><span class="o">.</span><span class="na">where</span><span class="o">((</span><span class="n">n</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">n</span><span class="o">.</span><span class="na">isEven</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Spot the bug? The <code class="language-plaintext highlighter-rouge">.where()</code> method is lazy, so it returns an <code class="language-plaintext highlighter-rouge">Iterable</code>, not a
<code class="language-plaintext highlighter-rouge">List</code>. This program compiles but then throws an exception at runtime when it
tries to cast that <code class="language-plaintext highlighter-rouge">Iterable</code> to the <code class="language-plaintext highlighter-rouge">List</code> type that <code class="language-plaintext highlighter-rouge">filterEvens</code> declares it
returns. With the removal of implicit downcasts, this becomes a compile error.</p>

<p>Where were we? Right, OK, so it’s as if we’ve taken the universe of types in
your program and split them into two halves:</p>

<p><img src="understanding-null-safety/bifurcate.png" width="668"></p>

<p>There is a region of non-nullable types. Those types let you access all of the
interesting methods, but can never ever contain <code class="language-plaintext highlighter-rouge">null</code>. And then there is a
parallel family of all of the corresponding nullable types. Those permit <code class="language-plaintext highlighter-rouge">null</code>,
but you can’t do much with them. We let values flow from the non-nullable side
to the nullable side because doing so is safe, but not the other direction.</p>

<p>That seems like nullable types are basically useless. They have no methods and
you can’t get away from them. Don’t worry, we have a whole suite of features to
help you move values from the nullable half over to the other side that we will
get to soon.</p>

<h3 id="top-and-bottom">
<a class="anchor" href="#top-and-bottom" aria-hidden="true"><span class="octicon octicon-link"></span></a>Top and bottom</h3>

<p>This section is a little esoteric. You can mostly skip it, except for two
bullets at the very end, unless you’re into type system stuff. Imagine all the
types in your program with edges between ones that are subtypes and supertypes
of each other. If you were to draw it, like the diagrams in this doc, it would
form a huge directed graph with supertypes like <code class="language-plaintext highlighter-rouge">Object</code> near the top and leaf
classes like your own types near the bottom.</p>

<p>If that directed graph comes to a point at the top where there is a single type
that is the supertype (directly or indirectly), that type is called the <em>top
type</em>. Likewise, if there is a weird type at that bottom that is a subtype of
every type, you have a <em>bottom type</em>. (In this case, your directed graph is a
<a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice.</a>)</p>

<p>It’s convenient if your type system has a top and bottom type, because it means
that type-level operations like least upper bound (which type inference uses to
figure out the type of a conditional expression based on the types of its two
branches) can always produce a type. Before null safety, <code class="language-plaintext highlighter-rouge">Object</code> was Dart’s top
type and <code class="language-plaintext highlighter-rouge">Null</code> was its bottom type.</p>

<p>Since <code class="language-plaintext highlighter-rouge">Object</code> is non-nullable now, it is no longer a top type. <code class="language-plaintext highlighter-rouge">Null</code> is not a
subtype of it. Dart has no <em>named</em> top type. If you need a top type, you want
<code class="language-plaintext highlighter-rouge">Object?</code>. Likewise, <code class="language-plaintext highlighter-rouge">Null</code> is no longer the bottom type. If it was, everything
would still be nullable. Instead, we’ve added a new bottom type named <code class="language-plaintext highlighter-rouge">Never</code>:</p>

<p><img src="understanding-null-safety/top-and-bottom.png" width="360"></p>

<p>In practice, this means:</p>

<ul>
  <li>
    <p>If you want to indicate that you allow a value of any type, use <code class="language-plaintext highlighter-rouge">Object?</code>
instead of <code class="language-plaintext highlighter-rouge">Object</code>. In fact, it becomes pretty unusual to use <code class="language-plaintext highlighter-rouge">Object</code>
since that type means “could be any possible value except this one weirdly
prohibited value <code class="language-plaintext highlighter-rouge">null</code>”.</p>
  </li>
  <li>
    <p>On the rare occasion that you need a bottom type, use <code class="language-plaintext highlighter-rouge">Never</code> instead of
<code class="language-plaintext highlighter-rouge">Null</code>. If you don’t know if you need a bottom type, you probably don’t.</p>
  </li>
</ul>

<h2 id="ensuring-correctness">
<a class="anchor" href="#ensuring-correctness" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ensuring correctness</h2>

<p>We divided the universe of types into nullable and non-nullable halves. In order
to maintain soundness and our principle that you can never get a null reference
error at runtime unless you ask for it, we need to guarantee that <code class="language-plaintext highlighter-rouge">null</code> never
appears in any type on the non-nullable side.</p>

<p>Getting rid of implicit downcasts and removing <code class="language-plaintext highlighter-rouge">Null</code> as a bottom type covers
all of the main places that types flow through a program across assignments and
from arguments into parameters on function calls. The main remaining places
where <code class="language-plaintext highlighter-rouge">null</code> can sneak in are when a variable first comes into being and when
you leave a function. So there are some additional compile errors:</p>

<h3 id="invalid-returns">
<a class="anchor" href="#invalid-returns" aria-hidden="true"><span class="octicon octicon-link"></span></a>Invalid returns</h3>

<p>If a function has a non-nullable return type, then every path through the
function must reach a <code class="language-plaintext highlighter-rouge">return</code> statement that returns a value. Before null
safety, Dart was pretty lax about missing returns. For example:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Without null safety:</span>
<span class="kt">String</span> <span class="nf">missingReturn</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// No return.</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If you analyzed this, you got a gentle <em>hint</em> that <em>maybe</em> you forgot a return,
but if not, no big deal. That’s because if execution reaches the end of a
function body then Dart implicitly returns <code class="language-plaintext highlighter-rouge">null</code>. Since every type is nullable,
<em>technically</em> this function is safe, even though it’s probably not what you
want.</p>

<p>With sound non-nullable types, this program is flat out wrong and unsafe. Under
null safety, you get a compile error if a function with a non-nullable return
type doesn’t reliably return a value. By “reliably”, I mean that the language
analyzes all of the control flow paths through the function. As long as they all
return something, it is satisfied. The analysis is pretty smart, so even this
function is OK:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">String</span> <span class="nf">alwaysReturns</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">'zero'</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="n">ArgumentError</span><span class="o">(</span><span class="s">'Negative values not allowed.'</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="s">'big'</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We’ll dive more deeply into the new flow analysis in the next section.</p>

<h3 id="uninitialized-variables">
<a class="anchor" href="#uninitialized-variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Uninitialized variables</h3>

<p>When you declare a variable, if you don’t give it an explicit initializer, Dart
default initializes the variable with <code class="language-plaintext highlighter-rouge">null</code>. That’s convenient, but obviously
totally unsafe if the variable’s type is non-nullable. So we have to tighten
things up for non-nullable variables:</p>

<ul>
  <li>
    <p><strong>Top level variable and static field declarations must have an
initializer.</strong> Since these can be accessed and assigned from anywhere in the
program, it’s impossible for the compiler to guarantee that the variable has
been given a value before it gets used. The only safe option is to require
the declaration itself to have an initializing expression that produces a
value of the right type:</p>

    <div class="language-dart highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">int</span> <span class="n">topLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">SomeClass</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="kt">int</span> <span class="n">staticField</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Instance fields must either have an initializer at the declaration, use an
initializing formal, or be initialized in the constructor’s initialization
list.</strong> That’s a lot of jargon. Here are the examples:</p>

    <div class="language-dart highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">SomeClass</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">atDeclaration</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">initializingFormal</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">initializationList</span><span class="o">;</span>

  <span class="n">SomeClass</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">initializingFormal</span><span class="o">)</span>
      <span class="o">:</span> <span class="n">initializationList</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>    </div>

    <p>In other words, as long as the field has a value before you reach the
constructor body, you’re good.</p>
  </li>
  <li>
    <p>Local variables are the most flexible case. A non-nullable local variable
<em>doesn’t</em> need to have an initializer. This is perfectly fine:</p>

    <div class="language-dart highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">int</span> <span class="nf">tracingFibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">tracingFibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">tracingFibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="n">print</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>    </div>

    <p>The rule is only that <strong>a local variable must be <em>definitely assigned</em>
before it is used.</strong> We get to rely on the new flow analysis I alluded to
for this as well. As long as every path to a variable’s use initializes it
first, the use is OK.</p>
  </li>
  <li>
    <p><strong>Optional parameters must have a default value.</strong> If you don’t pass an
argument for an optional positional or named parameter, then the language
fills it in with the default value. If you don’t specify a default value,
the <em>default</em> default value is <code class="language-plaintext highlighter-rouge">null</code>, and that doesn’t fly if the parameter’s
type is non-nullable.</p>

    <p>So, if you want a parameter to be optional, you need to either make it
nullable or specify a valid non-<code class="language-plaintext highlighter-rouge">null</code> default value.</p>
  </li>
</ul>

<p>These restrictions sound onerous, but they aren’t too bad in practice. They are
very similar to the existing restrictions around <code class="language-plaintext highlighter-rouge">final</code> variables and you’ve
likely been working with those for years without even really noticing. Also,
remember that these only apply to <em>non-nullable</em> variables. You can always make
the type nullable and then get the default initialization to <code class="language-plaintext highlighter-rouge">null</code>.</p>

<p>Even so, the rules do cause friction. Fortunately, we have a suite of new
language features to lubricate the most common patterns where these new
limitations slow you down. First, though, it’s time to talk about flow analysis.</p>

<h2 id="flow-analysis">
<a class="anchor" href="#flow-analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Flow analysis</h2>

<p><a href="https://en.wikipedia.org/wiki/Control_flow_analysis">Control flow analysis</a> has been around in compilers for years. It’s mostly
hidden from users and used during compiler optimization, but some newer
languages have started to use the same techniques for visible language features.
Dart already has a dash of flow analysis in the form of <em>type promotion</em>:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// With (or without) null safety:</span>
<span class="kt">bool</span> <span class="nf">isEmptyList</span><span class="p">(</span><span class="kt">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">object</span> <span class="k">is</span> <span class="kt">List</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">object</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">;</span> <span class="c1">// &lt;-- OK!</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note how on the marked line, we can call <code class="language-plaintext highlighter-rouge">isEmpty</code> on <code class="language-plaintext highlighter-rouge">object</code>. That method is
defined on <code class="language-plaintext highlighter-rouge">List</code>, not <code class="language-plaintext highlighter-rouge">Object</code>. This works because the type checker looks at
all of the <code class="language-plaintext highlighter-rouge">is</code> expressions and the control flow paths in the program. If the
body of some control flow construct only executes when a certain <code class="language-plaintext highlighter-rouge">is</code> expression
on a variable is true, then inside that body the variable’s type is “promoted”
to the tested type.</p>

<p>In the example here, the then branch of the <code class="language-plaintext highlighter-rouge">if</code> statement only runs when
<code class="language-plaintext highlighter-rouge">object</code> actually contains a list. Therefore, Dart promotes <code class="language-plaintext highlighter-rouge">object</code> to type
<code class="language-plaintext highlighter-rouge">List</code> instead of its declared type <code class="language-plaintext highlighter-rouge">Object</code>. This is a handy feature, but it’s
pretty limited. Prior to null safety, the following functionally identical
program did not work:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Without null safety:</span>
<span class="kt">bool</span> <span class="nf">isEmptyList</span><span class="p">(</span><span class="kt">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">object</span> <span class="k">is</span><span class="o">!</span> <span class="kt">List</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">object</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">;</span> <span class="c1">// &lt;-- Error!</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Again, you can only reach the <code class="language-plaintext highlighter-rouge">.isEmpty</code> call when <code class="language-plaintext highlighter-rouge">object</code> contains a list, so
this program is dynamically correct. But the type promotion rules were not smart
enough to see that the <code class="language-plaintext highlighter-rouge">return</code> statement means the second statement can only be
reached when <code class="language-plaintext highlighter-rouge">object</code> is a list.</p>

<p>For null safety, we’ve taken this limited analysis and made it <a href="https://github.com/dart-lang/language/blob/master/resources/type-system/flow-analysis.md">much more
powerful in several ways.</a></p>

<h3 id="reachability-analysis">
<a class="anchor" href="#reachability-analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reachability analysis</h3>

<p>First off, we fixed the <a href="https://github.com/dart-lang/sdk/issues/18921">long-standing complaint</a> that type promotion
isn’t smart about early returns and other unreachable code paths. When analyzing
a function, it now takes into account <code class="language-plaintext highlighter-rouge">return</code>, <code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">throw</code>, and any other
way execution might terminate early in a function. Under null safety, this function:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">bool</span> <span class="nf">isEmptyList</span><span class="p">(</span><span class="kt">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">object</span> <span class="k">is</span><span class="o">!</span> <span class="kt">List</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">object</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Is now perfectly valid. Since the <code class="language-plaintext highlighter-rouge">if</code> statement will exit the function when
<code class="language-plaintext highlighter-rouge">object</code> is <em>not</em> a <code class="language-plaintext highlighter-rouge">List</code>, Dart promotes <code class="language-plaintext highlighter-rouge">object</code> to be <code class="language-plaintext highlighter-rouge">List</code> on the second
statement. This is a really nice improvement that helps a lot of Dart code, even
stuff not related to nullability.</p>

<h3 id="never-for-unreachable-code">
<a class="anchor" href="#never-for-unreachable-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Never for unreachable code</h3>

<p>You can also <em>program</em> this reachability analysis. The new bottom type <code class="language-plaintext highlighter-rouge">Never</code>
has no values. (What kind of value is simultaneously a <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">bool</code>, and
<code class="language-plaintext highlighter-rouge">int</code>?) So what does it mean for an expression to have type <code class="language-plaintext highlighter-rouge">Never</code>? It means
that expression can never successfully finish evaluating. It must throw an
exception, abort, or otherwise ensure that the surrounding code expecting the
result of the expression never runs.</p>

<p>In fact, according to the language, the static type of a <code class="language-plaintext highlighter-rouge">throw</code> expression is
<code class="language-plaintext highlighter-rouge">Never</code>. The type <code class="language-plaintext highlighter-rouge">Never</code> is declared in the core libraries and you can use it
as a type annotation. Maybe you have a helper function to make it easier to
throw a certain kind of exception:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">Never</span> <span class="nf">wrongType</span><span class="p">(</span><span class="kt">String</span> <span class="n">type</span><span class="o">,</span> <span class="kt">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">throw</span> <span class="n">ArgumentError</span><span class="o">(</span><span class="s">'Expected </span><span class="si">$type</span><span class="s">, but was </span><span class="si">${value.runtimeType}</span><span class="s">.'</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>You might use it like so:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">;</span>

  <span class="kt">bool</span> <span class="kd">operator</span> <span class="o">==(</span><span class="kt">Object</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">other</span> <span class="k">is</span><span class="o">!</span> <span class="n">Point</span><span class="o">)</span> <span class="n">wrongType</span><span class="o">(</span><span class="s">'Point'</span><span class="o">,</span> <span class="n">other</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="na">x</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// Constructor and hashCode...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This program analyzes without error. Notice that the last line of the <code class="language-plaintext highlighter-rouge">==</code>
method accesses <code class="language-plaintext highlighter-rouge">.x</code> and <code class="language-plaintext highlighter-rouge">.y</code> on <code class="language-plaintext highlighter-rouge">other</code>. It has been promoted to <code class="language-plaintext highlighter-rouge">Point</code> even
though the function doesn’t have any <code class="language-plaintext highlighter-rouge">return</code> or <code class="language-plaintext highlighter-rouge">throw</code>. The control flow
analysis knows that the declared type of <code class="language-plaintext highlighter-rouge">wrongType()</code> is <code class="language-plaintext highlighter-rouge">Never</code> which means
the then branch of the <code class="language-plaintext highlighter-rouge">if</code> statement <em>must</em> abort somehow. Since the second
statement can only be reached when <code class="language-plaintext highlighter-rouge">other</code> is a <code class="language-plaintext highlighter-rouge">Point</code>, Dart promotes it.</p>

<p>In other words, using <code class="language-plaintext highlighter-rouge">Never</code> in your own APIs lets you extend Dart’s
reachability analysis.</p>

<h3 id="definite-assignment-analysis">
<a class="anchor" href="#definite-assignment-analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Definite assignment analysis</h3>

<p>I mentioned this one briefly with local variables. Dart needs to ensure a
non-nullable local variable is always initialized before it is read. We use
<em>definite assignment analysis</em> to be as flexible about that as possible. The
language analyzes each function body and tracks the assignments to local
variables and parameters through all control flow paths. As long as the variable
is assigned on every path that reaches some use of a variable, the variable is
considered initialized. This lets you declare a variable with no initializer and
then initialize it afterwards using complex control flow, even when the variable
has a non-nullable type.</p>

<p>We also use definite assignment analysis to make <em>final</em> variables more
flexible. Before null safety, it can be difficult to use <code class="language-plaintext highlighter-rouge">final</code> for local
variables if you need to initialize them in any sort of interesting way:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">int</span> <span class="nf">tracingFibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">tracingFibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">tracingFibonacci</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="n">print</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This would be an error since the <code class="language-plaintext highlighter-rouge">result</code> variable is <code class="language-plaintext highlighter-rouge">final</code> but has no
initializer. With the smarter flow analysis under null safety, this program is
fine. The analysis can tell that <code class="language-plaintext highlighter-rouge">result</code> is definitely initialized exactly once
on every control flow path, so the constraints for marking a variable <code class="language-plaintext highlighter-rouge">final</code>
are satisfied.</p>

<h3 id="type-promotion-on-null-checks">
<a class="anchor" href="#type-promotion-on-null-checks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Type promotion on null checks</h3>

<p>The smarter flow analysis helps lots of Dart code, even code not related to
nullability. But it’s not a coincidence that we’re making these changes now. We
have partitioned types into nullable and non-nullable sets. If you have a value
of a nullable type, you can’t really <em>do</em> anything useful with it. In cases
where the value <em>is</em> <code class="language-plaintext highlighter-rouge">null</code>, that restriction is good. It’s preventing you from
crashing.</p>

<p>But if the value isn’t <code class="language-plaintext highlighter-rouge">null</code>, it would be good to be able to move it over to
the non-nullable side so you can call methods on it. Flow analysis is one of the
primary ways to do this for local variables and parameters. We’ve extended type
promotion to also look at <code class="language-plaintext highlighter-rouge">== null</code> and <code class="language-plaintext highlighter-rouge">!= null</code> expressions.</p>

<p>If you check a local variable with nullable type to see if it is not <code class="language-plaintext highlighter-rouge">null</code>, 
Dart then promotes the variable to the underlying non-nullable type:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">String</span> <span class="nf">makeCommand</span><span class="p">(</span><span class="kt">String</span> <span class="n">executable</span><span class="o">,</span> <span class="o">[</span><span class="kt">List</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;?</span> <span class="n">arguments</span><span class="o">])</span> <span class="o">{</span>
  <span class="kd">var</span> <span class="n">result</span> <span class="o">=</span> <span class="n">executable</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">arguments</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s">' '</span> <span class="o">+</span> <span class="n">arguments</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">' '</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">arguments</code> has a nullable type. Normally, that prohibits you from calling
<code class="language-plaintext highlighter-rouge">.join()</code> on it. But because we have guarded that call in an <code class="language-plaintext highlighter-rouge">if</code> statement that
checks to ensure the value is not <code class="language-plaintext highlighter-rouge">null</code>, Dart promotes it from <code class="language-plaintext highlighter-rouge">List&lt;String&gt;?</code>
to <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code> and lets you call methods on it or pass it to functions that
expect non-nullable lists.</p>

<p>This sounds like a fairly minor thing, but this flow-based promotion on null
checks is what makes most existing Dart code work under null safety. Most Dart
code <em>is</em> dynamically correct and does avoid throwing null reference errors by
checking for <code class="language-plaintext highlighter-rouge">null</code> before calling methods. The new flow analysis on null checks
turns that <em>dynamic</em> correctness into provable <em>static</em> correctness.</p>

<p>It also, of course, works with the smarter analysis we do for reachability. The
above function can be written just as well as:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">String</span> <span class="nf">makeCommand</span><span class="p">(</span><span class="kt">String</span> <span class="n">executable</span><span class="o">,</span> <span class="o">[</span><span class="kt">List</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;?</span> <span class="n">arguments</span><span class="o">])</span> <span class="o">{</span>
  <span class="kd">var</span> <span class="n">result</span> <span class="o">=</span> <span class="n">executable</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">arguments</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="s">' '</span> <span class="o">+</span> <span class="n">arguments</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">' '</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The language is also smarter about what kinds of expressions cause promotion. An
explicit <code class="language-plaintext highlighter-rouge">== null</code> or <code class="language-plaintext highlighter-rouge">!= null</code> of course works. But explicit casts using <code class="language-plaintext highlighter-rouge">as</code>,
or assignments, or the postfix <code class="language-plaintext highlighter-rouge">!</code> operator we’ll get to soon also cause
promotion. The general goal is that if the code is dynamically correct and it’s
reasonable to figure that out statically, the analysis should be clever enough
to do so.</p>

<p>Note that type promotion only works on local variables,
not on fields or top-level variables.
For more information about working with non-local variables,
see <a href="#working-with-nullable-fields">Working with nullable fields</a>.</p>

<h3 id="unnecessary-code-warnings">
<a class="anchor" href="#unnecessary-code-warnings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unnecessary code warnings</h3>

<p>Having smarter reachability analysis and knowing where <code class="language-plaintext highlighter-rouge">null</code> can flow through
your program helps ensure that you <em>add</em> code to handle <code class="language-plaintext highlighter-rouge">null</code>. But we can also
use that same analysis to detect code that you <em>don’t</em> need. Before null safety,
if you wrote something like:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">String</span> <span class="nf">checkList</span><span class="p">(</span><span class="kt">List</span><span class="o">&lt;</span><span class="kt">Object</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">?.</span><span class="na">isEmpty</span> <span class="o">??</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">'Got nothing'</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="s">'Got something'</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Dart had no way of knowing if that null-aware <code class="language-plaintext highlighter-rouge">?.</code> operator is useful or not.
For all it knows, you could pass <code class="language-plaintext highlighter-rouge">null</code> to the function. But in null safe Dart,
if you have annotated that function with the now non-nullable <code class="language-plaintext highlighter-rouge">List</code> type, then
it knows <code class="language-plaintext highlighter-rouge">list</code> will never be <code class="language-plaintext highlighter-rouge">null</code>. That implies the <code class="language-plaintext highlighter-rouge">?.</code> will never do
anything useful and you can and should just use <code class="language-plaintext highlighter-rouge">.</code>.</p>

<p>To help you simplify your code, we’ve added warnings for unnecessary code like
this now that the static analysis is precise enough to detect it. Using a
null-aware operator or even a check like <code class="language-plaintext highlighter-rouge">== null</code> or <code class="language-plaintext highlighter-rouge">!= null</code> on a
non-nullable type gets reported as a warning.</p>

<p>And, of course, this plays with non-nullable type promotion too. Once a
variable has been promoted to a non-nullable type, you get a warning if you
redundantly check it again for <code class="language-plaintext highlighter-rouge">null</code>:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">String</span> <span class="nf">checkList</span><span class="p">(</span><span class="kt">List</span><span class="o">&lt;</span><span class="kt">Object</span><span class="o">&gt;?</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">list</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="s">'No list'</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">?.</span><span class="na">isEmpty</span> <span class="o">??</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">'Empty list'</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="s">'Got something'</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>You get a warning on the <code class="language-plaintext highlighter-rouge">?.</code> here because at the point that it executes, we
already know <code class="language-plaintext highlighter-rouge">list</code> cannot be <code class="language-plaintext highlighter-rouge">null</code>. The goal with these warnings is not just
to clean up pointless code. By removing <em>unneeded</em> checks for <code class="language-plaintext highlighter-rouge">null</code>, we ensure
that the remaining meaningful checks stand out. We want you to be able to look
at your code and <em>see</em> where <code class="language-plaintext highlighter-rouge">null</code> can flow.</p>

<h2 id="working-with-nullable-types">
<a class="anchor" href="#working-with-nullable-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Working with nullable types</h2>

<p>We’ve now corralled <code class="language-plaintext highlighter-rouge">null</code> into the set of nullable types. With flow analysis,
we can safely let some non-<code class="language-plaintext highlighter-rouge">null</code> values hop over the fence to the non-nullable
side where we can use them. That’s a big step, but if we stop here, the
resulting system is still painfully restrictive. Flow analysis only helps with
locals and parameters.</p>

<p>To try to regain as much of the flexibility that Dart had before null
safety—and to go beyond it on some places—we have a handful of other
new features.</p>

<h3 id="smarter-null-aware-methods">
<a class="anchor" href="#smarter-null-aware-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>Smarter null-aware methods</h3>

<p>Dart’s null aware operator <code class="language-plaintext highlighter-rouge">?.</code> is much older than null safety. The runtime
semantics state that if the receiver is <code class="language-plaintext highlighter-rouge">null</code> then the property access on the
right-hand side is skipped and the expression evaluates to <code class="language-plaintext highlighter-rouge">null</code>:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Without null safety:</span>
<span class="kt">String</span> <span class="n">notAString</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">print</span><span class="o">(</span><span class="n">notAString</span><span class="o">?.</span><span class="na">length</span><span class="o">);</span>
</code></pre></div></div>

<p>Instead of throwing an exception, this prints “null”. The null-aware operator is
a nice tool for making nullable types usable in Dart. While we can’t let you
call methods on nullable types, we can and do let you use null-aware operators
on them. The post-null safety version of the program is:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">String</span><span class="o">?</span> <span class="n">notAString</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">print</span><span class="o">(</span><span class="n">notAString</span><span class="o">?.</span><span class="na">length</span><span class="o">);</span>
</code></pre></div></div>

<p>It works just like the previous one.</p>

<p>However, if you’ve ever used null-aware operators in Dart, you’ve probably
encountered an annoyance when using them in method chains. Let’s say you want to
see if the length of a potentially absent string is an even number (not a
particularly realistic problem, I know, but work with me here):</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">String</span><span class="o">?</span> <span class="n">notAString</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">print</span><span class="o">(</span><span class="n">notAString</span><span class="o">?.</span><span class="na">length</span><span class="o">.</span><span class="na">isEven</span><span class="o">);</span>
</code></pre></div></div>

<p>Even though this program uses <code class="language-plaintext highlighter-rouge">?.</code>, it still throws an exception at runtime. The
problem is that the receiver of the <code class="language-plaintext highlighter-rouge">.isEven</code> expression is the result of the
entire <code class="language-plaintext highlighter-rouge">notAString?.length</code> expression to its left. That expression evaluates to
<code class="language-plaintext highlighter-rouge">null</code>, so we get a null reference error trying to call <code class="language-plaintext highlighter-rouge">.isEven</code>. If you’ve
ever used <code class="language-plaintext highlighter-rouge">?.</code> in Dart, you probably learned the hard way that you have to apply
the null-aware operator to <em>every</em> property or method in a chain after you use
it once:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">String</span><span class="o">?</span> <span class="n">notAString</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">print</span><span class="o">(</span><span class="n">notAString</span><span class="o">?.</span><span class="na">length</span><span class="o">?.</span><span class="na">isEven</span><span class="o">);</span>
</code></pre></div></div>

<p>This is annoying, but, worse, it obscures important information. Consider:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="n">showGizmo</span><span class="o">(</span><span class="n">Thing</span><span class="o">?</span> <span class="n">thing</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">print</span><span class="o">(</span><span class="n">thing</span><span class="o">?.</span><span class="na">doohickey</span><span class="o">?.</span><span class="na">gizmo</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here’s a question for you: Can the <code class="language-plaintext highlighter-rouge">doohickey</code> getter on <code class="language-plaintext highlighter-rouge">Thing</code> return <code class="language-plaintext highlighter-rouge">null</code>?
It looks like it <em>could</em> because you’re using <code class="language-plaintext highlighter-rouge">?.</code> on the result. But it may
just be that the second <code class="language-plaintext highlighter-rouge">?.</code> is only there to handle cases where <code class="language-plaintext highlighter-rouge">thing</code> is
<code class="language-plaintext highlighter-rouge">null</code>, not the result of <code class="language-plaintext highlighter-rouge">doohickey</code>. You can’t tell.</p>

<p>To address this, we borrowed a smart idea from C#’s design of the same feature.
When you use a null-aware operator in a method chain, if the receiver evaluates
to <code class="language-plaintext highlighter-rouge">null</code>, then <em>the entire rest of the method chain is short-circuited and
skipped</em>. This means if <code class="language-plaintext highlighter-rouge">doohickey</code> has a non-nullable return type, then you
can and should write:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="n">showGizmo</span><span class="o">(</span><span class="n">Thing</span><span class="o">?</span> <span class="n">thing</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">print</span><span class="o">(</span><span class="n">thing</span><span class="o">?.</span><span class="na">doohickey</span><span class="o">.</span><span class="na">gizmo</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In fact, you’ll get an unnecessary code warning on the second <code class="language-plaintext highlighter-rouge">?.</code> if you
don’t. If you see code like:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="n">showGizmo</span><span class="o">(</span><span class="n">Thing</span><span class="o">?</span> <span class="n">thing</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">print</span><span class="o">(</span><span class="n">thing</span><span class="o">?.</span><span class="na">doohickey</span><span class="o">?.</span><span class="na">gizmo</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then you know for certain it means that <code class="language-plaintext highlighter-rouge">doohickey</code> itself has a nullable return
type. Each <code class="language-plaintext highlighter-rouge">?.</code> corresponds to a <em>unique</em> path that can cause <code class="language-plaintext highlighter-rouge">null</code> to flow
into the method chain. This makes null-aware operators in method chains both
more terse and more precise.</p>

<p>While we were at it, we added a couple of other null-aware operators:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>

<span class="c1">// Null-aware cascade:</span>
<span class="n">receiver</span><span class="o">?..</span><span class="na">method</span><span class="o">();</span>

<span class="c1">// Null-aware index operator:</span>
<span class="n">receiver</span><span class="o">?[</span><span class="n">index</span><span class="o">];</span>
</code></pre></div></div>

<p>There isn’t a null-aware function call operator, but you can write:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Allowed with or without null safety:</span>
<span class="n">function</span><span class="o">?.</span><span class="na">call</span><span class="o">(</span><span class="n">arg1</span><span class="o">,</span> <span class="n">arg2</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="null-assertion-operator">
<a class="anchor" href="#null-assertion-operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Null assertion operator</h3>

<p>The great thing about using flow analysis to move a nullable variable to the
non-nullable side of the world is that doing so is provably safe. You get to
call methods on the previously-nullable variable without giving up any of the
safety or performance of non-nullable types.</p>

<p>But many valid uses of nullable types can’t be <em>proven</em> to be safe in a way that
pleases static analysis. For example:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety, incorrectly:</span>
<span class="kd">class</span> <span class="nc">HttpResponse</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">code</span><span class="o">;</span>
  <span class="kd">final</span> <span class="kt">String</span><span class="o">?</span> <span class="n">error</span><span class="o">;</span>

  <span class="n">HttpResponse</span><span class="o">.</span><span class="na">ok</span><span class="o">()</span>
      <span class="o">:</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">200</span><span class="o">,</span>
        <span class="n">error</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="n">HttpResponse</span><span class="o">.</span><span class="na">notFound</span><span class="o">()</span>
      <span class="o">:</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">404</span><span class="o">,</span>
        <span class="n">error</span> <span class="o">=</span> <span class="s">'Not found'</span><span class="o">;</span>

  <span class="nd">@override</span>
  <span class="kt">String</span> <span class="n">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">code</span> <span class="o">==</span> <span class="mi">200</span><span class="o">)</span> <span class="k">return</span> <span class="s">'OK'</span><span class="o">;</span>
    <span class="k">return</span> <span class="s">'ERROR </span><span class="si">$code</span><span class="s"> </span><span class="si">${error.toUpperCase()}</span><span class="s">'</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If you try to run this, you get a compile error on the call to <code class="language-plaintext highlighter-rouge">toUpperCase()</code>.
The <code class="language-plaintext highlighter-rouge">error</code> field is nullable because it won’t have a value in a successful
response. We can see by inspecting the class that we never access the <code class="language-plaintext highlighter-rouge">error</code>
message when it is <code class="language-plaintext highlighter-rouge">null</code>. But that requires understanding the relationship
between the value of <code class="language-plaintext highlighter-rouge">code</code> and the nullability of <code class="language-plaintext highlighter-rouge">error</code>. The type checker
can’t see that connection.</p>

<p>In other words, we human maintainers of the code <em>know</em> that error won’t be
<code class="language-plaintext highlighter-rouge">null</code> at the point that we use it and we need a way to assert that. Normally,
you assert types using an <code class="language-plaintext highlighter-rouge">as</code> cast, and you can do the same thing here:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">String</span> <span class="nf">toString</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">code</span> <span class="o">==</span> <span class="mi">200</span><span class="o">)</span> <span class="k">return</span> <span class="s">'OK'</span><span class="o">;</span>
  <span class="k">return</span> <span class="s">'ERROR </span><span class="si">$code</span><span class="s"> </span><span class="si">${(error as String).toUpperCase()}</span><span class="s">'</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Casting <code class="language-plaintext highlighter-rouge">error</code> to the non-nullable <code class="language-plaintext highlighter-rouge">String</code> type will throw a runtime exception
if the cast fails. Otherwise, it gives us a non-nullable string that we can then
call methods on.</p>

<p>“Casting away nullability” comes up often enough that we have a new shorthand
syntax. A postfix exclamation mark (<code class="language-plaintext highlighter-rouge">!</code>) takes the expression on the left and
casts it to its underlying non-nullable type. So the above function is
equivalent to:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">String</span> <span class="nf">toString</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">code</span> <span class="o">==</span> <span class="mi">200</span><span class="o">)</span> <span class="k">return</span> <span class="s">'OK'</span><span class="o">;</span>
  <span class="k">return</span> <span class="s">'ERROR </span><span class="si">$code</span><span class="s"> </span><span class="si">${error!.toUpperCase()}</span><span class="s">'</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This one-character “bang operator” is particularly handy when the underlying
type is verbose. It would be really annoying to have to write <code class="language-plaintext highlighter-rouge">as
Map&lt;TransactionProviderFactory, List&lt;Set&lt;ResponseFilter&gt;&gt;&gt;</code> just to cast away a
single <code class="language-plaintext highlighter-rouge">?</code> from some type.</p>

<p>Of course, like any cast, using <code class="language-plaintext highlighter-rouge">!</code> comes with a loss of static safety. The cast
must be checked at runtime to preserve soundness and it may fail and throw an
exception. But you have control over where these casts are inserted, and you can
always see them by looking through your code.</p>

<h3 id="late-variables">
<a class="anchor" href="#late-variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Late variables</h3>

<p>The most common place where the type checker cannot prove the safety of code is
around top-level variables and fields. Here is an example:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety, incorrectly:</span>
<span class="kd">class</span> <span class="nc">Coffee</span> <span class="o">{</span>
  <span class="kt">String</span> <span class="n">_temperature</span><span class="o">;</span>

  <span class="kt">void</span> <span class="n">heat</span><span class="o">()</span> <span class="o">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s">'hot'</span><span class="o">;</span> <span class="o">}</span>
  <span class="kt">void</span> <span class="n">chill</span><span class="o">()</span> <span class="o">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s">'iced'</span><span class="o">;</span> <span class="o">}</span>

  <span class="kt">String</span> <span class="n">serve</span><span class="o">()</span> <span class="o">=&gt;</span> <span class="n">_temperature</span> <span class="o">+</span> <span class="s">' coffee'</span><span class="o">;</span>
<span class="o">}</span>

<span class="n">main</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">var</span> <span class="n">coffee</span> <span class="o">=</span> <span class="n">Coffee</span><span class="o">();</span>
  <span class="n">coffee</span><span class="o">.</span><span class="na">heat</span><span class="o">();</span>
  <span class="n">coffee</span><span class="o">.</span><span class="na">serve</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here, the <code class="language-plaintext highlighter-rouge">heat()</code> method is called before <code class="language-plaintext highlighter-rouge">serve()</code>. That means <code class="language-plaintext highlighter-rouge">_temperature</code>
will be initialized to a non-null value before it is used. But it’s not feasible
for a static analysis to determine that. (It might be possible for a trivial
example like this one, but the general case of trying to track the state of each
instance of a class is intractable.)</p>

<p>Because the type checker can’t analyze uses of fields and top-level variables,
it has a conservative rule that non-nullable fields have to be initialized
either at their declaration (or in the constructor initialization list for
instance fields). So Dart reports a compile error on this class.</p>

<p>You can fix the error by making the field nullable and then using null assertion
operators on the uses:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">Coffee</span> <span class="o">{</span>
  <span class="kt">String</span><span class="o">?</span> <span class="n">_temperature</span><span class="o">;</span>

  <span class="kt">void</span> <span class="n">heat</span><span class="o">()</span> <span class="o">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s">'hot'</span><span class="o">;</span> <span class="o">}</span>
  <span class="kt">void</span> <span class="n">chill</span><span class="o">()</span> <span class="o">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s">'iced'</span><span class="o">;</span> <span class="o">}</span>

  <span class="kt">String</span> <span class="n">serve</span><span class="o">()</span> <span class="o">=&gt;</span> <span class="n">_temperature</span><span class="o">!</span> <span class="o">+</span> <span class="s">' coffee'</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This works fine. But it sends a confusing signal to the maintainer of the class.
By marking <code class="language-plaintext highlighter-rouge">_temperature</code> nullable, you imply that <code class="language-plaintext highlighter-rouge">null</code> is a useful,
meaningful value for that field. But that’s not the intent. The <code class="language-plaintext highlighter-rouge">_temperature</code>
field should never be <em>observed</em> in its <code class="language-plaintext highlighter-rouge">null</code> state.</p>

<p>To handle the common pattern of state with delayed initialization, we’ve added a
new modifier, <code class="language-plaintext highlighter-rouge">late</code>. You can use it like this:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">Coffee</span> <span class="o">{</span>
  <span class="kd">late</span> <span class="kt">String</span> <span class="n">_temperature</span><span class="o">;</span>

  <span class="kt">void</span> <span class="n">heat</span><span class="o">()</span> <span class="o">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s">'hot'</span><span class="o">;</span> <span class="o">}</span>
  <span class="kt">void</span> <span class="n">chill</span><span class="o">()</span> <span class="o">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s">'iced'</span><span class="o">;</span> <span class="o">}</span>

  <span class="kt">String</span> <span class="n">serve</span><span class="o">()</span> <span class="o">=&gt;</span> <span class="n">_temperature</span> <span class="o">+</span> <span class="s">' coffee'</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that the <code class="language-plaintext highlighter-rouge">_temperature</code> field has a non-nullable type, but is not
initialized. Also, there’s no explicit null assertion when it’s used. There are
a few models you can apply to the semantics of <code class="language-plaintext highlighter-rouge">late</code>, but I think of it like
this: The <code class="language-plaintext highlighter-rouge">late</code> modifier means “enforce this variable’s constraints at runtime
instead of at compile time”. It’s almost like the word “late” describes <em>when</em>
it enforces the variable’s guarantees.</p>

<p>In this case, since the field is not definitely initialized, every time the
field is read, a runtime check is inserted to make sure it has been assigned a
value. If it hasn’t, an exception is thrown. Giving the variable the type
<code class="language-plaintext highlighter-rouge">String</code> means “you should never see me with a value other than a string” and
the <code class="language-plaintext highlighter-rouge">late</code> modifier means “verify that at runtime”.</p>

<p>In some ways, the <code class="language-plaintext highlighter-rouge">late</code> modifier is more “magical” than using <code class="language-plaintext highlighter-rouge">?</code> because any
use of the field could fail, and there isn’t anything textually visible at the
use site. But you <em>do</em> have to write <code class="language-plaintext highlighter-rouge">late</code> at the declaration to get this
behavior, and our belief is that seeing the modifier there is explicit enough
for this to be maintainable.</p>

<p>In return, you get better static safety than using a nullable type. Because the
field’s type is non-nullable now, it is a <em>compile</em> error to try to assign
<code class="language-plaintext highlighter-rouge">null</code> or a nullable <code class="language-plaintext highlighter-rouge">String</code> to the field. The <code class="language-plaintext highlighter-rouge">late</code> modifier lets you <em>defer</em>
initialization, but still prohibits you from treating it like a nullable
variable.</p>

<h3 id="lazy-initialization">
<a class="anchor" href="#lazy-initialization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Lazy initialization</h3>

<p>The <code class="language-plaintext highlighter-rouge">late</code> modifier has some other special powers too. It may seem paradoxical,
but you can use <code class="language-plaintext highlighter-rouge">late</code> on a field that has an initializer:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">Weather</span> <span class="o">{</span>
  <span class="kd">late</span> <span class="kt">int</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="n">_readThermometer</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>When you do this, the initializer becomes <em>lazy</em>. Instead of running it as soon
as the instance is constructed, it is deferred and run lazily the first time the
field is accessed. In other words, it works exactly like an initializer on a
top-level variable or static field. This can be handy when the initialization
expression is costly and may not be needed.</p>

<p>Running the initializer lazily gives you an extra bonus when you use <code class="language-plaintext highlighter-rouge">late</code> on
an instance field. Usually instance field initializers cannot access <code class="language-plaintext highlighter-rouge">this</code>
because you don’t have access to the new object until all field initializers
have completed. But with a <code class="language-plaintext highlighter-rouge">late</code> field, that’s no longer true, so you <em>can</em>
access <code class="language-plaintext highlighter-rouge">this</code>, call methods, or access fields on the instance.</p>

<h3 id="late-final-variables">
<a class="anchor" href="#late-final-variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Late final variables</h3>

<p>You can also combine <code class="language-plaintext highlighter-rouge">late</code> with <code class="language-plaintext highlighter-rouge">final</code>:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">Coffee</span> <span class="o">{</span>
  <span class="kd">late</span> <span class="kd">final</span> <span class="kt">String</span> <span class="n">_temperature</span><span class="o">;</span>

  <span class="kt">void</span> <span class="n">heat</span><span class="o">()</span> <span class="o">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s">'hot'</span><span class="o">;</span> <span class="o">}</span>
  <span class="kt">void</span> <span class="n">chill</span><span class="o">()</span> <span class="o">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s">'iced'</span><span class="o">;</span> <span class="o">}</span>

  <span class="kt">String</span> <span class="n">serve</span><span class="o">()</span> <span class="o">=&gt;</span> <span class="n">_temperature</span> <span class="o">+</span> <span class="s">' coffee'</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Unlike normal <code class="language-plaintext highlighter-rouge">final</code> fields, you do not have to initialize the field in its
declaration or in the constructor initialization list. You can assign to it
later at runtime. But you can only assign to it <em>once</em>, and that fact is checked
at runtime. If you try to assign to it more than once—like calling both
<code class="language-plaintext highlighter-rouge">heat()</code> and <code class="language-plaintext highlighter-rouge">chill()</code> here—the second assignment throws an exception.
This is a great way to model state that gets initialized eventually and is
immutable afterwards.</p>

<p>In other words, the new <code class="language-plaintext highlighter-rouge">late</code> modifier in combination with Dart’s other
variable modifiers covers most of the feature space of <code class="language-plaintext highlighter-rouge">lateinit</code> in Kotlin and
<code class="language-plaintext highlighter-rouge">lazy</code> in Swift. You can even use it on local variables if you want a little
local lazy evaluation.</p>

<h3 id="required-named-parameters">
<a class="anchor" href="#required-named-parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Required named parameters</h3>

<p>To guarantee that you never see a <code class="language-plaintext highlighter-rouge">null</code> parameter with a non-nullable type, the
type checker requires all optional parameters to either have a nullable type or
a default value. What if you want to have a named parameter with a non-nullable
type and no default value? That would imply that you want to require the caller
to <em>always</em> pass it. In other words, you want a parameter that is <em>named</em>
but not optional.</p>

<p>I visualize the various kinds of Dart parameters with this table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             mandatory    optional
            +------------+------------+
positional  | f(int x)   | f([int x]) |
            +------------+------------+
named       | ???        | f({int x}) |
            +------------+------------+
</code></pre></div></div>

<p>For unclear reasons, Dart has long supported three corners of this table but
left the combination of named+mandatory empty. With null safety, we filled that
in. You declare a required named parameter by placing <code class="language-plaintext highlighter-rouge">required</code> before the
parameter:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="n">function</span><span class="o">({</span><span class="kt">int</span><span class="o">?</span> <span class="n">a</span><span class="o">,</span> <span class="kd">required</span> <span class="kt">int</span><span class="o">?</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span><span class="o">?</span> <span class="n">c</span><span class="o">,</span> <span class="kd">required</span> <span class="kt">int</span><span class="o">?</span> <span class="n">d</span><span class="o">})</span> <span class="o">{}</span>
</code></pre></div></div>

<p>Here, all the parameters must be passed by name. The parameters <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">c</code> are
optional and can be omitted. The parameters <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">d</code> are required and must
be passed. Note that required-ness is independent of nullability. You can have
required named parameters of nullable types, and optional named parameters of
non-nullable types (if they have a default value).</p>

<p>This is another one of those features that I think makes Dart better regardless
of null safety. It simply makes the language feel more complete to me.</p>

<h3 id="abstract-fields">
<a class="anchor" href="#abstract-fields" aria-hidden="true"><span class="octicon octicon-link"></span></a>Abstract fields</h3>

<p>One of the neat features of Dart is that
it upholds a thing called the <a href="https://en.wikipedia.org/wiki/Uniform_access_principle">uniform access principle</a>.
In human terms it means that
fields are indistinguishable from getters and setters.
It’s an implementation detail whether a “property” in some Dart class
is computed or stored.
Because of this,
when defining an interface using an abstract class,
it’s typical to use a field declaration:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Cup</span> <span class="o">{</span>
  <span class="n">Beverage</span> <span class="n">contents</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The intent is that users only implement that class and don’t extend it.
The field syntax is simply a shorter way of writing a getter/setter pair:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Cup</span> <span class="o">{</span>
  <span class="n">Beverage</span> <span class="kd">get</span> <span class="n">contents</span><span class="o">;</span>
  <span class="kd">set</span> <span class="n">contents</span><span class="o">(</span><span class="n">Beverage</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But Dart doesn’t <em>know</em> that this class will never be used as a concrete type.
It sees that <code class="language-plaintext highlighter-rouge">contents</code> declaration as a real field.
And, unfortunately, that field is non-nullable and has no initializer,
so you get a compile error.</p>

<p>One fix is to use explicit abstract getter/setter declarations
like in the second example.
But that’s a little verbose,
so with null safety
we also added support for explicit abstract field declarations:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Cup</span> <span class="o">{</span>
  <span class="kd">abstract</span> <span class="n">Beverage</span> <span class="n">contents</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This behaves exactly like the second example.
It simply declares an abstract getter and setter with the given name and type.</p>

<h3 id="working-with-nullable-fields">
<a class="anchor" href="#working-with-nullable-fields" aria-hidden="true"><span class="octicon octicon-link"></span></a>Working with nullable fields</h3>

<p>These new features cover many common patterns and make working with <code class="language-plaintext highlighter-rouge">null</code>
pretty painless most of the time. But even so, our experience is that nullable
fields can still be difficult. In cases where you can make the field <code class="language-plaintext highlighter-rouge">late</code> and
non-nullable, you’re golden. But in many cases you need to <em>check</em> to see if the
field has a value, and that requires making it nullable so you can observe the
<code class="language-plaintext highlighter-rouge">null</code>.</p>

<p>You might expect this to work:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety, incorrectly:</span>
<span class="kd">class</span> <span class="nc">Coffee</span> <span class="o">{</span>
  <span class="kt">String</span><span class="o">?</span> <span class="n">_temperature</span><span class="o">;</span>

  <span class="kt">void</span> <span class="n">heat</span><span class="o">()</span> <span class="o">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s">'hot'</span><span class="o">;</span> <span class="o">}</span>
  <span class="kt">void</span> <span class="n">chill</span><span class="o">()</span> <span class="o">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s">'iced'</span><span class="o">;</span> <span class="o">}</span>

  <span class="kt">void</span> <span class="n">checkTemp</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">_temperature</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">print</span><span class="o">(</span><span class="s">'Ready to serve '</span> <span class="o">+</span> <span class="n">_temperature</span> <span class="o">+</span> <span class="s">'!'</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kt">String</span> <span class="n">serve</span><span class="o">()</span> <span class="o">=&gt;</span> <span class="n">_temperature</span><span class="o">!</span> <span class="o">+</span> <span class="s">' coffee'</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Inside <code class="language-plaintext highlighter-rouge">checkTemp()</code>, we check to see if <code class="language-plaintext highlighter-rouge">_temperature</code> is <code class="language-plaintext highlighter-rouge">null</code>. If not, we
access it and end up calling <code class="language-plaintext highlighter-rouge">+</code> on it. Unfortunately, this is not allowed.
Flow-based type promotion does not apply to fields because the static analysis
cannot <em>prove</em> that the field’s value doesn’t change between the point that you
check for <code class="language-plaintext highlighter-rouge">null</code> and the point that you use it. (Consider that in pathological
cases, the field itself could be overridden by a getter in a subclass that
returns <code class="language-plaintext highlighter-rouge">null</code> the second time it is called.)</p>

<p>So, since we care about soundness, fields don’t promote and the above method
does not compile. This is annoying. In simple cases like here, your best bet is
to slap a <code class="language-plaintext highlighter-rouge">!</code> on the use of the field. It seems redundant, but that’s more or
less how Dart behaves today.</p>

<p>Another pattern that helps is to copy the field to a local variable first and
then use that instead:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kt">void</span> <span class="nf">checkTemp</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">var</span> <span class="n">temperature</span> <span class="o">=</span> <span class="n">_temperature</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">temperature</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">'Ready to serve '</span> <span class="o">+</span> <span class="n">temperature</span> <span class="o">+</span> <span class="s">'!'</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Since the type promotion does apply to locals, this now works fine. If you need
to <em>change</em> the value, just remember to store back to the field and not just the
local.</p>

<p>For more information on handling these and other type promotion issues,
see <a href="/tools/non-promotion-reasons">Fixing type promotion failures</a>.</p>

<h3 id="nullability-and-generics">
<a class="anchor" href="#nullability-and-generics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nullability and generics</h3>

<p>Like most modern statically-typed languages, Dart has generic classes and
generic methods. They interact with nullability in a few ways that seem
counter-intuitive but make sense once you think through the implications. First
is that “is this type nullable?” is no longer a simple yes or no question.
Consider:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">T</span> <span class="n">object</span><span class="o">;</span>
  <span class="n">Box</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">object</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">main</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">Box</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;(</span><span class="s">'a string'</span><span class="o">);</span>
  <span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">?&gt;(</span><span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In the definition of <code class="language-plaintext highlighter-rouge">Box</code>, is <code class="language-plaintext highlighter-rouge">T</code> a nullable type or a non-nullable type? As
you can see, it can be instantiated with either kind. The answer is that <code class="language-plaintext highlighter-rouge">T</code> is a
<em>potentially nullable type</em>. Inside the body of a generic class or method, a
potentially nullable type has all of the restrictions of both nullable types
<em>and</em> non-nullable types.</p>

<p>The former means you can’t call any methods on it except the handful defined on
Object. The latter means that you must initialize any fields or variables of
that type before they’re used. This can make type parameters pretty hard to work with.</p>

<p>In practice, a few patterns show up. In collection-like classes where the type
parameter can be instantiated with any type at all, you just have to deal with
the restrictions. In most cases, like the example here, it means ensuring you do
have access to a value of the type argument’s type whenever you need to work
with one. Fortunately, collection-like classes rarely call methods on their
elements.</p>

<p>In places where you don’t have access to a value, you can make the use of the
type parameter nullable:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="n">T</span><span class="o">?</span> <span class="n">object</span><span class="o">;</span>
  <span class="n">Box</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
  <span class="n">Box</span><span class="o">.</span><span class="na">full</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">object</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note the <code class="language-plaintext highlighter-rouge">?</code> on the declaration of <code class="language-plaintext highlighter-rouge">object</code>. Now the field has an explicitly
nullable type, so it is fine to leave it uninitialized.</p>

<p>When you make a type parameter type nullable like <code class="language-plaintext highlighter-rouge">T?</code> here, you may need to
cast the nullability away. The correct way to do that is using an explicit <code class="language-plaintext highlighter-rouge">as
T</code> cast, <em>not</em> the <code class="language-plaintext highlighter-rouge">!</code> operator:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="n">T</span><span class="o">?</span> <span class="n">object</span><span class="o">;</span>
  <span class="n">Box</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
  <span class="n">Box</span><span class="o">.</span><span class="na">full</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">object</span><span class="o">);</span>

  <span class="n">T</span> <span class="n">unbox</span><span class="o">()</span> <span class="o">=&gt;</span> <span class="n">object</span> <span class="k">as</span> <span class="n">T</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">!</code> operator <em>always</em> throws if the value is <code class="language-plaintext highlighter-rouge">null</code>. But if the type
parameter has been instantiated with a nullable type, then <code class="language-plaintext highlighter-rouge">null</code> is a perfectly
valid value for <code class="language-plaintext highlighter-rouge">T</code>:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="n">main</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">var</span> <span class="n">box</span> <span class="o">=</span> <span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">?&gt;.</span><span class="na">full</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
  <span class="n">print</span><span class="o">(</span><span class="n">box</span><span class="o">.</span><span class="na">unbox</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This program should run without error. Using <code class="language-plaintext highlighter-rouge">as T</code> accomplishes that. Using
<code class="language-plaintext highlighter-rouge">!</code> would throw an exception.</p>

<p>Other generic types have some bound that restricts the kinds of type arguments
that can be applied:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">Interval</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="kt">num</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="n">T</span> <span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">;</span>

  <span class="n">Interval</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">min</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">max</span><span class="o">);</span>

  <span class="kt">bool</span> <span class="kd">get</span> <span class="n">isEmpty</span> <span class="o">=&gt;</span> <span class="n">max</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If the bound is non-nullable, then the type parameter is also non-nullable. This
means you have the restrictions of non-nullable types—you can’t leave
fields and variables uninitialized. The example class here must have a
constructor that initializes the fields.</p>

<p>In return for that restriction, you can call any methods on values of the type
parameter type that are declared on its bound. Having a non-nullable bound does,
however, prevent <em>users</em> of your generic class from instantiating it with a
nullable type argument. That’s probably a reasonable limitation for most
classes.</p>

<p>You can also use a nullable <em>bound</em>:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">class</span> <span class="nc">Interval</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="kt">num</span><span class="o">?&gt;</span> <span class="o">{</span>
  <span class="n">T</span> <span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">;</span>

  <span class="n">Interval</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">min</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">max</span><span class="o">);</span>

  <span class="kt">bool</span> <span class="kd">get</span> <span class="n">isEmpty</span> <span class="o">{</span>
    <span class="kd">var</span> <span class="n">localMin</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
    <span class="kd">var</span> <span class="n">localMax</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>

    <span class="c1">// No min or max means an open-ended interval.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">localMin</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">localMax</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">localMax</span> <span class="o">&lt;=</span> <span class="n">localMin</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This means that in the body of the class you get the flexibility of treating the
type parameter as nullable, but you also have the limitations of nullability. 
You can’t call anything on a variable of that type
unless you deal with the nullability first. In the example here, 
we copy the fields in local variables and check those locals for <code class="language-plaintext highlighter-rouge">null</code> 
so that flow analysis promotes them to non-nullable types before we use <code class="language-plaintext highlighter-rouge">&lt;=</code>.</p>

<p>Note that a nullable bound does not prevent users from instantiating the class
with non-nullable types. A nullable bound means that the type argument <em>can</em> be
nullable, not that it <em>must</em>. (In fact, the default bound on type parameters if
you don’t write an <code class="language-plaintext highlighter-rouge">extends</code> clause is the nullable bound <code class="language-plaintext highlighter-rouge">Object?</code>.) There is
no way to <em>require</em> a nullable type argument. If you want uses of the type
parameter to reliably be nullable and be implicitly initialized to <code class="language-plaintext highlighter-rouge">null</code>, 
you can use <code class="language-plaintext highlighter-rouge">T?</code> inside the body of the class.</p>

<h2 id="core-library-changes">
<a class="anchor" href="#core-library-changes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Core library changes</h2>

<p>There are a couple of other tweaks here and there in the language, but they are
minor. Things like the default type of a <code class="language-plaintext highlighter-rouge">catch</code> with no <code class="language-plaintext highlighter-rouge">on</code> clause is now
<code class="language-plaintext highlighter-rouge">Object</code> instead of <code class="language-plaintext highlighter-rouge">dynamic</code>. Fallthrough analysis in switch statements uses
the new flow analysis.</p>

<p>The remaining changes that really matter to you are in the core libraries.
Before we embarked on the Grand Null Safety Adventure, we worried that it would
turn out there was no way to make our core libraries null safe without massively
breaking the world. It turned out not so dire. There <em>are</em> a few significant
changes, but for the most part, the migration went smoothly. Most core libraries
either did not accept <code class="language-plaintext highlighter-rouge">null</code> and naturally move to non-nullable types, or do and
gracefully accept it with a nullable type.</p>

<p>There are a few important corners, though:</p>

<h3 id="the-map-index-operator-is-nullable">
<a class="anchor" href="#the-map-index-operator-is-nullable" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Map index operator is nullable</h3>

<p>This isn’t really a change, but more a thing to know. The index <code class="language-plaintext highlighter-rouge">[]</code> operator on
the Map class returns <code class="language-plaintext highlighter-rouge">null</code> if the key isn’t present. This implies that the
return type of that operator must be nullable: <code class="language-plaintext highlighter-rouge">V?</code> instead of <code class="language-plaintext highlighter-rouge">V</code>.</p>

<p>We could have changed that method to throw an exception when the key isn’t
present and then given it an easier-to-use non-nullable return type. But code
that uses the index operator and checks for <code class="language-plaintext highlighter-rouge">null</code> to see if the key is absent
is very common, around half of all uses based on our analysis. Breaking all of
that code would have set the Dart ecosystem aflame.</p>

<p>Instead, the runtime behavior is the same and thus the return type is obliged
to be nullable. This means you generally cannot immediately use the result of
a map lookup:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety, incorrectly:</span>
<span class="kd">var</span> <span class="n">map</span> <span class="o">=</span> <span class="o">{</span><span class="s">'key'</span><span class="o">:</span> <span class="s">'value'</span><span class="o">};</span>
<span class="n">print</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="s">'key'</span><span class="o">].</span><span class="na">length</span><span class="o">);</span> <span class="c1">// Error.</span>
</code></pre></div></div>

<p>This gives you a compile error on the attempt to call <code class="language-plaintext highlighter-rouge">.length</code> on a nullable
string. In cases where you <em>know</em> the key is present you can teach the type
checker by using <code class="language-plaintext highlighter-rouge">!</code>:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using null safety:</span>
<span class="kd">var</span> <span class="n">map</span> <span class="o">=</span> <span class="o">{</span><span class="s">'key'</span><span class="o">:</span> <span class="s">'value'</span><span class="o">};</span>
<span class="n">print</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="s">'key'</span><span class="o">]!.</span><span class="na">length</span><span class="o">);</span> <span class="c1">// OK.</span>
</code></pre></div></div>

<p>We considered adding another method to Map that would do this for you: look up
the key, throw if not found, or return a non-nullable value otherwise. But what
to call it? No name would be shorter than the single-character <code class="language-plaintext highlighter-rouge">!</code>, and no
method name would be clearer than seeing a <code class="language-plaintext highlighter-rouge">!</code> with its built-in semantics right
there at the call site. So the idiomatic way to access a known-present element
in a map is to use <code class="language-plaintext highlighter-rouge">[]!</code>. You get used to it.</p>

<h3 id="no-unnamed-list-constructor">
<a class="anchor" href="#no-unnamed-list-constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>No unnamed List constructor</h3>

<p>The unnamed constructor on <code class="language-plaintext highlighter-rouge">List</code> creates a new list with the given size but
does not initialize any of the elements. This would poke a very large hole in
the soundness guarantees if you created a list of a non-nullable type and then
accessed an element.</p>

<p>To avoid that, we have removed the constructor entirely. It is an error to call
<code class="language-plaintext highlighter-rouge">List()</code> in null safe code, even with a nullable type. That sounds scary, but
in practice most code creates lists using list literals, <code class="language-plaintext highlighter-rouge">List.filled()</code>,
<code class="language-plaintext highlighter-rouge">List.generate()</code>, or as a result of transforming some other collection. For
the edge case where you want to create an empty list of some type, we added a
new <code class="language-plaintext highlighter-rouge">List.empty()</code> constructor.</p>

<p>The pattern of creating a completely uninitialized list has always felt out of
place in Dart, and now it is even more so. If you have code broken by this,
you can always fix it by using one of the many other ways to produce a list.</p>

<h3 id="cannot-set-a-larger-length-on-non-nullable-lists">
<a class="anchor" href="#cannot-set-a-larger-length-on-non-nullable-lists" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cannot set a larger length on non-nullable lists</h3>

<p>This is little known, but the <code class="language-plaintext highlighter-rouge">length</code> getter on <code class="language-plaintext highlighter-rouge">List</code> also has a corresponding
<em>setter</em>. You can set the length to a shorter value to truncate the list. And
you can also set it to a <em>longer</em> length to pad the list with uninitialized
elements.</p>

<p>If you were to do that with a list of a non-nullable type, you’d violate
soundness when you later accessed those unwritten elements. To prevent that, the
<code class="language-plaintext highlighter-rouge">length</code> setter will throw a runtime exception if (and only if) the list has a
non-nullable element type <em>and</em> you set it to a <em>longer</em> length. It is still
fine to truncate lists of all types, and you can grow lists of nullable types.</p>

<p>There is an important consequence of this if you define your own list types that
extend <code class="language-plaintext highlighter-rouge">ListBase</code> or apply <code class="language-plaintext highlighter-rouge">ListMixin</code>. Both of those types provide an
implementation of <code class="language-plaintext highlighter-rouge">insert()</code> that previously made room for the inserted element
by setting the length. That would fail with null safety, so instead we changed
the implementation of <code class="language-plaintext highlighter-rouge">insert()</code> in <code class="language-plaintext highlighter-rouge">ListMixin</code> (which <code class="language-plaintext highlighter-rouge">ListBase</code> shares) to
call <code class="language-plaintext highlighter-rouge">add()</code> instead. Your custom list class should provide a definition of
<code class="language-plaintext highlighter-rouge">add()</code> if you want to be able to use that inherited <code class="language-plaintext highlighter-rouge">insert()</code> method.</p>

<h3 id="cannot-access-iteratorcurrent-before-or-after-iteration">
<a class="anchor" href="#cannot-access-iteratorcurrent-before-or-after-iteration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cannot access Iterator.current before or after iteration</h3>

<p>The <code class="language-plaintext highlighter-rouge">Iterator</code> class is the mutable “cursor” class used to traverse the elements
of a type that implements <code class="language-plaintext highlighter-rouge">Iterable</code>. You are expected to call <code class="language-plaintext highlighter-rouge">moveNext()</code>
before accessing any elements to advance to the first element. When that method
returns <code class="language-plaintext highlighter-rouge">false</code>, you have reached the end and there are no more elements.</p>

<p>It used to be that <code class="language-plaintext highlighter-rouge">current</code> returned <code class="language-plaintext highlighter-rouge">null</code> if you called it either before
calling <code class="language-plaintext highlighter-rouge">moveNext()</code> the first time or after iteration finished. With null
safety, that would require the return type of <code class="language-plaintext highlighter-rouge">current</code> to be <code class="language-plaintext highlighter-rouge">E?</code> and not <code class="language-plaintext highlighter-rouge">E</code>.
That in turn means every element access would require a runtime <code class="language-plaintext highlighter-rouge">null</code> check.</p>

<p>Those checks would be useless given that almost no one ever accesses the current
element in that erroneous way. Instead, we have made the type of <code class="language-plaintext highlighter-rouge">current</code> be
<code class="language-plaintext highlighter-rouge">E</code>. Since there <em>may</em> be a value of that type available before or after
iterating, we’ve left the iterator’s behavior undefined if you call it when you
aren’t supposed to. Most implementations of <code class="language-plaintext highlighter-rouge">Iterator</code> throw a <code class="language-plaintext highlighter-rouge">StateError</code>.</p>

<h2 id="summary">
<a class="anchor" href="#summary" aria-hidden="true"><span class="octicon octicon-link"></span></a>Summary</h2>

<p>That is a very detailed tour through all of the language and library changes
around null safety. It’s a lot of stuff, but this is a pretty big language
change. More importantly, we wanted to get to a point where Dart still feels
cohesive and usable. That requires changing not just the type system, but a
number of other usability features around it. We didn’t want it to feel like
null safety was bolted on.</p>

<p>The core points to take away are:</p>

<ul>
  <li>
    <p>Types are non-nullable by default and made nullable by adding <code class="language-plaintext highlighter-rouge">?</code>.</p>
  </li>
  <li>
    <p>Optional parameters must be nullable or have a default value. You can use
<code class="language-plaintext highlighter-rouge">required</code> to make named parameters non-optional. Non-nullable top-level
variables and static fields must have initializers. Non-nullable instance
fields must be initialized before the constructor body begins.</p>
  </li>
  <li>
    <p>Method chains after null-aware operators short circuit if the receiver is
<code class="language-plaintext highlighter-rouge">null</code>. There are new null-aware cascade (<code class="language-plaintext highlighter-rouge">?..</code>) and index (<code class="language-plaintext highlighter-rouge">?[]</code>)
operators. The postfix null assertion “bang” operator (<code class="language-plaintext highlighter-rouge">!</code>) casts its
nullable operand to the underlying non-nullable type.</p>
  </li>
  <li>
    <p>Flow analysis lets you safely turn nullable local variables and parameters
into usable non-nullable ones. The new flow analysis also has smarter rules
for type promotion, missing returns, unreachable code, and variable
initialization.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">late</code> modifier lets you use non-nullable types and <code class="language-plaintext highlighter-rouge">final</code> in places
you otherwise might not be able to, at the expense of runtime checking. It
also gives you lazy-initialized fields.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">List</code> class is changed to prevent uninitialized elements.</p>
  </li>
</ul>

<p>Finally, once you absorb all of that and get your code into the world of null
safety, you get a sound program that the compilers can optimize and where every
place a runtime error can occur is visible in your code. We hope you feel that’s
worth the effort to get there.</p>

          

        </div>
      </article>
    </main>
    <footer id="page-footer">
  <div class="footer-section footer-main">
    <a href="/" class="brand" title="Dart">
      <img src="/assets/img/shared/dart/logo+text/horizontal/white.svg" alt="Dart" width="164px">
    </a>
    <div class="footer-social-links">
      <a href="https://medium.com/dartlang" target="_blank" rel="noopener" title="Medium blog" class="no-automatic-external">
        <svg>
          <use href="/assets/img/social/medium.svg#medium"></use>
        </svg>
      </a>
      <a href="https://github.com/dart-lang" target="_blank" rel="noopener" title="GitHub" class="no-automatic-external">
        <svg>
          <use href="/assets/img/social/github.svg#github"></use>
        </svg>
      </a>
      <a href="https://twitter.com/dart_lang" target="_blank" rel="noopener" title="Twitter" class="no-automatic-external">
        <svg>
          <use href="/assets/img/social/twitter.svg#twitter"></use>
        </svg>
      </a>
    </div>
  </div>
  <div class="footer-section footer-tray">
    <div class="footer-licenses">
      Salvo que se indique lo contrario, este sitio está bajo una 
      <a href="https://creativecommons.org/licenses/by/4.0/" class="no-automatic-external">licencia internacional Creative Commons Attribution 4.0</a >, 
      y los ejemplos de código tienen licencia 
      <a href="https://opensource.org/licenses/BSD-3-Clause" class="no-automatic-external">3-Clause BSD License</a>.
    </div>
    <div class="footer-utility-links">
      <ul>
        <li><a href="/terms" title="Terms of use">Términos</a></li>
        <li><a href="https://policies.google.com/privacy" target="_blank" rel="noopener" title="Privacy policy" class="no-automatic-external">Privacidad</a></li>
        <li><a href="/security" title="Security philosophy and practices">Seguridad</a></li>
      </ul>
    </div>
  </div>
</footer>

   
  </body>
</html>
